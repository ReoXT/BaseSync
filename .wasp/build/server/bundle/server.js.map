{"version":3,"file":"server.js","sources":["../../../out/sdk/wasp/dist/universal/ansiColors.js","../../../out/sdk/wasp/dist/env/validation.js","../../../out/sdk/wasp/dist/server/env.js","../../../out/sdk/wasp/dist/universal/url.js","../../../out/sdk/wasp/dist/server/config.js","../../../out/sdk/wasp/dist/server/dbClient.js","../../../out/sdk/wasp/dist/server/HttpError.js","../../../out/sdk/wasp/dist/auth/lucia.js","../../../out/sdk/wasp/dist/auth/password.js","../../../out/sdk/wasp/dist/server/utils.js","../../../out/sdk/wasp/dist/auth/validation.js","../../../out/sdk/wasp/dist/auth/utils.js","../../../out/sdk/wasp/dist/server/auth/user.js","../../../out/sdk/wasp/dist/auth/session.js","../../../out/sdk/wasp/dist/core/auth.js","../../../out/sdk/wasp/dist/core/serialization/prisma.js","../../../out/sdk/wasp/dist/universal/predicates.js","../../../out/sdk/wasp/dist/auth/user.js","../src/middleware/operations.ts","../../../../src/server/utils.ts","../../../../src/payment/plans.ts","../../../../src/server/validation.ts","../../../../src/user/operations.ts","../src/actions/updateIsUserAdminById.ts","../src/routes/operations/updateIsUserAdminById.js","../../../../src/user/accountSettings.ts","../src/actions/updateUsername.ts","../src/routes/operations/updateUsername.js","../src/actions/requestEmailChange.ts","../src/routes/operations/requestEmailChange.js","../src/actions/confirmEmailChange.ts","../src/routes/operations/confirmEmailChange.js","../src/actions/updateNotificationPreferences.ts","../src/routes/operations/updateNotificationPreferences.js","../../../../src/user/security.ts","../src/actions/changePassword.ts","../src/routes/operations/changePassword.js","../../../../src/payment/stripe/stripeClient.ts","../../../../src/user/dangerZone.ts","../src/actions/deleteAccount.ts","../src/routes/operations/deleteAccount.js","../../../../src/shared/utils.ts","../../../../src/payment/user.ts","../../../../src/payment/stripe/checkoutUtils.ts","../../../out/sdk/wasp/dist/server/email/core/helpers.js","../../../out/sdk/wasp/dist/server/email/core/providers/smtp.js","../../../out/sdk/wasp/dist/server/email/index.js","../../../../src/payment/errors.ts","../../../../src/payment/stripe/webhook.ts","../../../../src/payment/stripe/paymentProcessor.ts","../../../../src/payment/paymentProcessor.ts","../../../../src/payment/operations.ts","../src/actions/generateCheckoutSession.ts","../src/routes/operations/generateCheckoutSession.js","../../../../src/server/admin/operations.ts","../src/actions/updateUser.ts","../src/routes/operations/updateUser.js","../src/actions/deleteUser.ts","../src/routes/operations/deleteUser.js","../src/actions/pauseResumeSync.ts","../src/routes/operations/pauseResumeSync.js","../src/actions/triggerManualSyncAdmin.ts","../src/routes/operations/triggerManualSyncAdmin.js","../src/actions/forceRefreshUserToken.ts","../src/routes/operations/forceRefreshUserToken.js","../../../../src/server/airtable/encryption.ts","../../../../src/server/airtable/auth.ts","../../../../src/server/airtable/operations.ts","../src/actions/initiateAirtableAuth.ts","../src/routes/operations/initiateAirtableAuth.js","../src/actions/completeAirtableAuth.ts","../src/routes/operations/completeAirtableAuth.js","../src/actions/disconnectAirtable.ts","../src/routes/operations/disconnectAirtable.js","../../../../src/server/google/auth.ts","../../../../src/server/google/operations.ts","../src/actions/initiateGoogleAuth.ts","../src/routes/operations/initiateGoogleAuth.js","../src/actions/completeGoogleAuth.ts","../src/routes/operations/completeGoogleAuth.js","../src/actions/disconnectGoogle.ts","../src/routes/operations/disconnectGoogle.js","../../../../src/server/airtable/client.ts","../../../../src/server/google/client.ts","../../../../src/server/sync/fieldMapper.ts","../../../../src/server/sync/linkedRecordResolver.ts","../../../../src/server/sync/dropdownFieldDetector.ts","../../../../src/server/sync/airtableToSheets.ts","../../../../src/server/sync/sheetsToAirtable.ts","../../../../src/server/sync/conflictDetector.ts","../../../../src/server/sync/bidirectionalSync.ts","../../../../src/server/utils/tokenManager.ts","../../../../src/server/middleware/usageLimits.ts","../../../../src/server/email/resendEmailSender.ts","../../../../src/server/emails/baseSyncEmails.ts","../../../../src/server/emails/notificationSender.ts","../../../../src/server/utils/usageTracker.ts","../../../../src/server/actions/sync.ts","../src/actions/triggerManualSync.ts","../src/routes/operations/triggerManualSync.js","../src/actions/runInitialSync.ts","../src/routes/operations/runInitialSync.js","../../../../src/server/actions/syncConfig.ts","../src/actions/createSyncConfig.ts","../src/routes/operations/createSyncConfig.js","../src/actions/updateSyncConfig.ts","../src/routes/operations/updateSyncConfig.js","../src/actions/deleteSyncConfig.ts","../src/routes/operations/deleteSyncConfig.js","../src/actions/toggleSyncActive.ts","../src/routes/operations/toggleSyncActive.js","../../../../src/server/actions/diagnostics.ts","../src/actions/runConnectionDiagnostics.ts","../src/routes/operations/runConnectionDiagnostics.js","../src/actions/clearReauthFlags.ts","../src/routes/operations/clearReauthFlags.js","../../../../src/auth/email-and-pass/emails.ts","../../../../src/server/emails/testSender.ts","../src/actions/sendTestEmails.ts","../src/routes/operations/sendTestEmails.js","../src/queries/getPaginatedUsers.ts","../src/routes/operations/getPaginatedUsers.js","../src/queries/exportUserData.ts","../src/routes/operations/exportUserData.js","../src/queries/getCustomerPortalUrl.ts","../src/routes/operations/getCustomerPortalUrl.js","../../../../src/analytics/operations.ts","../src/queries/getDailyStats.ts","../src/routes/operations/getDailyStats.js","../src/queries/getAdminOverviewStats.ts","../src/routes/operations/getAdminOverviewStats.js","../src/queries/getRecentActivity.ts","../src/routes/operations/getRecentActivity.js","../src/queries/searchUsers.ts","../src/routes/operations/searchUsers.js","../src/queries/getOnlineUsers.ts","../src/routes/operations/getOnlineUsers.js","../src/queries/getUserDetail.ts","../src/routes/operations/getUserDetail.js","../src/queries/getActiveSyncs.ts","../src/routes/operations/getActiveSyncs.js","../src/queries/getFailedSyncs.ts","../src/routes/operations/getFailedSyncs.js","../src/queries/getSyncMonitor.ts","../src/routes/operations/getSyncMonitor.js","../src/queries/getAirtableConnectionStatus.ts","../src/routes/operations/getAirtableConnectionStatus.js","../../../../src/server/airtable/queries.ts","../src/queries/listUserAirtableBases.ts","../src/routes/operations/listUserAirtableBases.js","../src/queries/getAirtableTableSchema.ts","../src/routes/operations/getAirtableTableSchema.js","../src/queries/getAirtableBaseTables.ts","../src/routes/operations/getAirtableBaseTables.js","../src/queries/getGoogleConnectionStatus.ts","../src/routes/operations/getGoogleConnectionStatus.js","../../../../src/server/google/urlParser.ts","../../../../src/server/google/queries.ts","../src/queries/validateSpreadsheetUrl.ts","../src/routes/operations/validateSpreadsheetUrl.js","../src/queries/getSpreadsheetSheets.ts","../src/routes/operations/getSpreadsheetSheets.js","../src/queries/getSheetColumnHeaders.ts","../src/routes/operations/getSheetColumnHeaders.js","../../../../src/server/queries/syncConfig.ts","../src/queries/getUserSyncConfigs.ts","../src/routes/operations/getUserSyncConfigs.js","../src/queries/getSyncConfigById.ts","../src/routes/operations/getSyncConfigById.js","../src/queries/getSyncLogs.ts","../src/routes/operations/getSyncLogs.js","../../../../src/server/queries/usage.ts","../src/queries/getUserUsage.ts","../src/routes/operations/getUserUsage.js","../src/routes/operations/index.js","../src/middleware/globalMiddleware.ts","../src/routes/auth/me.ts","../src/routes/auth/logout.ts","../src/auth/hooks.ts","../src/auth/providers/email/login.ts","../../../out/sdk/wasp/dist/auth/jwt.js","../../../out/sdk/wasp/dist/server/auth/email/utils.js","../src/auth/providers/email/signup.ts","../src/auth/providers/email/requestPasswordReset.ts","../src/auth/providers/email/resetPassword.ts","../src/auth/providers/email/verifyEmail.ts","../../../out/sdk/wasp/dist/auth/providers/types.js","../../../../src/auth/userSignupFields.ts","../src/auth/providers/config/email.ts","../src/auth/providers/index.ts","../src/routes/auth/index.js","../../../../src/payment/webhook.ts","../src/routes/apis/index.ts","../src/routes/index.js","../src/app.js","../../../../src/server/serverSetup.ts","../../../out/sdk/wasp/dist/server/jobs/core/pgBoss/pgBoss.js","../../../out/sdk/wasp/dist/server/jobs/core/job.js","../../../out/sdk/wasp/dist/server/jobs/core/pgBoss/pgBossJob.js","../../../../src/analytics/providers/plausibleAnalyticsUtils.ts","../../../../src/payment/polar/polarClient.ts","../../../../src/analytics/stats.ts","../../../out/sdk/wasp/dist/server/jobs/dailyStatsJob.js","../../../out/sdk/wasp/dist/server/jobs/syncJob.js","../src/jobs/dailyStatsJob.ts","../../../../src/server/jobs/syncJob.ts","../src/jobs/syncJob.ts","../src/server.ts"],"sourcesContent":["export const colors = {\n    red: '\\x1b[31m',\n    yellow: '\\x1b[33m',\n};\nexport const resetColor = \"\\x1b[0m\";\n// PRIVATE API (SDK, client)\n// Used with console.log() to colorize the output\n// Example: console.log(getColorizedConsoleFormatString('red'), 'This is red text');\nexport function getColorizedConsoleFormatString(colorKey) {\n    const color = colors[colorKey];\n    return `${color}%s${resetColor}`;\n}\n//# sourceMappingURL=ansiColors.js.map","import { getColorizedConsoleFormatString } from 'wasp/universal/ansiColors';\nconst redColorFormatString = getColorizedConsoleFormatString('red');\n// PRIVATE API (SDK)\nexport function ensureEnvSchema(data, schema) {\n    const result = getValidatedEnvOrError(data, schema);\n    if (result.success) {\n        return result.data;\n    }\n    else {\n        console.error(`${redColorFormatString}${formatZodEnvErrors(result.error.issues)}`);\n        throw new Error('Error parsing environment variables');\n    }\n}\n// PRIVATE API (SDK, Vite config)\nexport function getValidatedEnvOrError(env, schema) {\n    return schema.safeParse(env);\n}\n// PRIVATE API (SDK, Vite config)\nexport function formatZodEnvErrors(issues) {\n    const errorOutput = ['', 'â•â• Env vars validation failed â•â•', ''];\n    for (const error of issues) {\n        errorOutput.push(` - ${error.message}`);\n    }\n    errorOutput.push('');\n    errorOutput.push('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');\n    return errorOutput.join('\\n');\n}\n//# sourceMappingURL=validation.js.map","import * as z from 'zod';\nimport { ensureEnvSchema } from '../env/validation.js';\nconst userServerEnvSchema = z.object({});\nconst waspServerCommonSchema = z.object({\n    PORT: z.coerce.number().default(3001),\n    DATABASE_URL: z.string({\n        required_error: 'DATABASE_URL is required',\n    }),\n    PG_BOSS_NEW_OPTIONS: z.string().optional(),\n    SMTP_HOST: z.string({\n        required_error: getRequiredEnvVarErrorMessage('SMTP email sender', 'SMTP_HOST'),\n    }),\n    SMTP_PORT: z.coerce.number({\n        required_error: getRequiredEnvVarErrorMessage('SMTP email sender', 'SMTP_PORT'),\n        invalid_type_error: 'SMTP_PORT must be a number',\n    }),\n    SMTP_USERNAME: z.string({\n        required_error: getRequiredEnvVarErrorMessage('SMTP email sender', 'SMTP_USERNAME'),\n    }),\n    SMTP_PASSWORD: z.string({\n        required_error: getRequiredEnvVarErrorMessage('SMTP email sender', 'SMTP_PASSWORD'),\n    }),\n    SKIP_EMAIL_VERIFICATION_IN_DEV: z\n        .enum(['true', 'false'], {\n        message: 'SKIP_EMAIL_VERIFICATION_IN_DEV must be either \"true\" or \"false\"',\n    })\n        .transform((value) => value === 'true')\n        .default('false'),\n});\nconst serverUrlSchema = z\n    .string({\n    required_error: 'WASP_SERVER_URL is required',\n})\n    .url({\n    message: 'WASP_SERVER_URL must be a valid URL',\n});\nconst clientUrlSchema = z\n    .string({\n    required_error: 'WASP_WEB_CLIENT_URL is required',\n})\n    .url({\n    message: 'WASP_WEB_CLIENT_URL must be a valid URL',\n});\nconst jwtTokenSchema = z\n    .string({\n    required_error: 'JWT_SECRET is required',\n});\n// In development, we provide default values for some environment variables\n// to make the development process easier.\nconst serverDevSchema = z.object({\n    NODE_ENV: z.literal('development'),\n    \"WASP_SERVER_URL\": serverUrlSchema\n        .default('http://localhost:3001'),\n    \"WASP_WEB_CLIENT_URL\": clientUrlSchema\n        .default('http://localhost:3000/'),\n    \"JWT_SECRET\": jwtTokenSchema\n        .default('DEVJWTSECRET'),\n});\nconst serverProdSchema = z.object({\n    NODE_ENV: z.literal('production'),\n    \"WASP_SERVER_URL\": serverUrlSchema,\n    \"WASP_WEB_CLIENT_URL\": clientUrlSchema,\n    \"JWT_SECRET\": jwtTokenSchema,\n});\nconst serverCommonSchema = userServerEnvSchema.merge(waspServerCommonSchema);\nconst serverEnvSchema = z.discriminatedUnion('NODE_ENV', [\n    serverDevSchema.merge(serverCommonSchema),\n    serverProdSchema.merge(serverCommonSchema)\n]);\nconst defaultNodeEnvValue = serverDevSchema.shape.NODE_ENV.value;\nconst { NODE_ENV: inputNodeEnvValue, ...restEnv } = process.env;\n// PUBLIC API\nexport const env = ensureEnvSchema({\n    NODE_ENV: inputNodeEnvValue ?? defaultNodeEnvValue,\n    ...restEnv,\n}, serverEnvSchema);\nfunction getRequiredEnvVarErrorMessage(featureName, envVarName) {\n    return `${envVarName} is required when using ${featureName}`;\n}\n//# sourceMappingURL=env.js.map","export function stripTrailingSlash(url) {\n    return url?.replace(/\\/$/, \"\");\n}\nexport function getOrigin(url) {\n    return new URL(url).origin;\n}\n//# sourceMappingURL=url.js.map","import { env } from './env.js';\nimport { stripTrailingSlash, getOrigin } from '../universal/url.js';\nconst frontendUrl = stripTrailingSlash(env['WASP_WEB_CLIENT_URL']);\nconst serverUrl = stripTrailingSlash(env['WASP_SERVER_URL']);\nconst allowedCORSOriginsPerEnv = {\n    development: [/.*/],\n    production: [getOrigin(frontendUrl)]\n};\nconst allowedCORSOrigins = allowedCORSOriginsPerEnv[env.NODE_ENV];\nconst config = {\n    frontendUrl,\n    serverUrl,\n    allowedCORSOrigins,\n    env: env.NODE_ENV,\n    isDevelopment: env.NODE_ENV === 'development',\n    port: env.PORT,\n    databaseUrl: env.DATABASE_URL,\n    auth: {\n        jwtSecret: env[\"JWT_SECRET\"]\n    }\n};\n// PUBLIC API\nexport default config;\n//# sourceMappingURL=config.js.map","import { PrismaClient as InternalPrismaClient } from '@prisma/client';\nfunction createDbClient() {\n    return new InternalPrismaClient();\n}\nconst dbClient = createDbClient();\n// PUBLIC API\nexport default dbClient;\n//# sourceMappingURL=dbClient.js.map","export class HttpError extends Error {\n    statusCode;\n    data;\n    constructor(statusCode, message, data, options) {\n        super(message, options);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, HttpError);\n        }\n        this.name = this.constructor.name;\n        if (!(Number.isInteger(statusCode) && statusCode >= 400 && statusCode < 600)) {\n            throw new Error('statusCode has to be integer in range [400, 600).');\n        }\n        this.statusCode = statusCode;\n        if (data) {\n            this.data = data;\n        }\n    }\n}\n//# sourceMappingURL=HttpError.js.map","import { Lucia } from \"lucia\";\nimport { PrismaAdapter } from \"@lucia-auth/adapter-prisma\";\nimport { prisma } from 'wasp/server';\nconst prismaAdapter = new PrismaAdapter(prisma.session, prisma.auth);\n// PRIVATE API\n/**\n * We are using Lucia for session management.\n *\n * Some details:\n * 1. We are using the Prisma adapter for Lucia.\n * 2. We are not using cookies for session management. Instead, we are using\n *    the Authorization header to send the session token.\n * 3. Our `Session` entity is connected to the `Auth` entity.\n * 4. We are exposing the `userId` field from the `Auth` entity to\n *    make fetching the User easier.\n */\nexport const auth = new Lucia(prismaAdapter, {\n    // Since we are not using cookies, we don't need to set any cookie options.\n    // But in the future, if we decide to use cookies, we can set them here.\n    // sessionCookie: {\n    //   name: \"session\",\n    //   expires: true,\n    //   attributes: {\n    //     secure: !config.isDevelopment,\n    //     sameSite: \"lax\",\n    //   },\n    // },\n    getUserAttributes({ userId }) {\n        return {\n            userId,\n        };\n    },\n});\n//# sourceMappingURL=lucia.js.map","import { hash, verify } from \"@node-rs/argon2\";\n// The options are the same as the ones used in the oslo/password library\nconst hashingOptions = {\n    memoryCost: 19456,\n    timeCost: 2,\n    outputLen: 32,\n    parallelism: 1,\n    version: 1 /* Version.V0x13 */,\n};\n// PRIVATE API\nexport async function hashPassword(password) {\n    return hash(normalizePassword(password), hashingOptions);\n}\n// PRIVATE API\nexport async function verifyPassword(hashedPassword, password) {\n    const validPassword = await verify(hashedPassword, normalizePassword(password), hashingOptions);\n    if (!validPassword) {\n        throw new Error(\"Invalid password\");\n    }\n}\n// We are normalising the password to ensure that the password is always hashed in the same way\n// We have the same normalising process as oslo/password did in the past\nfunction normalizePassword(password) {\n    return password.normalize(\"NFKC\");\n}\n//# sourceMappingURL=password.js.map","/**\n * Simple helper to give the correct types for Express handlers.\n * We define it in the same file as our extension to Request\n * so that it is picked up by TypeScript.\n */\nexport const defineHandler = (middleware) => middleware;\nexport const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nexport function redirect(res, redirectUri) {\n    return res\n        .status(302)\n        .setHeader(\"Location\", redirectUri)\n        .end();\n}\n//# sourceMappingURL=utils.js.map","import { HttpError } from 'wasp/server';\nexport const PASSWORD_FIELD = 'password';\nconst USERNAME_FIELD = 'username';\nconst EMAIL_FIELD = 'email';\nconst TOKEN_FIELD = 'token';\n// PUBLIC API\nexport function ensureValidEmail(args) {\n    validate(args, [\n        { validates: EMAIL_FIELD, message: 'email must be present', validator: email => !!email },\n        { validates: EMAIL_FIELD, message: 'email must be a valid email', validator: email => isValidEmail(email) },\n    ]);\n}\n// PUBLIC API\nexport function ensureValidUsername(args) {\n    validate(args, [\n        { validates: USERNAME_FIELD, message: 'username must be present', validator: username => !!username }\n    ]);\n}\n// PUBLIC API\nexport function ensurePasswordIsPresent(args) {\n    validate(args, [\n        { validates: PASSWORD_FIELD, message: 'password must be present', validator: password => !!password },\n    ]);\n}\n// PUBLIC API\nexport function ensureValidPassword(args) {\n    validate(args, [\n        { validates: PASSWORD_FIELD, message: 'password must be at least 8 characters', validator: password => isMinLength(password, 8) },\n        { validates: PASSWORD_FIELD, message: 'password must contain a number', validator: password => containsNumber(password) },\n    ]);\n}\n// PUBLIC API\nexport function ensureTokenIsPresent(args) {\n    validate(args, [\n        { validates: TOKEN_FIELD, message: 'token must be present', validator: token => !!token },\n    ]);\n}\n// PRIVATE API\nexport function throwValidationError(message) {\n    throw new HttpError(422, 'Validation failed', { message });\n}\nfunction validate(args, validators) {\n    for (const { validates, message, validator } of validators) {\n        if (!validator(args[validates])) {\n            throwValidationError(message);\n        }\n    }\n}\n// NOTE(miho): it would be good to replace our custom validations with e.g. Zod\nconst validEmailRegex = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/;\nfunction isValidEmail(input) {\n    if (typeof input !== 'string') {\n        return false;\n    }\n    return input.match(validEmailRegex) !== null;\n}\nfunction isMinLength(input, minLength) {\n    if (typeof input !== 'string') {\n        return false;\n    }\n    return input.length >= minLength;\n}\nfunction containsNumber(input) {\n    if (typeof input !== 'string') {\n        return false;\n    }\n    return /\\d/.test(input);\n}\n//# sourceMappingURL=validation.js.map","import { hashPassword } from './password.js';\nimport { prisma, HttpError } from 'wasp/server';\nimport { sleep } from 'wasp/server/utils';\nimport { Prisma } from '@prisma/client';\nimport { throwValidationError } from './validation.js';\n// PRIVATE API\nexport const contextWithUserEntity = {\n    entities: {\n        User: prisma.user\n    }\n};\n// PRIVATE API\nexport const authConfig = {\n    failureRedirectPath: \"/login\",\n    successRedirectPath: \"/dashboard\",\n};\n// PUBLIC API\nexport function createProviderId(providerName, providerUserId) {\n    return {\n        providerName,\n        providerUserId: normalizeProviderUserId(providerName, providerUserId),\n    };\n}\n// PRIVATE API\nexport function normalizeProviderUserId(providerName, providerUserId) {\n    switch (providerName) {\n        case 'email':\n        case 'username':\n            return providerUserId.toLowerCase();\n        case 'google':\n        case 'github':\n        case 'discord':\n        case 'keycloak':\n        case 'slack':\n            return providerUserId;\n        /*\n          Why the default case?\n          In case users add a new auth provider in the user-land.\n          Users can't extend this function because it is private.\n          If there is an unknown `providerName` in runtime, we'll\n          return the `providerUserId` as is.\n    \n          We want to still have explicit OAuth providers listed\n          so that we get a type error if we forget to add a new provider\n          to the switch statement.\n        */\n        default:\n            providerName;\n            return providerUserId;\n    }\n}\n// PUBLIC API\nexport async function findAuthIdentity(providerId) {\n    return prisma.authIdentity.findUnique({\n        where: {\n            providerName_providerUserId: providerId,\n        }\n    });\n}\n// PUBLIC API\n/**\n * Updates the provider data for the given auth identity.\n *\n * This function performs data sanitization and serialization.\n * Sanitization is done by hashing the password, so this function\n * expects the password received in the `providerDataUpdates`\n * **not to be hashed**.\n */\nexport async function updateAuthIdentityProviderData(providerId, existingProviderData, providerDataUpdates) {\n    // We are doing the sanitization here only on updates to avoid\n    // hashing the password multiple times.\n    const sanitizedProviderDataUpdates = await ensurePasswordIsHashed(providerDataUpdates);\n    const newProviderData = {\n        ...existingProviderData,\n        ...sanitizedProviderDataUpdates,\n    };\n    const serializedProviderData = await serializeProviderData(newProviderData);\n    return prisma.authIdentity.update({\n        where: {\n            providerName_providerUserId: providerId,\n        },\n        data: { providerData: serializedProviderData },\n    });\n}\n// PRIVATE API\nexport async function findAuthWithUserBy(where) {\n    const result = await prisma.auth.findFirst({ where, include: { user: true } });\n    if (result === null) {\n        return null;\n    }\n    if (result.user === null) {\n        return null;\n    }\n    return { ...result, user: result.user };\n}\n// PUBLIC API\nexport async function createUser(providerId, serializedProviderData, userFields) {\n    return prisma.user.create({\n        data: {\n            // Using any here to prevent type errors when userFields are not\n            // defined. We want Prisma to throw an error in that case.\n            ...(userFields ?? {}),\n            auth: {\n                create: {\n                    identities: {\n                        create: {\n                            providerName: providerId.providerName,\n                            providerUserId: providerId.providerUserId,\n                            providerData: serializedProviderData,\n                        },\n                    },\n                }\n            },\n        },\n        // We need to include the Auth entity here because we need `authId`\n        // to be able to create a session.\n        include: {\n            auth: true,\n        },\n    });\n}\n// PRIVATE API\nexport async function deleteUserByAuthId(authId) {\n    return prisma.user.deleteMany({ where: { auth: {\n                id: authId,\n            } } });\n}\n// PRIVATE API\n// If an user exists, we don't want to leak information\n// about it. Pretending that we're doing some work\n// will make it harder for an attacker to determine\n// if a user exists or not.\n// NOTE: Attacker measuring time to response can still determine\n// if a user exists or not. We'll be able to avoid it when \n// we implement e-mail sending via jobs.\nexport async function doFakeWork() {\n    const timeToWork = Math.floor(Math.random() * 1000) + 1000;\n    return sleep(timeToWork);\n}\n// PRIVATE API\nexport function rethrowPossibleAuthError(e) {\n    // Prisma code P2002 is for unique constraint violations.\n    if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2002') {\n        throw new HttpError(422, 'Save failed', {\n            message: `user with the same identity already exists`,\n        });\n    }\n    if (e instanceof Prisma.PrismaClientValidationError) {\n        // NOTE: Logging the error since this usually means that there are\n        // required fields missing in the request, we want the developer\n        // to know about it.\n        console.error(e);\n        throw new HttpError(422, 'Save failed', {\n            message: 'there was a database error'\n        });\n    }\n    // Prisma code P2021 is for missing table errors.\n    if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2021') {\n        // NOTE: Logging the error since this usually means that the database\n        // migrations weren't run, we want the developer to know about it.\n        console.error(e);\n        console.info('ðŸ This error can happen if you did\\'t run the database migrations.');\n        throw new HttpError(500, 'Save failed', {\n            message: `there was a database error`,\n        });\n    }\n    // Prisma code P2003 is for foreign key constraint failure\n    if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2003') {\n        console.error(e);\n        console.info(`ðŸ This error can happen if you have some relation on your User entity\n   but you didn't specify the \"onDelete\" behaviour to either \"Cascade\" or \"SetNull\".\n   Read more at: https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/referential-actions`);\n        throw new HttpError(500, 'Save failed', {\n            message: `there was a database error`,\n        });\n    }\n    throw e;\n}\n// PRIVATE API\nexport async function validateAndGetUserFields(data, userSignupFields) {\n    const { password: _password, ...sanitizedData } = data;\n    const result = {};\n    if (!userSignupFields) {\n        return result;\n    }\n    for (const [field, getFieldValue] of Object.entries(userSignupFields)) {\n        try {\n            const value = await getFieldValue(sanitizedData);\n            result[field] = value;\n        }\n        catch (e) {\n            throwValidationError(e.message);\n        }\n    }\n    return result;\n}\n// PUBLIC API\nexport function getProviderData(providerData) {\n    return sanitizeProviderData(getProviderDataWithPassword(providerData));\n}\n// PUBLIC API\nexport function getProviderDataWithPassword(providerData) {\n    // NOTE: We are letting JSON.parse throw an error if the providerData is not valid JSON.\n    return JSON.parse(providerData);\n}\nfunction sanitizeProviderData(providerData) {\n    if (providerDataHasPasswordField(providerData)) {\n        const { hashedPassword, ...rest } = providerData;\n        return rest;\n    }\n    else {\n        return providerData;\n    }\n}\n// PUBLIC API\nexport async function sanitizeAndSerializeProviderData(providerData) {\n    return serializeProviderData(await ensurePasswordIsHashed(providerData));\n}\nfunction serializeProviderData(providerData) {\n    return JSON.stringify(providerData);\n}\nasync function ensurePasswordIsHashed(providerData) {\n    const data = {\n        ...providerData,\n    };\n    if (providerDataHasPasswordField(data)) {\n        data.hashedPassword = await hashPassword(data.hashedPassword);\n    }\n    return data;\n}\nfunction providerDataHasPasswordField(providerData) {\n    return 'hashedPassword' in providerData;\n}\n// PRIVATE API\nexport function createInvalidCredentialsError(message) {\n    return new HttpError(401, 'Invalid credentials', { message });\n}\n//# sourceMappingURL=utils.js.map","import { getProviderData, } from '../../auth/utils.js';\n// PRIVATE API\nexport function createAuthUserData(user) {\n    const { auth, ...rest } = user;\n    if (!auth) {\n        throw new Error(`ðŸ Error: trying to create a user without auth data.\nThis should never happen, but it did which means there is a bug in the code.`);\n    }\n    const identities = {\n        email: getProviderInfo(auth, 'email'),\n    };\n    return {\n        ...rest,\n        identities,\n    };\n}\nfunction getProviderInfo(auth, providerName) {\n    const identity = getIdentity(auth, providerName);\n    if (!identity) {\n        return null;\n    }\n    return {\n        ...getProviderData(identity.providerData),\n        id: identity.providerUserId,\n    };\n}\nfunction getIdentity(auth, providerName) {\n    return auth.identities.find((i) => i.providerName === providerName) ?? null;\n}\n//# sourceMappingURL=user.js.map","import { auth } from \"./lucia.js\";\nimport { createInvalidCredentialsError } from \"./utils.js\";\nimport { prisma } from 'wasp/server';\nimport { createAuthUserData } from \"../server/auth/user.js\";\n// PRIVATE API\n// Creates a new session for the `authId` in the database\nexport async function createSession(authId) {\n    return auth.createSession(authId, {});\n}\n// PRIVATE API\nexport async function getSessionAndUserFromBearerToken(req) {\n    const authorizationHeader = req.headers[\"authorization\"];\n    if (typeof authorizationHeader !== \"string\") {\n        return null;\n    }\n    const sessionId = auth.readBearerToken(authorizationHeader);\n    if (!sessionId) {\n        return null;\n    }\n    return getSessionAndUserFromSessionId(sessionId);\n}\n// PRIVATE API\nexport async function getSessionAndUserFromSessionId(sessionId) {\n    const { session, user: authEntity } = await auth.validateSession(sessionId);\n    if (!session || !authEntity) {\n        return null;\n    }\n    return {\n        session,\n        user: await getAuthUserData(authEntity.userId)\n    };\n}\nasync function getAuthUserData(userId) {\n    const user = await prisma.user\n        .findUnique({\n        where: { id: userId },\n        include: {\n            auth: {\n                include: {\n                    identities: true\n                }\n            }\n        }\n    });\n    if (!user) {\n        throw createInvalidCredentialsError();\n    }\n    return createAuthUserData(user);\n}\n// PRIVATE API\nexport function invalidateSession(sessionId) {\n    return auth.invalidateSession(sessionId);\n}\n//# sourceMappingURL=session.js.map","import { getSessionAndUserFromBearerToken } from 'wasp/auth/session';\nimport { createInvalidCredentialsError } from 'wasp/auth/utils';\nimport { defineHandler } from 'wasp/server/utils';\n/**\n * Auth middleware\n *\n * If the request includes an `Authorization` header it will try to authenticate the request,\n * otherwise it will let the request through.\n *\n * - If authentication succeeds it sets `req.sessionId` and `req.user`\n *   - `req.user` is the user that made the request and it's used in\n *      all Wasp features that need to know the user that made the request.\n *   - `req.sessionId` is the ID of the session that authenticated the request.\n * - If the request is not authenticated, it throws an error.\n */\nconst auth = defineHandler(async (req, res, next) => {\n    const authHeader = req.get('Authorization');\n    // NOTE(matija): for now we let tokenless requests through and make it operation's\n    // responsibility to verify whether the request is authenticated or not. In the future\n    // we will develop our own system at Wasp-level for that.\n    if (!authHeader) {\n        req.sessionId = null;\n        req.user = null;\n        return next();\n    }\n    const sessionAndUser = await getSessionAndUserFromBearerToken(req);\n    if (sessionAndUser === null) {\n        throw createInvalidCredentialsError();\n    }\n    req.sessionId = sessionAndUser.session.id;\n    req.user = sessionAndUser.user;\n    next();\n});\nexport default auth;\n//# sourceMappingURL=auth.js.map","import { Prisma } from \"@prisma/client\";\nimport { registerCustom } from \"superjson\";\nimport \"./custom-register\";\nconst Decimal = Prisma.Decimal;\n/*\n  And finally, if we have the `Decimal` type because the Prisma schema is using it,\n  we register it as a custom type with SuperJSON.\n  Based on https://github.com/flightcontrolhq/superjson/blob/v2.2.2/README.md#decimaljs--prismadecimal\n*/\nif (Decimal) {\n    registerCustom({\n        isApplicable: (v) => Decimal.isDecimal(v),\n        serialize: (v) => v.toJSON(),\n        deserialize: (v) => new Decimal(v),\n    }, \"prisma.decimal\");\n}\n//# sourceMappingURL=prisma.js.map","export function isNotNull(value) {\n    return value !== null;\n}\n//# sourceMappingURL=predicates.js.map","import { isNotNull } from '../universal/predicates.js';\n/**\n * We split the user.ts code into two files to avoid some server-only\n * code (Oslo's hashing functions) being imported on the client.\n */\n// PUBLIC API\nexport function getEmail(user) {\n    return findUserIdentity(user, \"email\")?.providerUserId ?? null;\n}\n// PUBLIC API\nexport function getUsername(user) {\n    return findUserIdentity(user, \"username\")?.providerUserId ?? null;\n}\n// PUBLIC API\nexport function getFirstProviderUserId(user) {\n    if (!user || !user.auth || !user.auth.identities || user.auth.identities.length === 0) {\n        return null;\n    }\n    return user.auth.identities[0].providerUserId ?? null;\n}\nexport function makeAuthUserIfPossible(user) {\n    return user ? makeAuthUser(user) : null;\n}\nfunction makeAuthUser(data) {\n    return {\n        ...data,\n        getFirstProviderUserId: () => {\n            const identities = Object.values(data.identities).filter(isNotNull);\n            return identities.length > 0 ? identities[0].id : null;\n        },\n    };\n}\nfunction findUserIdentity(user, providerName) {\n    if (!user.auth) {\n        return null;\n    }\n    return user.auth.identities.find((identity) => identity.providerName === providerName) ?? null;\n}\n//# sourceMappingURL=user.js.map","import { deserialize, serialize } from 'wasp/core/serialization'\nimport { defineHandler } from 'wasp/server/utils'\nimport { makeAuthUserIfPossible } from 'wasp/auth/user'\n\nexport function createOperation (handlerFn) {\n    return defineHandler(async (req, res) => {\n        const args = (req.body && deserialize(req.body)) || {}\n        const context = {\n            user: makeAuthUserIfPossible(req.user),\n        }\n        const result = await handlerFn(args, context)\n        const serializedResult = serialize(result)\n        res.json(serializedResult)\n    })\n}\n\nexport function createQuery(handlerFn) {\n    return createOperation(handlerFn)\n}\n\nexport function createAction(handlerFn) {\n    return createOperation(handlerFn)\n}\n","export function requireNodeEnvVar(name: string): string {\n  const value = process.env[name];\n  if (value === undefined) {\n    throw new Error(`Env var ${name} is undefined`);\n  } else {\n    return value;\n  }\n}\n","import { requireNodeEnvVar } from \"../server/utils\";\n\nexport enum SubscriptionStatus {\n  PastDue = \"past_due\",\n  CancelAtPeriodEnd = \"cancel_at_period_end\",\n  Active = \"active\",\n  Deleted = \"deleted\",\n}\n\nexport enum PaymentPlanId {\n  Starter = \"starter\",\n  Pro = \"pro\",\n  Business = \"business\",\n  StarterAnnual = \"starter-annual\",\n  ProAnnual = \"pro-annual\",\n  BusinessAnnual = \"business-annual\",\n}\n\nexport interface PaymentPlan {\n  /**\n   * Returns the id under which this payment plan is identified on your payment processor.\n   *\n   * E.g. price id on Stripe, or variant id on LemonSqueezy.\n   */\n  getPaymentProcessorPlanId: () => string;\n  effect: PaymentPlanEffect;\n}\n\nexport type PaymentPlanEffect =\n  | { kind: \"subscription\" }\n  | { kind: \"credits\"; amount: number };\n\nexport const paymentPlans = {\n  [PaymentPlanId.Starter]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_STARTER_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n  [PaymentPlanId.Pro]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_PRO_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n  [PaymentPlanId.Business]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_BUSINESS_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n  [PaymentPlanId.StarterAnnual]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_STARTER_ANNUAL_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n  [PaymentPlanId.ProAnnual]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_PRO_ANNUAL_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n  [PaymentPlanId.BusinessAnnual]: {\n    getPaymentProcessorPlanId: () =>\n      requireNodeEnvVar(\"PAYMENTS_BUSINESS_ANNUAL_SUBSCRIPTION_PLAN_ID\"),\n    effect: { kind: \"subscription\" },\n  },\n} as const satisfies Record<PaymentPlanId, PaymentPlan>;\n\nexport function prettyPaymentPlanName(planId: PaymentPlanId): string {\n  const planToName: Record<PaymentPlanId, string> = {\n    [PaymentPlanId.Starter]: \"Starter\",\n    [PaymentPlanId.Pro]: \"Pro\",\n    [PaymentPlanId.Business]: \"Business\",\n    [PaymentPlanId.StarterAnnual]: \"Starter (Annual)\",\n    [PaymentPlanId.ProAnnual]: \"Pro (Annual)\",\n    [PaymentPlanId.BusinessAnnual]: \"Business (Annual)\",\n  };\n  return planToName[planId];\n}\n\nexport function parsePaymentPlanId(planId: string): PaymentPlanId {\n  if ((Object.values(PaymentPlanId) as string[]).includes(planId)) {\n    return planId as PaymentPlanId;\n  } else {\n    throw new Error(`Invalid PaymentPlanId: ${planId}`);\n  }\n}\n\nexport function getSubscriptionPaymentPlanIds(): PaymentPlanId[] {\n  return Object.values(PaymentPlanId).filter(\n    (planId) => paymentPlans[planId].effect.kind === \"subscription\",\n  );\n}\n\n/**\n * Returns Open SaaS `PaymentPlanId` for some payment provider's plan ID.\n * \n * Different payment providers track plan ID in different ways.\n * e.g. Stripe price ID, Polar product ID...\n */\nexport function getPaymentPlanIdByPaymentProcessorPlanId(\n  paymentProcessorPlanId: string,\n): PaymentPlanId {\n  for (const [planId, plan] of Object.entries(paymentPlans)) {\n    if (plan.getPaymentProcessorPlanId() === paymentProcessorPlanId) {\n      return planId as PaymentPlanId;\n    }\n  }\n\n  throw new Error(\n    `Unknown payment processor plan ID: ${paymentProcessorPlanId}`,\n  );\n}\n","import { HttpError } from \"wasp/server\";\nimport * as z from \"zod\";\n\nexport function ensureArgsSchemaOrThrowHttpError<Schema extends z.ZodType>(\n  schema: Schema,\n  rawArgs: unknown,\n): z.infer<Schema> {\n  const parseResult = schema.safeParse(rawArgs);\n  if (!parseResult.success) {\n    console.error(parseResult.error);\n    throw new HttpError(400, \"Operation arguments validation failed\", {\n      errors: parseResult.error.errors,\n    });\n  } else {\n    return parseResult.data;\n  }\n}\n","import { type Prisma } from \"@prisma/client\";\nimport { type User } from \"wasp/entities\";\nimport { HttpError, prisma } from \"wasp/server\";\nimport {\n  type GetPaginatedUsers,\n  type UpdateIsUserAdminById,\n} from \"wasp/server/operations\";\nimport * as z from \"zod\";\nimport { SubscriptionStatus } from \"../payment/plans\";\nimport { ensureArgsSchemaOrThrowHttpError } from \"../server/validation\";\n\nconst updateUserAdminByIdInputSchema = z.object({\n  id: z.string().nonempty(),\n  isAdmin: z.boolean(),\n});\n\ntype UpdateUserAdminByIdInput = z.infer<typeof updateUserAdminByIdInputSchema>;\n\nexport const updateIsUserAdminById: UpdateIsUserAdminById<\n  UpdateUserAdminByIdInput,\n  User\n> = async (rawArgs, context) => {\n  const { id, isAdmin } = ensureArgsSchemaOrThrowHttpError(\n    updateUserAdminByIdInputSchema,\n    rawArgs,\n  );\n\n  if (!context.user) {\n    throw new HttpError(\n      401,\n      \"Only authenticated users are allowed to perform this operation\",\n    );\n  }\n\n  if (!context.user.isAdmin) {\n    throw new HttpError(\n      403,\n      \"Only admins are allowed to perform this operation\",\n    );\n  }\n\n  return context.entities.User.update({\n    where: { id },\n    data: { isAdmin },\n  });\n};\n\ntype GetPaginatedUsersOutput = {\n  users: Pick<\n    User,\n    | \"id\"\n    | \"email\"\n    | \"username\"\n    | \"subscriptionStatus\"\n    | \"paymentProcessorUserId\"\n    | \"isAdmin\"\n  >[];\n  totalPages: number;\n};\n\nconst getPaginatorArgsSchema = z.object({\n  skipPages: z.number(),\n  filter: z.object({\n    emailContains: z.string().nonempty().optional(),\n    isAdmin: z.boolean().optional(),\n    subscriptionStatusIn: z\n      .array(z.nativeEnum(SubscriptionStatus).nullable())\n      .optional(),\n  }),\n});\n\ntype GetPaginatedUsersInput = z.infer<typeof getPaginatorArgsSchema>;\n\nexport const getPaginatedUsers: GetPaginatedUsers<\n  GetPaginatedUsersInput,\n  GetPaginatedUsersOutput\n> = async (rawArgs, context) => {\n  if (!context.user) {\n    throw new HttpError(\n      401,\n      \"Only authenticated users are allowed to perform this operation\",\n    );\n  }\n\n  if (!context.user.isAdmin) {\n    throw new HttpError(\n      403,\n      \"Only admins are allowed to perform this operation\",\n    );\n  }\n\n  const {\n    skipPages,\n    filter: {\n      subscriptionStatusIn: subscriptionStatus,\n      emailContains,\n      isAdmin,\n    },\n  } = ensureArgsSchemaOrThrowHttpError(getPaginatorArgsSchema, rawArgs);\n\n  const includeUnsubscribedUsers = !!subscriptionStatus?.some(\n    (status) => status === null,\n  );\n  const desiredSubscriptionStatuses = subscriptionStatus?.filter(\n    (status) => status !== null,\n  );\n\n  const pageSize = 10;\n\n  const userPageQuery: Prisma.UserFindManyArgs = {\n    skip: skipPages * pageSize,\n    take: pageSize,\n    where: {\n      AND: [\n        {\n          email: {\n            contains: emailContains,\n            mode: \"insensitive\",\n          },\n          isAdmin,\n        },\n        {\n          OR: [\n            {\n              subscriptionStatus: {\n                in: desiredSubscriptionStatuses,\n              },\n            },\n            {\n              subscriptionStatus: includeUnsubscribedUsers ? null : undefined,\n            },\n          ],\n        },\n      ],\n    },\n    select: {\n      id: true,\n      email: true,\n      username: true,\n      isAdmin: true,\n      subscriptionStatus: true,\n      paymentProcessorUserId: true,\n    },\n    orderBy: {\n      username: \"asc\",\n    },\n  };\n\n  const [pageOfUsers, totalUsers] = await prisma.$transaction([\n    context.entities.User.findMany(userPageQuery),\n    context.entities.User.count({ where: userPageQuery.where }),\n  ]);\n  const totalPages = Math.ceil(totalUsers / pageSize);\n\n  return {\n    users: pageOfUsers,\n    totalPages,\n  };\n};\n","import { prisma } from 'wasp/server'\n\nimport { updateIsUserAdminById } from '../../../../../src/user/operations'\n\n\nexport default async function (args, context) {\n  return (updateIsUserAdminById as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport updateIsUserAdminById from '../../actions/updateIsUserAdminById.js'\n\nexport default createAction(updateIsUserAdminById)\n","import type { UpdateUsername, RequestEmailChange, ConfirmEmailChange, UpdateNotificationPreferences } from 'wasp/server/operations';\nimport { HttpError } from 'wasp/server';\nimport crypto from 'crypto';\n\n// ============================================================================\n// UPDATE USERNAME\n// ============================================================================\n\ntype UpdateUsernameInput = {\n  username: string;\n};\n\nexport const updateUsername: UpdateUsername<UpdateUsernameInput, void> = async (\n  { username },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Validate username format\n  if (!/^[a-zA-Z0-9_-]{3,30}$/.test(username)) {\n    throw new HttpError(400, 'Username must be 3-30 characters and contain only letters, numbers, dashes, and underscores');\n  }\n\n  // Check if username is already taken\n  const existingUser = await context.entities.User.findUnique({\n    where: { username },\n  });\n\n  if (existingUser && existingUser.id !== context.user.id) {\n    throw new HttpError(400, 'Username is already taken');\n  }\n\n  // Update username\n  await context.entities.User.update({\n    where: { id: context.user.id },\n    data: { username },\n  });\n};\n\n// ============================================================================\n// REQUEST EMAIL CHANGE\n// ============================================================================\n\ntype RequestEmailChangeInput = {\n  newEmail: string;\n};\n\nexport const requestEmailChange: RequestEmailChange<RequestEmailChangeInput, void> = async (\n  { newEmail },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Validate email format\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  if (!emailRegex.test(newEmail)) {\n    throw new HttpError(400, 'Invalid email format');\n  }\n\n  // Check if email is already in use\n  const existingUser = await context.entities.User.findUnique({\n    where: { email: newEmail },\n  });\n\n  if (existingUser && existingUser.id !== context.user.id) {\n    throw new HttpError(400, 'Email is already in use');\n  }\n\n  // Generate verification token (32 bytes = 64 hex chars)\n  const token = crypto.randomBytes(32).toString('hex');\n  const expiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour from now\n\n  // Store pending email and token\n  await context.entities.User.update({\n    where: { id: context.user.id },\n    data: {\n      pendingEmail: newEmail,\n      emailChangeToken: token,\n      emailChangeTokenExpiry: expiry,\n    },\n  });\n\n  // Send verification email\n  const verificationLink = `${process.env.WASP_WEB_CLIENT_URL}/account/verify-email-change?token=${token}`;\n\n  try {\n    await context.entities.User.update({\n      where: { id: context.user.id },\n      data: {}, // Trigger to send email via emailSender\n    });\n\n    // TODO: Implement actual email sending\n    // For now, log the verification link for development\n    console.log('ðŸ”— Email verification link:', verificationLink);\n    console.log('ðŸ“§ Send this to:', newEmail);\n\n    // In production, use Wasp's email sender:\n    // await emailSender.send({\n    //   to: newEmail,\n    //   subject: 'Verify your new email address',\n    //   text: `Click this link to verify your new email: ${verificationLink}`,\n    //   html: `<p>Click <a href=\"${verificationLink}\">here</a> to verify your new email address.</p>`,\n    // });\n\n  } catch (error) {\n    console.error('Failed to send verification email:', error);\n    throw new HttpError(500, 'Failed to send verification email');\n  }\n};\n\n// ============================================================================\n// CONFIRM EMAIL CHANGE\n// ============================================================================\n\ntype ConfirmEmailChangeInput = {\n  token: string;\n};\n\nexport const confirmEmailChange: ConfirmEmailChange<ConfirmEmailChangeInput, { success: boolean; email?: string }> = async (\n  { token },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Find user with this token\n  const user = await context.entities.User.findUnique({\n    where: { id: context.user.id },\n  });\n\n  if (!user || !user.emailChangeToken || !user.emailChangeTokenExpiry || !user.pendingEmail) {\n    throw new HttpError(400, 'Invalid or expired verification link');\n  }\n\n  // Verify token matches\n  if (user.emailChangeToken !== token) {\n    throw new HttpError(400, 'Invalid verification link');\n  }\n\n  // Check if token is expired\n  if (new Date() > user.emailChangeTokenExpiry) {\n    throw new HttpError(400, 'Verification link has expired. Please request a new email change.');\n  }\n\n  // Check if the pending email is still available\n  const existingUser = await context.entities.User.findUnique({\n    where: { email: user.pendingEmail },\n  });\n\n  if (existingUser && existingUser.id !== user.id) {\n    throw new HttpError(400, 'This email address is no longer available');\n  }\n\n  // Update email and clear pending fields\n  await context.entities.User.update({\n    where: { id: user.id },\n    data: {\n      email: user.pendingEmail,\n      pendingEmail: null,\n      emailChangeToken: null,\n      emailChangeTokenExpiry: null,\n    },\n  });\n\n  return {\n    success: true,\n    email: user.pendingEmail,\n  };\n};\n\n// ============================================================================\n// UPDATE NOTIFICATION PREFERENCES\n// ============================================================================\n\ntype UpdateNotificationPreferencesInput = {\n  emailNotifications: boolean;\n  syncFailureAlerts: boolean;\n  weeklyDigest: boolean;\n};\n\nexport const updateNotificationPreferences: UpdateNotificationPreferences<UpdateNotificationPreferencesInput, void> = async (\n  { emailNotifications, syncFailureAlerts, weeklyDigest },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  await context.entities.User.update({\n    where: { id: context.user.id },\n    data: {\n      emailNotifications,\n      syncFailureAlerts,\n      weeklyDigest,\n    },\n  });\n};\n","import { prisma } from 'wasp/server'\n\nimport { updateUsername } from '../../../../../src/user/accountSettings'\n\n\nexport default async function (args, context) {\n  return (updateUsername as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport updateUsername from '../../actions/updateUsername.js'\n\nexport default createAction(updateUsername)\n","import { prisma } from 'wasp/server'\n\nimport { requestEmailChange } from '../../../../../src/user/accountSettings'\n\n\nexport default async function (args, context) {\n  return (requestEmailChange as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport requestEmailChange from '../../actions/requestEmailChange.js'\n\nexport default createAction(requestEmailChange)\n","import { prisma } from 'wasp/server'\n\nimport { confirmEmailChange } from '../../../../../src/user/accountSettings'\n\n\nexport default async function (args, context) {\n  return (confirmEmailChange as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport confirmEmailChange from '../../actions/confirmEmailChange.js'\n\nexport default createAction(confirmEmailChange)\n","import { prisma } from 'wasp/server'\n\nimport { updateNotificationPreferences } from '../../../../../src/user/accountSettings'\n\n\nexport default async function (args, context) {\n  return (updateNotificationPreferences as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport updateNotificationPreferences from '../../actions/updateNotificationPreferences.js'\n\nexport default createAction(updateNotificationPreferences)\n","import type { ChangePassword } from 'wasp/server/operations';\nimport { HttpError, prisma } from 'wasp/server';\nimport { hashPassword, verifyPassword } from 'wasp/auth/password';\n\n// ============================================================================\n// CHANGE PASSWORD\n// ============================================================================\n\ntype ChangePasswordInput = {\n  currentPassword: string;\n  newPassword: string;\n};\n\nexport const changePassword: ChangePassword<ChangePasswordInput, void> = async (\n  { currentPassword, newPassword },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Validate new password strength\n  if (newPassword.length < 8) {\n    throw new HttpError(400, 'Password must be at least 8 characters long');\n  }\n  if (!/[A-Z]/.test(newPassword)) {\n    throw new HttpError(400, 'Password must contain at least one uppercase letter');\n  }\n  if (!/[a-z]/.test(newPassword)) {\n    throw new HttpError(400, 'Password must contain at least one lowercase letter');\n  }\n  if (!/[0-9]/.test(newPassword)) {\n    throw new HttpError(400, 'Password must contain at least one number');\n  }\n\n  // Get user with auth identities\n  const user = await context.entities.User.findUnique({\n    where: { id: context.user.id },\n    include: {\n      auth: {\n        include: {\n          identities: true,\n        },\n      },\n    },\n  });\n\n  if (!user || !user.auth) {\n    throw new HttpError(404, 'User not found');\n  }\n\n  // Find email identity\n  const emailIdentity = user.auth.identities.find(\n    (identity: any) => identity.providerName === 'email'\n  );\n\n  if (!emailIdentity) {\n    throw new HttpError(400, 'Email authentication not set up for this account');\n  }\n\n  // Validate that we have a stored password hash\n  if (!emailIdentity.providerUserId || emailIdentity.providerUserId.trim() === '') {\n    console.error('âŒ Missing password hash for user:', user.id);\n    throw new HttpError(500, 'Password data is missing. Please try resetting your password instead.');\n  }\n\n  console.log('ðŸ” Password change attempt for user:', user.id);\n\n  // Import Wasp's password utilities and Prisma client\n  let hashedNewPassword: string;\n\n  try {\n    // verifyPassword expects (hashedPassword, plainPassword)\n    // emailIdentity.providerUserId contains the hashed password\n    await verifyPassword(\n      emailIdentity.providerUserId,\n      currentPassword\n    );\n\n    // Hash new password\n    hashedNewPassword = await hashPassword(newPassword);\n  } catch (error: any) {\n    console.error('Password operation failed:', error);\n    // Check for specific error messages\n    if (error.message?.includes('Invalid password') || error.message?.includes('does not match')) {\n      throw new HttpError(400, 'Current password is incorrect');\n    }\n    if (error.code === 'InvalidArg' || error.message?.includes('missing field')) {\n      throw new HttpError(500, 'Password verification error. Please contact support.');\n    }\n    throw new HttpError(500, 'Password management failed');\n  }\n\n  // Update password in AuthIdentity using the composite key\n  // AuthIdentity uses @@id([providerName, providerUserId]) so we need direct Prisma access\n  await prisma.authIdentity.updateMany({\n    where: {\n      providerName: 'email',\n      authId: user.auth.id,\n    },\n    data: {\n      providerUserId: hashedNewPassword,\n    },\n  });\n\n  // TODO: Send email notification about password change\n  // This would require implementing an email service\n  // For now, log the change\n  console.log(`âœ… Password changed for user ${user.id} (${user.email})`);\n\n  // Note: Wasp doesn't currently support session invalidation\n  // In a production app, you might want to:\n  // 1. Invalidate all other sessions (force re-login on other devices)\n  // 2. Send email notification about password change\n};\n","import { prisma } from 'wasp/server'\n\nimport { changePassword } from '../../../../../src/user/security'\n\n\nexport default async function (args, context) {\n  return (changePassword as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport changePassword from '../../actions/changePassword.js'\n\nexport default createAction(changePassword)\n","import Stripe from \"stripe\";\nimport { requireNodeEnvVar } from \"../../server/utils\";\n\n/**\n * The Stripe client API version.\n *\n * By default, Stripe uses the API version set in your Dashboard.\n *\n * You can override this by setting `apiVersion` when creating the Stripe client.\n * This is useful for testing new API versions before updating the\n * default version in your Dashboard.\n *\n * The Stripe Node SDK works with multiple API versions and follows semantic versioning.\n * Major SDK versions typically correspond to Stripe's biannual releases (like 'basil').\n * Each SDK version uses the API version that was current when it was released.\n *\n * Note: '2025-04-30.basil' follows Stripe's newer versioning format where:\n * - The date represents the release date\n * - The suffix ('basil') indicates the major release name\n *\n * Monthly API updates use the same suffix as the last major release but with updated dates.\n *\n * @see https://docs.stripe.com/api/versioning\n * @see https://docs.stripe.com/sdks/versioning\n */\nconst STRIPE_API_VERSION = \"2025-04-30.basil\";\n\nexport const stripeClient = new Stripe(requireNodeEnvVar(\"STRIPE_API_KEY\"), {\n  apiVersion: STRIPE_API_VERSION,\n});\n","import type { ExportUserData, DeleteAccount } from 'wasp/server/operations';\nimport { HttpError } from 'wasp/server';\nimport { verifyPassword } from 'wasp/auth/password';\nimport { stripeClient } from '../payment/stripe/stripeClient';\n\n// ============================================================================\n// EXPORT USER DATA (GDPR Compliance)\n// ============================================================================\n\nexport const exportUserData: ExportUserData<void, any> = async (args, context) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Fetch all user data\n  const user = await context.entities.User.findUnique({\n    where: { id: context.user.id },\n    include: {\n      airtableConnections: {\n        select: {\n          id: true,\n          createdAt: true,\n          accountId: true,\n          needsReauth: true,\n          // Exclude encrypted tokens\n        },\n      },\n      googleSheetsConnections: {\n        select: {\n          id: true,\n          createdAt: true,\n          googleAccountEmail: true,\n          needsReauth: true,\n          // Exclude encrypted tokens\n        },\n      },\n      syncConfigs: {\n        select: {\n          id: true,\n          name: true,\n          airtableBaseId: true,\n          airtableTableName: true,\n          googleSpreadsheetId: true,\n          googleSheetName: true,\n          syncDirection: true,\n          conflictResolution: true,\n          isActive: true,\n          lastSyncAt: true,\n          lastSyncStatus: true,\n          createdAt: true,\n          updatedAt: true,\n          syncLogs: {\n            take: 100, // Last 100 sync logs\n            orderBy: {\n              createdAt: 'desc',\n            },\n            select: {\n              id: true,\n              status: true,\n              recordsSynced: true,\n              recordsFailed: true,\n              startedAt: true,\n              completedAt: true,\n              triggeredBy: true,\n            },\n          },\n        },\n      },\n      usageStats: true,\n    },\n  });\n\n  if (!user) {\n    throw new HttpError(404, 'User not found');\n  }\n\n  // Flatten sync logs from all sync configs\n  const allSyncLogs = user.syncConfigs.flatMap(config =>\n    config.syncLogs.map(log => ({\n      ...log,\n      syncConfigName: config.name,\n      syncConfigId: config.id,\n    }))\n  );\n\n  // Format data for export\n  const exportData = {\n    exportedAt: new Date().toISOString(),\n    profile: {\n      id: user.id,\n      email: user.email,\n      username: user.username,\n      createdAt: user.createdAt,\n      isAdmin: user.isAdmin,\n    },\n    subscription: {\n      plan: user.subscriptionPlan,\n      status: user.subscriptionStatus,\n      credits: user.credits,\n      datePaid: user.datePaid,\n      trialStartedAt: user.trialStartedAt,\n      trialEndsAt: user.trialEndsAt,\n    },\n    notifications: {\n      emailNotifications: user.emailNotifications,\n      syncFailureAlerts: user.syncFailureAlerts,\n      weeklyDigest: user.weeklyDigest,\n    },\n    connections: {\n      airtable: user.airtableConnections.map(conn => ({\n        id: conn.id,\n        connectedAt: conn.createdAt,\n        accountId: conn.accountId,\n        needsReauth: conn.needsReauth,\n      })),\n      googleSheets: user.googleSheetsConnections.map(conn => ({\n        id: conn.id,\n        connectedAt: conn.createdAt,\n        googleAccountEmail: conn.googleAccountEmail,\n        needsReauth: conn.needsReauth,\n      })),\n    },\n    syncConfigurations: user.syncConfigs.map(({ syncLogs, ...config }) => config),\n    syncHistory: allSyncLogs,\n    usageStatistics: user.usageStats,\n  };\n\n  return exportData;\n};\n\n// ============================================================================\n// DELETE ACCOUNT\n// ============================================================================\n\ntype DeleteAccountInput = {\n  confirmationText: string;\n  password: string;\n};\n\nexport const deleteAccount: DeleteAccount<DeleteAccountInput, void> = async (\n  { confirmationText, password },\n  context\n) => {\n  if (!context.user) {\n    throw new HttpError(401, 'Unauthorized');\n  }\n\n  // Verify confirmation text\n  if (confirmationText !== 'DELETE MY ACCOUNT') {\n    throw new HttpError(400, 'Confirmation text does not match. Please type exactly: DELETE MY ACCOUNT');\n  }\n\n  // Get user with auth identities\n  const user = await context.entities.User.findUnique({\n    where: { id: context.user.id },\n    include: {\n      auth: {\n        include: {\n          identities: true,\n        },\n      },\n    },\n  });\n\n  if (!user || !user.auth) {\n    throw new HttpError(404, 'User not found');\n  }\n\n  // Find email identity\n  const emailIdentity = user.auth.identities.find(\n    (identity: any) => identity.providerName === 'email'\n  );\n\n  if (!emailIdentity) {\n    throw new HttpError(400, 'Email authentication not set up for this account');\n  }\n\n  // Verify password\n  try {\n    // verifyPassword throws if password is invalid, so if it doesn't throw, password is valid\n    await verifyPassword(\n      emailIdentity.providerUserId,\n      password\n    );\n  } catch (error) {\n    console.error('Password verification failed:', error);\n    throw new HttpError(400, 'Incorrect password');\n  }\n\n  // Cancel Stripe subscription if active\n  if (user.subscriptionStatus === 'active' && user.paymentProcessorUserId) {\n    try {\n      // Get customer's subscriptions\n      const subscriptions = await stripeClient.subscriptions.list({\n        customer: user.paymentProcessorUserId,\n        status: 'active',\n      });\n\n      // Cancel all active subscriptions\n      for (const subscription of subscriptions.data) {\n        await stripeClient.subscriptions.cancel(subscription.id);\n        console.log(`âœ… Cancelled subscription ${subscription.id} for user ${user.id}`);\n      }\n    } catch (error) {\n      console.error('Failed to cancel Stripe subscription:', error);\n      // Don't block account deletion if Stripe cancellation fails\n      // The subscription will remain but user data will be deleted\n    }\n  }\n\n  // TODO: Send goodbye email\n  console.log(`ðŸ‘‹ Account deletion requested for ${user.email}`);\n\n  // Delete user (Prisma will cascade delete all related records)\n  await context.entities.User.delete({\n    where: { id: user.id },\n  });\n\n  console.log(`ðŸ—‘ï¸ User ${user.id} deleted successfully`);\n\n  // Note: After this, the user's session will be invalid\n  // The frontend should handle logout and redirect\n};\n","import { prisma } from 'wasp/server'\n\nimport { deleteAccount } from '../../../../../src/user/dangerZone'\n\n\nexport default async function (args, context) {\n  return (deleteAccount as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport deleteAccount from '../../actions/deleteAccount.js'\n\nexport default createAction(deleteAccount)\n","/**\n * Used purely to help compiler check for exhaustiveness in switch statements,\n * will never execute. See https://stackoverflow.com/a/39419171.\n */\nexport function assertUnreachable(_: never): never {\n  throw Error(\"This code should be unreachable\");\n}\n\n/**\n * Allows for throttling a function call while still allowing the last invocation to be executed after the throttle delay ends.\n */\nexport function throttleWithTrailingInvocation(\n  fn: () => void,\n  delayInMilliseconds: number,\n): ((...args: any[]) => void) & { cancel: () => void } {\n  let fnLastCallTime: number | null = null;\n  let trailingInvocationTimeoutId: ReturnType<typeof setTimeout> | null = null;\n  let isTrailingInvocationPending = false;\n\n  const callFn = () => {\n    fnLastCallTime = Date.now();\n    fn();\n  };\n\n  const throttledFn = () => {\n    const currentTime = Date.now();\n    const timeSinceLastExecution = fnLastCallTime\n      ? currentTime - fnLastCallTime\n      : 0;\n\n    const shouldCallImmediately =\n      fnLastCallTime === null || timeSinceLastExecution >= delayInMilliseconds;\n\n    if (shouldCallImmediately) {\n      callFn();\n      return;\n    }\n\n    if (!isTrailingInvocationPending) {\n      isTrailingInvocationPending = true;\n      const remainingDelayTime = Math.max(\n        delayInMilliseconds - timeSinceLastExecution,\n        0,\n      );\n\n      trailingInvocationTimeoutId = setTimeout(() => {\n        callFn();\n        isTrailingInvocationPending = false;\n      }, remainingDelayTime);\n    }\n  };\n\n  throttledFn.cancel = () => {\n    if (trailingInvocationTimeoutId) {\n      clearTimeout(trailingInvocationTimeoutId);\n      trailingInvocationTimeoutId = null;\n    }\n    isTrailingInvocationPending = false;\n  };\n\n  return throttledFn as typeof throttledFn & { cancel: () => void };\n}\n","import { User } from \"wasp/entities\";\nimport { PrismaClient } from \"wasp/server\";\nimport { PaymentPlanId, SubscriptionStatus } from \"./plans\";\n\nexport async function fetchUserPaymentProcessorUserId(\n  userId: User[\"id\"],\n  prismaUserDelegate: PrismaClient[\"user\"],\n): Promise<string | null> {\n  const user = await prismaUserDelegate.findUniqueOrThrow({\n    where: {\n      id: userId,\n    },\n    select: {\n      paymentProcessorUserId: true,\n    },\n  });\n\n  return user.paymentProcessorUserId;\n}\n\ninterface UpdateUserPaymentProcessorUserIdArgs {\n  userId: User[\"id\"];\n  paymentProcessorUserId: NonNullable<User[\"paymentProcessorUserId\"]>;\n}\n\nexport function updateUserPaymentProcessorUserId(\n  { userId, paymentProcessorUserId }: UpdateUserPaymentProcessorUserIdArgs,\n  prismaUserDelegate: PrismaClient[\"user\"],\n): Promise<User> {\n  return prismaUserDelegate.update({\n    where: {\n      id: userId,\n    },\n    data: {\n      paymentProcessorUserId,\n    },\n  });\n}\n\ninterface UpdateUserSubscriptionArgs {\n  paymentProcessorUserId: NonNullable<User[\"paymentProcessorUserId\"]>;\n  subscriptionStatus: SubscriptionStatus;\n  paymentPlanId?: PaymentPlanId;\n  datePaid?: Date;\n}\n\nexport function updateUserSubscription(\n  {\n    paymentProcessorUserId,\n    paymentPlanId,\n    subscriptionStatus,\n    datePaid,\n  }: UpdateUserSubscriptionArgs,\n  userDelegate: PrismaClient[\"user\"],\n): Promise<User> {\n  return userDelegate.update({\n    where: {\n      paymentProcessorUserId,\n    },\n    data: {\n      subscriptionPlan: paymentPlanId,\n      subscriptionStatus,\n      datePaid,\n    },\n  });\n}\n\ninterface UpdateUserCreditsArgs {\n  paymentProcessorUserId: NonNullable<User[\"paymentProcessorUserId\"]>;\n  numOfCreditsPurchased: number;\n  datePaid: Date;\n}\n\nexport function updateUserCredits(\n  {\n    paymentProcessorUserId,\n    numOfCreditsPurchased,\n    datePaid,\n  }: UpdateUserCreditsArgs,\n  userDelegate: PrismaClient[\"user\"],\n): Promise<User> {\n  return userDelegate.update({\n    where: {\n      paymentProcessorUserId,\n    },\n    data: {\n      credits: { increment: numOfCreditsPurchased },\n      datePaid,\n    },\n  });\n}\n","import Stripe from \"stripe\";\nimport { User } from \"wasp/entities\";\nimport { config } from \"wasp/server\";\nimport { stripeClient } from \"./stripeClient\";\n\n/**\n * Returns a Stripe customer for the given User email, creating a customer if none exist.\n * Implements email uniqueness logic since Stripe doesn't enforce unique emails.\n */\nexport async function ensureStripeCustomer(\n  userEmail: NonNullable<User[\"email\"]>,\n): Promise<Stripe.Customer> {\n  const customers = await stripeClient.customers.list({\n    email: userEmail,\n  });\n\n  if (customers.data.length === 0) {\n    return stripeClient.customers.create({\n      email: userEmail,\n    });\n  } else {\n    return customers.data[0];\n  }\n}\n\ninterface CreateStripeCheckoutSessionParams {\n  priceId: Stripe.Price[\"id\"];\n  customerId: Stripe.Customer[\"id\"];\n  mode: Stripe.Checkout.Session.Mode;\n  returnUrl?: string;\n}\n\nexport function createStripeCheckoutSession({\n  priceId,\n  customerId,\n  mode,\n  returnUrl,\n}: CreateStripeCheckoutSessionParams): Promise<Stripe.Checkout.Session> {\n  // Default return URL if not provided\n  const baseReturnUrl = returnUrl || \"/pricing\";\n\n  return stripeClient.checkout.sessions.create({\n    customer: customerId,\n    line_items: [\n      {\n        price: priceId,\n        quantity: 1,\n      },\n    ],\n    mode,\n    success_url: `${config.frontendUrl}${baseReturnUrl}${baseReturnUrl.includes(\"?\") ? \"&\" : \"?\"}checkout=success`,\n    cancel_url: `${config.frontendUrl}${baseReturnUrl}${baseReturnUrl.includes(\"?\") ? \"&\" : \"?\"}checkout=canceled`,\n    automatic_tax: { enabled: true },\n    allow_promotion_codes: true,\n    customer_update: {\n      address: \"auto\",\n    },\n    invoice_creation: getInvoiceCreationConfig(mode),\n    // Add 14-day free trial for subscription mode\n    ...(mode === \"subscription\" && {\n      subscription_data: {\n        trial_period_days: 14,\n      },\n      payment_method_collection: \"always\", // Require card upfront (won't be charged during trial)\n    }),\n  });\n}\n\n/**\n * Stripe automatically creates invoices for subscriptions.\n * For one-time payments, we must enable them manually.\n * However, enabling invoices for subscriptions will throw an error.\n */\nfunction getInvoiceCreationConfig(\n  mode: Stripe.Checkout.Session.Mode,\n): Stripe.Checkout.SessionCreateParams[\"invoice_creation\"] {\n  return mode === \"payment\"\n    ? {\n        enabled: true,\n      }\n    : undefined;\n}\n","// PRIVATE API\n// Formats an email address and an optional name into a string that can be used\n// as the \"from\" field in an email.\n// { email: \"test@test.com, name: \"Test\" } -> \"Test <test@test.com>\"\nexport function formatFromField({ email, name, }) {\n    if (name) {\n        return `${name} <${email}>`;\n    }\n    return email;\n}\n// PRIVATE API\nexport function getDefaultFromField() {\n    return {\n        email: \"noreply@basesync.app\",\n        name: \"BaseSync\",\n    };\n}\n//# sourceMappingURL=helpers.js.map","import { createTransport } from \"nodemailer\";\nimport { formatFromField, getDefaultFromField } from \"../helpers.js\";\n// PRIVATE API\nexport function initSmtpEmailSender(config) {\n    const transporter = createTransport({\n        host: config.host,\n        port: config.port,\n        auth: {\n            user: config.username,\n            pass: config.password,\n        },\n    });\n    const defaultFromField = getDefaultFromField();\n    return {\n        async send(email) {\n            return transporter.sendMail({\n                from: formatFromField(email.from || defaultFromField),\n                to: email.to,\n                subject: email.subject,\n                text: email.text,\n                html: email.html,\n            });\n        },\n    };\n}\n//# sourceMappingURL=smtp.js.map","import { env } from '../env.js';\nimport { initEmailSender } from \"./core/index.js\";\nconst emailProvider = {\n    type: \"smtp\",\n    host: env.SMTP_HOST,\n    port: env.SMTP_PORT,\n    username: env.SMTP_USERNAME,\n    password: env.SMTP_PASSWORD,\n};\n// PUBLIC API\nexport const emailSender = initEmailSender(emailProvider);\n//# sourceMappingURL=index.js.map","export class UnhandledWebhookEventError extends Error {\n  constructor(eventType: string) {\n    super(`Unhandled event type: ${eventType}`);\n    this.name = \"UnhandledWebhookEventError\";\n  }\n}\n","import { type PrismaClient } from \"@prisma/client\";\nimport express from \"express\";\nimport type { Stripe } from \"stripe\";\nimport { type MiddlewareConfigFn } from \"wasp/server\";\nimport { type PaymentsWebhook } from \"wasp/server/api\";\nimport { emailSender } from \"wasp/server/email\";\nimport { requireNodeEnvVar } from \"../../server/utils\";\nimport { UnhandledWebhookEventError } from \"../errors\";\nimport {\n  getPaymentPlanIdByPaymentProcessorPlanId,\n  SubscriptionStatus,\n} from \"../plans\";\nimport { updateUserSubscription } from \"../user\";\nimport { stripeClient } from \"./stripeClient\";\n\n/**\n * Stripe requires a raw request to construct events successfully.\n */\nexport const stripeMiddlewareConfigFn: MiddlewareConfigFn = (\n  middlewareConfig,\n) => {\n  middlewareConfig.delete(\"express.json\");\n  middlewareConfig.set(\n    \"express.raw\",\n    express.raw({ type: \"application/json\" }),\n  );\n  return middlewareConfig;\n};\n\nexport const stripeWebhook: PaymentsWebhook = async (\n  request,\n  response,\n  context,\n) => {\n  const prismaUserDelegate = context.entities.User;\n  try {\n    const event = constructStripeEvent(request);\n\n    // If you'd like to handle more events, you can add more cases below.\n    // When deploying your app, you configure your webhook in the Stripe dashboard\n    // to only send the events that you're handling above.\n    // See: https://docs.opensaas.sh/guides/deploying/#setting-up-your-stripe-webhook\n    switch (event.type) {\n      case \"invoice.paid\":\n        await handleInvoicePaid(event, prismaUserDelegate);\n        break;\n      case \"customer.subscription.updated\":\n        await handleCustomerSubscriptionUpdated(event, prismaUserDelegate);\n        break;\n      case \"customer.subscription.deleted\":\n        await handleCustomerSubscriptionDeleted(event, prismaUserDelegate);\n        break;\n      default:\n        throw new UnhandledWebhookEventError(event.type);\n    }\n    return response.status(204).send();\n  } catch (error) {\n    if (error instanceof UnhandledWebhookEventError) {\n      // In development, it is likely that we will receive events that we are not handling.\n      // E.g. via the `stripe trigger` command.\n      if (process.env.NODE_ENV === \"development\") {\n        console.info(\"Unhandled Stripe webhook event in development: \", error);\n      } else if (process.env.NODE_ENV === \"production\") {\n        console.error(\"Unhandled Stripe webhook event in production: \", error);\n      }\n\n      // We must return a 2XX status code, otherwise Stripe will keep retrying the event.\n      return response.status(204).send();\n    }\n\n    console.error(\"Stripe webhook error:\", error);\n    if (error instanceof Error) {\n      return response.status(400).json({ error: error.message });\n    } else {\n      return response\n        .status(500)\n        .json({ error: \"Error processing Stripe webhook event\" });\n    }\n  }\n};\n\nfunction constructStripeEvent(request: express.Request): Stripe.Event {\n  const stripeWebhookSecret = requireNodeEnvVar(\"STRIPE_WEBHOOK_SECRET\");\n  const stripeSignature = request.headers[\"stripe-signature\"];\n  if (!stripeSignature) {\n    throw new Error(\"Stripe webhook signature not provided\");\n  }\n\n  return stripeClient.webhooks.constructEvent(\n    request.body,\n    stripeSignature,\n    stripeWebhookSecret,\n  );\n}\n\nasync function handleInvoicePaid(\n  event: Stripe.InvoicePaidEvent,\n  prismaUserDelegate: PrismaClient[\"user\"],\n): Promise<void> {\n  const invoice = event.data.object;\n  const customerId = getCustomerId(invoice.customer);\n  const invoicePaidAtDate = getInvoicePaidAtDate(invoice);\n  const paymentPlanId = getPaymentPlanIdByPaymentProcessorPlanId(\n    getInvoicePriceId(invoice),\n  );\n\n  // All plans are subscription-based (Starter, Pro, Business)\n  await updateUserSubscription(\n    {\n      paymentProcessorUserId: customerId,\n      datePaid: invoicePaidAtDate,\n      paymentPlanId,\n      subscriptionStatus: SubscriptionStatus.Active,\n    },\n    prismaUserDelegate,\n  );\n}\n\nfunction getInvoicePriceId(invoice: Stripe.Invoice): Stripe.Price[\"id\"] {\n  const invoiceLineItems = invoice.lines.data;\n  // We only expect one line item.\n  // If your workflow expects more, you should change this function to handle them.\n  if (invoiceLineItems.length !== 1) {\n    throw new Error(\"There should be exactly one line item in Stripe invoice\");\n  }\n\n  const priceId = invoiceLineItems[0].pricing?.price_details?.price;\n  if (!priceId) {\n    throw new Error(\"Unable to extract price id from items\");\n  }\n\n  return priceId;\n}\n\nasync function handleCustomerSubscriptionUpdated(\n  event: Stripe.CustomerSubscriptionUpdatedEvent,\n  prismaUserDelegate: PrismaClient[\"user\"],\n): Promise<void> {\n  const subscription = event.data.object;\n\n  // There are other subscription statuses, such as `trialing` that we are not handling.\n  const subscriptionStatus = getOpenSaasSubscriptionStatus(subscription);\n  if (!subscriptionStatus) {\n    return;\n  }\n\n  const customerId = getCustomerId(subscription.customer);\n  const paymentPlanId = getPaymentPlanIdByPaymentProcessorPlanId(\n    getSubscriptionPriceId(subscription),\n  );\n\n  const user = await updateUserSubscription(\n    { paymentProcessorUserId: customerId, paymentPlanId, subscriptionStatus },\n    prismaUserDelegate,\n  );\n\n  if (subscription.cancel_at_period_end && user.email) {\n    await emailSender.send({\n      to: user.email,\n      subject: \"We hate to see you go :(\",\n      text: \"We hate to see you go. Here is a sweet offer...\",\n      html: \"We hate to see you go. Here is a sweet offer...\",\n    });\n  }\n}\n\nfunction getOpenSaasSubscriptionStatus(\n  subscription: Stripe.Subscription,\n): SubscriptionStatus | undefined {\n  const stripeToOpenSaasSubscriptionStatus: Record<\n    Stripe.Subscription.Status,\n    SubscriptionStatus | undefined\n  > = {\n    trialing: SubscriptionStatus.Active,\n    active: SubscriptionStatus.Active,\n    past_due: SubscriptionStatus.PastDue,\n    canceled: SubscriptionStatus.Deleted,\n    unpaid: SubscriptionStatus.Deleted,\n    incomplete_expired: SubscriptionStatus.Deleted,\n    paused: undefined,\n    incomplete: undefined,\n  };\n\n  const subscriptionStatus =\n    stripeToOpenSaasSubscriptionStatus[subscription.status];\n\n  if (\n    subscriptionStatus === SubscriptionStatus.Active &&\n    subscription.cancel_at_period_end\n  ) {\n    return SubscriptionStatus.CancelAtPeriodEnd;\n  }\n\n  return subscriptionStatus;\n}\n\nfunction getSubscriptionPriceId(\n  subscription: Stripe.Subscription,\n): Stripe.Price[\"id\"] {\n  const subscriptionItems = subscription.items.data;\n  // We only expect one subscription item.\n  // If your workflow expects more, you should change this function to handle them.\n  if (subscriptionItems.length !== 1) {\n    throw new Error(\n      \"There should be exactly one subscription item in Stripe subscription\",\n    );\n  }\n\n  return subscriptionItems[0].price.id;\n}\n\nasync function handleCustomerSubscriptionDeleted(\n  event: Stripe.CustomerSubscriptionDeletedEvent,\n  prismaUserDelegate: PrismaClient[\"user\"],\n): Promise<void> {\n  const subscription = event.data.object;\n  const customerId = getCustomerId(subscription.customer);\n\n  await updateUserSubscription(\n    {\n      paymentProcessorUserId: customerId,\n      subscriptionStatus: SubscriptionStatus.Deleted,\n    },\n    prismaUserDelegate,\n  );\n}\n\nfunction getCustomerId(\n  customer: string | Stripe.Customer | Stripe.DeletedCustomer | null,\n): Stripe.Customer[\"id\"] {\n  if (!customer) {\n    throw new Error(\"Customer is missing\");\n  } else if (typeof customer === \"string\") {\n    return customer;\n  } else {\n    return customer.id;\n  }\n}\n\nfunction getInvoicePaidAtDate(invoice: Stripe.Invoice): Date {\n  if (!invoice.status_transitions.paid_at) {\n    throw new Error(\"Invoice has not been paid yet\");\n  }\n\n  // Stripe returns timestamps in seconds (Unix time),\n  // so we multiply by 1000 to convert to milliseconds.\n  return new Date(invoice.status_transitions.paid_at * 1000);\n}\n","import Stripe from \"stripe\";\nimport { config } from \"wasp/server\";\nimport { assertUnreachable } from \"../../shared/utils\";\nimport type {\n  CreateCheckoutSessionArgs,\n  FetchCustomerPortalUrlArgs,\n  PaymentProcessor,\n} from \"../paymentProcessor\";\nimport type { PaymentPlanEffect } from \"../plans\";\nimport {\n  fetchUserPaymentProcessorUserId,\n  updateUserPaymentProcessorUserId,\n} from \"../user\";\nimport {\n  createStripeCheckoutSession,\n  ensureStripeCustomer,\n} from \"./checkoutUtils\";\nimport { stripeClient } from \"./stripeClient\";\nimport { stripeMiddlewareConfigFn, stripeWebhook } from \"./webhook\";\n\nexport const stripePaymentProcessor: PaymentProcessor = {\n  id: \"stripe\",\n  createCheckoutSession: async ({\n    userId,\n    userEmail,\n    paymentPlan,\n    prismaUserDelegate,\n    returnUrl,\n  }: CreateCheckoutSessionArgs) => {\n    const customer = await ensureStripeCustomer(userEmail);\n\n    await updateUserPaymentProcessorUserId(\n      { userId, paymentProcessorUserId: customer.id },\n      prismaUserDelegate,\n    );\n\n    const checkoutSession = await createStripeCheckoutSession({\n      customerId: customer.id,\n      priceId: paymentPlan.getPaymentProcessorPlanId(),\n      mode: paymentPlanEffectToStripeCheckoutSessionMode(paymentPlan.effect),\n      returnUrl,\n    });\n\n    if (!checkoutSession.url) {\n      throw new Error(\n        \"Stripe checkout session URL is missing. Checkout session might not be active.\",\n      );\n    }\n\n    return {\n      session: {\n        url: checkoutSession.url,\n        id: checkoutSession.id,\n      },\n    };\n  },\n  fetchCustomerPortalUrl: async ({\n    prismaUserDelegate,\n    userId,\n    returnUrl,\n  }: FetchCustomerPortalUrlArgs) => {\n    const paymentProcessorUserId = await fetchUserPaymentProcessorUserId(\n      userId,\n      prismaUserDelegate,\n    );\n\n    if (!paymentProcessorUserId) {\n      return null;\n    }\n\n    // Default to pricing page if no return URL provided\n    const baseReturnUrl = returnUrl || \"/pricing\";\n\n    const billingPortalSession =\n      await stripeClient.billingPortal.sessions.create({\n        customer: paymentProcessorUserId,\n        return_url: `${config.frontendUrl}${baseReturnUrl}`,\n      });\n\n    return billingPortalSession.url;\n  },\n  webhook: stripeWebhook,\n  webhookMiddlewareConfigFn: stripeMiddlewareConfigFn,\n};\n\nfunction paymentPlanEffectToStripeCheckoutSessionMode({\n  kind,\n}: PaymentPlanEffect): Stripe.Checkout.Session.Mode {\n  switch (kind) {\n    case \"subscription\":\n      return \"subscription\";\n    case \"credits\":\n      return \"payment\";\n    default:\n      assertUnreachable(kind);\n  }\n}\n","import { PrismaClient } from \"@prisma/client\";\nimport { User } from \"wasp/entities\";\nimport type { MiddlewareConfigFn } from \"wasp/server\";\nimport type { PaymentsWebhook } from \"wasp/server/api\";\nimport type { PaymentPlan } from \"./plans\";\nimport { stripePaymentProcessor } from \"./stripe/paymentProcessor\";\n\nexport interface CreateCheckoutSessionArgs {\n  userId: User[\"id\"];\n  userEmail: NonNullable<User[\"email\"]>;\n  paymentPlan: PaymentPlan;\n  prismaUserDelegate: PrismaClient[\"user\"];\n  returnUrl?: string;\n}\n\nexport interface FetchCustomerPortalUrlArgs {\n  userId: User[\"id\"];\n  prismaUserDelegate: PrismaClient[\"user\"];\n  returnUrl?: string;\n}\n\nexport interface PaymentProcessor {\n  id: \"stripe\" | \"lemonsqueezy\" | \"polar\";\n  createCheckoutSession: (\n    args: CreateCheckoutSessionArgs,\n  ) => Promise<{ session: { id: string; url: string } }>;\n  fetchCustomerPortalUrl: (\n    args: FetchCustomerPortalUrlArgs,\n  ) => Promise<string | null>;\n  webhook: PaymentsWebhook;\n  webhookMiddlewareConfigFn: MiddlewareConfigFn;\n}\n\n/**\n * Choose which payment processor you'd like to use, then delete the\n * other payment processor code that you're not using  from `/src/payment`\n */\nexport const paymentProcessor: PaymentProcessor = stripePaymentProcessor;\n// export const paymentProcessor: PaymentProcessor = lemonSqueezyPaymentProcessor;\n// export const paymentProcessor: PaymentProcessor = polarPaymentProcessor;\n","import { HttpError } from \"wasp/server\";\nimport type {\n  GenerateCheckoutSession,\n  GetCustomerPortalUrl,\n} from \"wasp/server/operations\";\nimport * as z from \"zod\";\nimport { PaymentPlanId, paymentPlans } from \"../payment/plans\";\nimport { ensureArgsSchemaOrThrowHttpError } from \"../server/validation\";\nimport { paymentProcessor } from \"./paymentProcessor\";\n\nexport type CheckoutSession = {\n  sessionUrl: string | null;\n  sessionId: string;\n};\n\nconst generateCheckoutSessionSchema = z.object({\n  paymentPlanId: z.nativeEnum(PaymentPlanId),\n  returnUrl: z.string().optional(),\n});\n\ntype GenerateCheckoutSessionInput = z.infer<\n  typeof generateCheckoutSessionSchema\n>;\n\nexport const generateCheckoutSession: GenerateCheckoutSession<\n  GenerateCheckoutSessionInput,\n  CheckoutSession\n> = async (args, context) => {\n  if (!context.user) {\n    throw new HttpError(\n      401,\n      \"Only authenticated users are allowed to perform this operation\",\n    );\n  }\n\n  const { paymentPlanId, returnUrl } = ensureArgsSchemaOrThrowHttpError(\n    generateCheckoutSessionSchema,\n    args,\n  );\n  const userId = context.user.id;\n  const userEmail = context.user.email;\n  if (!userEmail) {\n    // If using the usernameAndPassword Auth method, switch to an Auth method that provides an email.\n    throw new HttpError(403, \"User needs an email to make a payment.\");\n  }\n\n  const paymentPlan = paymentPlans[paymentPlanId];\n  const { session } = await paymentProcessor.createCheckoutSession({\n    userId,\n    userEmail,\n    paymentPlan,\n    prismaUserDelegate: context.entities.User,\n    returnUrl,\n  });\n\n  return {\n    sessionUrl: session.url,\n    sessionId: session.id,\n  };\n};\n\nconst getCustomerPortalUrlSchema = z.object({\n  returnUrl: z.string().optional(),\n}).optional();\n\ntype GetCustomerPortalUrlInput = z.infer<typeof getCustomerPortalUrlSchema>;\n\nexport const getCustomerPortalUrl: GetCustomerPortalUrl<\n  GetCustomerPortalUrlInput,\n  string | null\n> = async (args, context) => {\n  if (!context.user) {\n    throw new HttpError(\n      401,\n      \"Only authenticated users are allowed to perform this operation\",\n    );\n  }\n\n  const validatedArgs = args ? ensureArgsSchemaOrThrowHttpError(\n    getCustomerPortalUrlSchema,\n    args,\n  ) : undefined;\n\n  return paymentProcessor.fetchCustomerPortalUrl({\n    userId: context.user.id,\n    prismaUserDelegate: context.entities.User,\n    returnUrl: validatedArgs?.returnUrl,\n  });\n};\n","import { prisma } from 'wasp/server'\n\nimport { generateCheckoutSession } from '../../../../../src/payment/operations'\n\n\nexport default async function (args, context) {\n  return (generateCheckoutSession as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport generateCheckoutSession from '../../actions/generateCheckoutSession.js'\n\nexport default createAction(generateCheckoutSession)\n","import { HttpError } from 'wasp/server';\nimport type { GetAdminOverviewStats, GetUserDetail, GetActiveSyncs, GetFailedSyncs, UpdateUser, DeleteUser, GetSyncMonitor, ForceRefreshUserToken, PauseResumeSync, TriggerManualSyncAdmin, GetRecentActivity, SearchUsers, GetOnlineUsers } from 'wasp/server/operations';\n\n// ============================================================================\n// ADMIN GUARD - Use this in every admin operation\n// ============================================================================\nfunction requireAdmin(context: any) {\n  if (!context.user) {\n    throw new HttpError(401, 'Authentication required');\n  }\n  if (!context.user.isAdmin) {\n    throw new HttpError(403, 'Admin access required');\n  }\n}\n\n// ============================================================================\n// OVERVIEW PAGE - Stats and alerts\n// ============================================================================\n\nexport const getAdminOverviewStats: GetAdminOverviewStats = async (_args, context) => {\n  requireAdmin(context);\n\n  const now = new Date();\n  const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);\n  const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n  // Users online (active in last 5 minutes)\n  // Note: You'll need to track last activity somehow. For now, we'll use a simple approach.\n  const totalUsers = await context.entities.User.count();\n  const paidUsers = await context.entities.User.count({\n    where: {\n      subscriptionStatus: {\n        in: ['active', 'past_due']\n      }\n    }\n  });\n\n  // Active syncs (SyncLogs with status in progress or started recently)\n  const activeSyncs = await context.entities.SyncLog.findMany({\n    where: {\n      startedAt: { gte: fiveMinutesAgo },\n      completedAt: null\n    },\n    include: {\n      syncConfig: {\n        include: {\n          user: {\n            select: {\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    },\n    take: 10\n  });\n\n  // Syncs completed today\n  const todayStart = new Date(now.setHours(0, 0, 0, 0));\n  const syncsCompletedToday = await context.entities.SyncLog.count({\n    where: {\n      completedAt: { gte: todayStart },\n      status: 'SUCCESS'\n    }\n  });\n\n  // Failed syncs in last 24h\n  const failedSyncs = await context.entities.SyncLog.findMany({\n    where: {\n      startedAt: { gte: oneDayAgo },\n      status: 'FAILED'\n    },\n    include: {\n      syncConfig: {\n        include: {\n          user: {\n            select: {\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    }\n  });\n\n  // Count unique users affected\n  const uniqueFailedUsers = new Set(failedSyncs.map(log => log.syncConfig.userId)).size;\n\n  // Group errors by type\n  const errorTypes: Record<string, number> = {};\n  failedSyncs.forEach(log => {\n    if (log.errors) {\n      try {\n        const errors = JSON.parse(log.errors);\n        if (Array.isArray(errors) && errors.length > 0) {\n          const errorMsg = errors[0].error || 'Unknown error';\n          const errorType = errorMsg.split(':')[0] || errorMsg;\n          errorTypes[errorType] = (errorTypes[errorType] || 0) + 1;\n        }\n      } catch (e) {\n        errorTypes['Parse error'] = (errorTypes['Parse error'] || 0) + 1;\n      }\n    }\n  });\n\n  // Users needing OAuth reauth\n  const needsReauthAirtable = await context.entities.AirtableConnection.count({\n    where: { needsReauth: true }\n  });\n  const needsReauthGoogle = await context.entities.GoogleSheetsConnection.count({\n    where: { needsReauth: true }\n  });\n\n  // Trial users expiring soon (3 days)\n  const threeDaysFromNow = new Date(now.getTime() + 3 * 24 * 60 * 60 * 1000);\n  const trialExpiringUsers = await context.entities.User.count({\n    where: {\n      trialEndsAt: {\n        lte: threeDaysFromNow,\n        gte: now\n      },\n      subscriptionStatus: null\n    }\n  });\n\n  // Revenue this month\n  const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);\n  const paidUsersThisMonth = await context.entities.User.count({\n    where: {\n      datePaid: { gte: monthStart },\n      subscriptionStatus: 'active'\n    }\n  });\n\n  // Calculate MRR (rough estimate based on subscription plans)\n  const usersByPlan = await context.entities.User.groupBy({\n    by: ['subscriptionPlan'],\n    where: {\n      subscriptionStatus: 'active'\n    },\n    _count: true\n  });\n\n  const planPrices: Record<string, number> = {\n    starter: 9,\n    pro: 19,\n    business: 39\n  };\n\n  let mrr = 0;\n  usersByPlan.forEach(group => {\n    if (group.subscriptionPlan && planPrices[group.subscriptionPlan]) {\n      mrr += planPrices[group.subscriptionPlan] * group._count;\n    }\n  });\n\n  return {\n    users: {\n      total: totalUsers,\n      paid: paidUsers,\n      online: 0 // TODO: Implement activity tracking\n    },\n    syncs: {\n      active: activeSyncs.map(log => ({\n        id: log.id,\n        userEmail: log.syncConfig.user.email,\n        syncName: log.syncConfig.name,\n        startedAt: log.startedAt\n      })),\n      completedToday: syncsCompletedToday,\n      failedCount: failedSyncs.length,\n      uniqueFailedUsers\n    },\n    alerts: {\n      failedSyncs: failedSyncs.length,\n      needsReauth: needsReauthAirtable + needsReauthGoogle,\n      trialExpiringSoon: trialExpiringUsers,\n      errorTypes: Object.entries(errorTypes).map(([type, count]) => ({ type, count }))\n    },\n    revenue: {\n      mrr,\n      newSubscriptionsThisMonth: paidUsersThisMonth\n    }\n  };\n};\n\n// ============================================================================\n// RECENT ACTIVITY FEED\n// ============================================================================\n\nexport const getRecentActivity: GetRecentActivity = async (_args, context) => {\n  requireAdmin(context);\n\n  // Get recent sync logs and user activities\n  const recentSyncLogs = await context.entities.SyncLog.findMany({\n    take: 20,\n    orderBy: { startedAt: 'desc' },\n    include: {\n      syncConfig: {\n        include: {\n          user: {\n            select: {\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    }\n  });\n\n  // Get recent user signups\n  const recentSignups = await context.entities.User.findMany({\n    take: 10,\n    orderBy: { createdAt: 'desc' },\n    select: {\n      id: true,\n      email: true,\n      createdAt: true,\n      subscriptionStatus: true\n    }\n  });\n\n  // Combine and sort activities\n  const activities: any[] = [];\n\n  recentSyncLogs.forEach(log => {\n    activities.push({\n      type: log.status === 'FAILED' ? 'sync_failed' : 'sync_completed',\n      timestamp: log.startedAt,\n      userEmail: log.syncConfig.user.email || 'Unknown',\n      userId: log.syncConfig.userId,\n      description: `${log.syncConfig.name} - ${log.recordsSynced} records`,\n      metadata: {\n        syncId: log.syncConfig.id,\n        status: log.status\n      }\n    });\n  });\n\n  recentSignups.forEach(user => {\n    activities.push({\n      type: 'user_signup',\n      timestamp: user.createdAt,\n      userEmail: user.email || 'Unknown',\n      userId: user.id,\n      description: user.subscriptionStatus ? 'Signed up (Paid)' : 'Signed up (Trial)',\n      metadata: {}\n    });\n  });\n\n  // Sort by timestamp descending\n  activities.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n  return activities.slice(0, 20);\n};\n\n// ============================================================================\n// USER SEARCH\n// ============================================================================\n\nexport const searchUsers: SearchUsers = async (args, context) => {\n  requireAdmin(context);\n\n  const query = (args as any).query;\n  if (!query || typeof query !== 'string' || query.trim().length === 0) {\n    return [];\n  }\n\n  const users = await context.entities.User.findMany({\n    where: {\n      OR: [\n        { email: { contains: query, mode: 'insensitive' } },\n        { username: { contains: query, mode: 'insensitive' } }\n      ]\n    },\n    take: 10,\n    select: {\n      id: true,\n      email: true,\n      username: true,\n      subscriptionStatus: true,\n      subscriptionPlan: true\n    }\n  });\n\n  return users;\n};\n\n// ============================================================================\n// ONLINE USERS\n// ============================================================================\n\nexport const getOnlineUsers: GetOnlineUsers = async (_args, context) => {\n  requireAdmin(context);\n\n  // TODO: Implement proper activity tracking\n  // For now, return empty array\n  return [];\n};\n\n// ============================================================================\n// USER DETAIL PAGE\n// ============================================================================\n\nexport const getUserDetail: GetUserDetail = async (args, context) => {\n  requireAdmin(context);\n\n  const { userId } = args as any;\n\n  const user = await context.entities.User.findUnique({\n    where: { id: userId },\n    include: {\n      airtableConnections: true,\n      googleSheetsConnections: true,\n      syncConfigs: {\n        include: {\n          syncLogs: {\n            orderBy: { startedAt: 'desc' },\n            take: 10\n          }\n        }\n      },\n      usageStats: {\n        orderBy: { month: 'desc' },\n        take: 3\n      }\n    }\n  });\n\n  if (!user) {\n    throw new HttpError(404, 'User not found');\n  }\n\n  return user;\n};\n\n// ============================================================================\n// UPDATE USER\n// ============================================================================\n\nexport const updateUser: UpdateUser = async (args, context) => {\n  requireAdmin(context);\n\n  const { userId, updates } = args as any;\n\n  // Validate updates - only allow safe fields\n  const allowedFields = [\n    'email',\n    'username',\n    'subscriptionStatus',\n    'subscriptionPlan',\n    'credits',\n    'isAdmin',\n    'trialEndsAt',\n    'emailNotifications',\n    'syncFailureAlerts',\n    'weeklyDigest'\n  ];\n\n  const safeUpdates: any = {};\n  Object.keys(updates).forEach(key => {\n    if (allowedFields.includes(key)) {\n      safeUpdates[key] = updates[key];\n    }\n  });\n\n  // Prevent admin from removing their own admin access\n  if (updates.isAdmin === false && userId === context.user?.id) {\n    throw new HttpError(400, 'Cannot remove your own admin access');\n  }\n\n  const updatedUser = await context.entities.User.update({\n    where: { id: userId },\n    data: safeUpdates\n  });\n\n  return updatedUser;\n};\n\n// ============================================================================\n// DELETE USER\n// ============================================================================\n\nexport const deleteUser: DeleteUser = async (args, context) => {\n  requireAdmin(context);\n\n  const { userId, confirmEmail } = args as any;\n\n  // Prevent admin from deleting themselves\n  if (userId === context.user?.id) {\n    throw new HttpError(400, 'Cannot delete your own account');\n  }\n\n  // Get user to verify email\n  const user = await context.entities.User.findUnique({\n    where: { id: userId },\n    select: { email: true }\n  });\n\n  if (!user) {\n    throw new HttpError(404, 'User not found');\n  }\n\n  if (user.email !== confirmEmail) {\n    throw new HttpError(400, 'Email confirmation does not match');\n  }\n\n  // Delete user (cascade will handle related records)\n  await context.entities.User.delete({\n    where: { id: userId }\n  });\n\n  return { success: true };\n};\n\n// ============================================================================\n// SYNC MONITOR\n// ============================================================================\n\nexport const getActiveSyncs: GetActiveSyncs = async (_args, context) => {\n  requireAdmin(context);\n\n  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);\n\n  const syncs = await context.entities.SyncLog.findMany({\n    where: {\n      startedAt: { gte: fiveMinutesAgo },\n      completedAt: null\n    },\n    include: {\n      syncConfig: {\n        include: {\n          user: {\n            select: {\n              id: true,\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    },\n    orderBy: { startedAt: 'desc' }\n  });\n\n  return syncs;\n};\n\nexport const getFailedSyncs: GetFailedSyncs = async (args, context) => {\n  requireAdmin(context);\n\n  const hours = (args as any)?.hours || 24;\n  const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000);\n\n  const syncs = await context.entities.SyncLog.findMany({\n    where: {\n      startedAt: { gte: cutoffTime },\n      status: 'FAILED'\n    },\n    include: {\n      syncConfig: {\n        include: {\n          user: {\n            select: {\n              id: true,\n              email: true,\n              username: true\n            }\n          }\n        }\n      }\n    },\n    orderBy: { startedAt: 'desc' }\n  });\n\n  return syncs;\n};\n\nexport const getSyncMonitor: GetSyncMonitor = async (_args, context) => {\n  requireAdmin(context);\n\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n  const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n\n  const [active, recentCompleted, failed] = await Promise.all([\n    context.entities.SyncLog.findMany({\n      where: {\n        completedAt: null\n      },\n      include: {\n        syncConfig: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                username: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: { startedAt: 'desc' },\n      take: 50\n    }),\n    context.entities.SyncLog.findMany({\n      where: {\n        completedAt: { gte: oneHourAgo },\n        status: 'SUCCESS'\n      },\n      include: {\n        syncConfig: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                username: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: { completedAt: 'desc' },\n      take: 50\n    }),\n    context.entities.SyncLog.findMany({\n      where: {\n        startedAt: { gte: oneDayAgo },\n        status: 'FAILED'\n      },\n      include: {\n        syncConfig: {\n          include: {\n            user: {\n              select: {\n                id: true,\n                email: true,\n                username: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: { startedAt: 'desc' },\n      take: 100\n    })\n  ]);\n\n  return {\n    active,\n    recentCompleted,\n    failed\n  };\n};\n\n// ============================================================================\n// SYNC ACTIONS\n// ============================================================================\n\nexport const pauseResumeSync: PauseResumeSync = async (args, context) => {\n  requireAdmin(context);\n\n  const { syncConfigId, isActive } = args as any;\n\n  const updated = await context.entities.SyncConfig.update({\n    where: { id: syncConfigId },\n    data: { isActive }\n  });\n\n  return updated;\n};\n\nexport const triggerManualSyncAdmin: TriggerManualSyncAdmin = async (args, context) => {\n  requireAdmin(context);\n\n  const { syncConfigId } = args as any;\n\n  // TODO: Implement actual sync trigger\n  // For now, just mark the sync config as needing a sync\n  const syncConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: syncConfigId }\n  });\n\n  if (!syncConfig) {\n    throw new HttpError(404, 'Sync configuration not found');\n  }\n\n  // Return success\n  return { success: true, message: 'Sync triggered successfully' };\n};\n\n// ============================================================================\n// OAUTH ACTIONS\n// ============================================================================\n\nexport const forceRefreshUserToken: ForceRefreshUserToken = async (args, context) => {\n  requireAdmin(context);\n\n  const { userId, service } = args as any;\n\n  if (service === 'airtable') {\n    const connection = await context.entities.AirtableConnection.findUnique({\n      where: { userId }\n    });\n\n    if (!connection) {\n      throw new HttpError(404, 'Airtable connection not found');\n    }\n\n    // TODO: Implement token refresh\n    // For now, just mark as needing reauth\n    await context.entities.AirtableConnection.update({\n      where: { userId },\n      data: { needsReauth: false, lastRefreshAttempt: new Date() }\n    });\n\n    return { success: true, message: 'Airtable token refresh requested' };\n  } else if (service === 'google') {\n    const connection = await context.entities.GoogleSheetsConnection.findUnique({\n      where: { userId }\n    });\n\n    if (!connection) {\n      throw new HttpError(404, 'Google Sheets connection not found');\n    }\n\n    // TODO: Implement token refresh\n    // For now, just mark as needing reauth\n    await context.entities.GoogleSheetsConnection.update({\n      where: { userId },\n      data: { needsReauth: false, lastRefreshAttempt: new Date() }\n    });\n\n    return { success: true, message: 'Google token refresh requested' };\n  } else {\n    throw new HttpError(400, 'Invalid service type');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { updateUser } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (updateUser as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport updateUser from '../../actions/updateUser.js'\n\nexport default createAction(updateUser)\n","import { prisma } from 'wasp/server'\n\nimport { deleteUser } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (deleteUser as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport deleteUser from '../../actions/deleteUser.js'\n\nexport default createAction(deleteUser)\n","import { prisma } from 'wasp/server'\n\nimport { pauseResumeSync } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (pauseResumeSync as any)(args, {\n    ...context,\n    entities: {\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport pauseResumeSync from '../../actions/pauseResumeSync.js'\n\nexport default createAction(pauseResumeSync)\n","import { prisma } from 'wasp/server'\n\nimport { triggerManualSyncAdmin } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (triggerManualSyncAdmin as any)(args, {\n    ...context,\n    entities: {\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport triggerManualSyncAdmin from '../../actions/triggerManualSyncAdmin.js'\n\nexport default createAction(triggerManualSyncAdmin)\n","import { prisma } from 'wasp/server'\n\nimport { forceRefreshUserToken } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (forceRefreshUserToken as any)(args, {\n    ...context,\n    entities: {\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport forceRefreshUserToken from '../../actions/forceRefreshUserToken.js'\n\nexport default createAction(forceRefreshUserToken)\n","import * as crypto from 'crypto';\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16;\nconst AUTH_TAG_LENGTH = 16;\nconst KEY_LENGTH = 32;\n\n/**\n * Gets the encryption key from environment variable\n * The key should be a 64-character hex string (32 bytes)\n */\nfunction getEncryptionKey(): Buffer {\n  const encryptionKey = process.env.ENCRYPTION_KEY;\n\n  if (!encryptionKey) {\n    throw new Error(\n      'ENCRYPTION_KEY environment variable is not set. ' +\n      'Generate one with: node -e \"console.log(require(\\'crypto\\').randomBytes(32).toString(\\'hex\\'))\"'\n    );\n  }\n\n  if (encryptionKey.length !== 64) {\n    throw new Error(\n      `ENCRYPTION_KEY must be a 64-character hex string (32 bytes). Current length: ${encryptionKey.length}`\n    );\n  }\n\n  try {\n    return Buffer.from(encryptionKey, 'hex');\n  } catch (error) {\n    throw new Error('ENCRYPTION_KEY must be a valid hex string');\n  }\n}\n\n/**\n * Encrypts a string using AES-256-GCM\n * Format: iv:authTag:encryptedData (all hex encoded)\n */\nexport function encrypt(plaintext: string): string {\n  if (!plaintext) {\n    throw new Error('Cannot encrypt empty string');\n  }\n\n  const key = getEncryptionKey();\n  const iv = crypto.randomBytes(IV_LENGTH);\n\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n  let encrypted = cipher.update(plaintext, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n\n  const authTag = cipher.getAuthTag();\n\n  // Format: iv:authTag:encryptedData\n  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;\n}\n\n/**\n * Decrypts a string encrypted with the encrypt() function\n */\nexport function decrypt(ciphertext: string): string {\n  if (!ciphertext) {\n    throw new Error('Cannot decrypt empty string');\n  }\n\n  const parts = ciphertext.split(':');\n  if (parts.length !== 3) {\n    throw new Error('Invalid ciphertext format. Expected format: iv:authTag:encryptedData');\n  }\n\n  const [ivHex, authTagHex, encryptedHex] = parts;\n\n  const key = getEncryptionKey();\n  const iv = Buffer.from(ivHex, 'hex');\n  const authTag = Buffer.from(authTagHex, 'hex');\n  const encrypted = Buffer.from(encryptedHex, 'hex');\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n\n  let decrypted = decipher.update(encrypted);\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\n\n  return decrypted.toString('utf8');\n}\n\n/**\n * Validates that the ENCRYPTION_KEY is properly set\n * Call this on server startup to fail fast if misconfigured\n */\nexport function validateEncryptionKey(): void {\n  try {\n    getEncryptionKey();\n  } catch (error) {\n    throw new Error(\n      `Encryption key validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n    );\n  }\n}\n\n/**\n * Helper function to decrypt an encrypted access token\n * Used by background jobs to get plaintext tokens\n */\nexport async function getDecryptedConnection(encryptedAccessToken: string): Promise<string> {\n  return decrypt(encryptedAccessToken);\n}\n","import type { PrismaClient } from '@prisma/client';\nimport type { User, AirtableConnection } from 'wasp/entities';\nimport { encrypt, decrypt } from './encryption';\nimport crypto from 'crypto';\n\n// Type for Prisma delegate (from context.entities)\ntype AirtableConnectionDelegate = {\n  findUnique: PrismaClient['airtableConnection']['findUnique'];\n  upsert: PrismaClient['airtableConnection']['upsert'];\n  delete: PrismaClient['airtableConnection']['delete'];\n};\n\n// Union type that accepts either full Prisma client or just the delegate\ntype PrismaOrDelegate = PrismaClient | AirtableConnectionDelegate;\n\n/**\n * Airtable OAuth Configuration\n * Docs: https://airtable.com/developers/web/api/oauth-reference\n */\nconst AIRTABLE_AUTH_URL = 'https://airtable.com/oauth2/v1/authorize';\nconst AIRTABLE_TOKEN_URL = 'https://airtable.com/oauth2/v1/token';\n\n// Required scopes for BaseSync\nconst REQUIRED_SCOPES = [\n  'data.records:read',\n  'data.records:write',\n  'schema.bases:read',\n];\n\ninterface AirtableOAuthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\ninterface AirtableTokenResponse {\n  access_token: string;\n  refresh_token: string;\n  expires_in: number; // seconds\n  token_type: 'Bearer';\n  scope: string;\n}\n\ninterface AirtableUserInfo {\n  id: string;\n  email?: string;\n}\n\ninterface PKCEChallenge {\n  codeVerifier: string;\n  codeChallenge: string;\n}\n\n/**\n * Gets Airtable OAuth configuration from environment variables\n */\nfunction getAirtableConfig(): AirtableOAuthConfig {\n  const clientId = process.env.AIRTABLE_CLIENT_ID;\n  const clientSecret = process.env.AIRTABLE_CLIENT_SECRET;\n  const redirectUri = process.env.AIRTABLE_REDIRECT_URI;\n\n  if (!clientId || !clientSecret || !redirectUri) {\n    throw new Error(\n      'Missing Airtable OAuth configuration. Please set AIRTABLE_CLIENT_ID, ' +\n      'AIRTABLE_CLIENT_SECRET, and AIRTABLE_REDIRECT_URI in your .env.server file.'\n    );\n  }\n\n  return { clientId, clientSecret, redirectUri };\n}\n\n/**\n * Generates PKCE code verifier and challenge for OAuth\n * @returns Object containing code verifier and challenge\n */\nexport function generatePKCEChallenge(): PKCEChallenge {\n  // Generate a random code verifier (43-128 characters)\n  const codeVerifier = crypto.randomBytes(32).toString('base64url');\n\n  // Create SHA256 hash of the verifier\n  const hash = crypto.createHash('sha256').update(codeVerifier).digest();\n\n  // Base64url encode the hash to get the challenge\n  const codeChallenge = hash.toString('base64url');\n\n  return {\n    codeVerifier,\n    codeChallenge,\n  };\n}\n\n/**\n * Generates the Airtable OAuth authorization URL with PKCE\n * User should be redirected to this URL to start the OAuth flow\n *\n * @param state - Optional state parameter for CSRF protection\n * @param codeChallenge - PKCE code challenge\n * @returns Authorization URL to redirect the user to\n */\nexport function generateAuthorizationUrl(state?: string, codeChallenge?: string): string {\n  const config = getAirtableConfig();\n\n  const params = new URLSearchParams({\n    client_id: config.clientId,\n    redirect_uri: config.redirectUri,\n    response_type: 'code',\n    scope: REQUIRED_SCOPES.join(' '),\n    ...(state && { state }),\n    ...(codeChallenge && {\n      code_challenge: codeChallenge,\n      code_challenge_method: 'S256',\n    }),\n  });\n\n  return `${AIRTABLE_AUTH_URL}?${params.toString()}`;\n}\n\n/**\n * Exchanges an authorization code for access and refresh tokens\n *\n * @param code - Authorization code from Airtable callback\n * @param codeVerifier - PKCE code verifier (optional, required if PKCE was used)\n * @returns Token response from Airtable\n */\nexport async function exchangeCodeForTokens(\n  code: string,\n  codeVerifier?: string\n): Promise<AirtableTokenResponse> {\n  const config = getAirtableConfig();\n\n  const params = new URLSearchParams({\n    grant_type: 'authorization_code',\n    code,\n    redirect_uri: config.redirectUri,\n    ...(codeVerifier && { code_verifier: codeVerifier }),\n  });\n\n  const authHeader = Buffer.from(`${config.clientId}:${config.clientSecret}`).toString('base64');\n\n  const response = await fetch(AIRTABLE_TOKEN_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Authorization': `Basic ${authHeader}`,\n    },\n    body: params.toString(),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to exchange code for tokens: ${response.status} ${response.statusText}. ` +\n      `Error: ${JSON.stringify(errorData)}`\n    );\n  }\n\n  return await response.json() as AirtableTokenResponse;\n}\n\n/**\n * Refreshes an expired access token using the refresh token\n *\n * @param refreshToken - The refresh token (encrypted)\n * @returns New token response from Airtable\n */\nexport async function refreshAccessToken(\n  refreshToken: string\n): Promise<AirtableTokenResponse> {\n  const config = getAirtableConfig();\n\n  // Decrypt the refresh token\n  const decryptedRefreshToken = decrypt(refreshToken);\n\n  const params = new URLSearchParams({\n    grant_type: 'refresh_token',\n    refresh_token: decryptedRefreshToken,\n  });\n\n  const authHeader = Buffer.from(`${config.clientId}:${config.clientSecret}`).toString('base64');\n\n  const response = await fetch(AIRTABLE_TOKEN_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Authorization': `Basic ${authHeader}`,\n    },\n    body: params.toString(),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to refresh access token: ${response.status} ${response.statusText}. ` +\n      `Error: ${JSON.stringify(errorData)}`\n    );\n  }\n\n  return await response.json() as AirtableTokenResponse;\n}\n\n/**\n * Stores encrypted Airtable OAuth tokens in the database\n * Creates a new connection or updates existing one for the user\n *\n * @param userId - User ID\n * @param tokenResponse - Token response from Airtable\n * @param prisma - Prisma client instance or delegate\n */\nexport async function storeAirtableConnection(\n  userId: User['id'],\n  tokenResponse: AirtableTokenResponse,\n  prisma: PrismaOrDelegate\n): Promise<void> {\n  // Encrypt tokens before storing\n  const encryptedAccessToken = encrypt(tokenResponse.access_token);\n  const encryptedRefreshToken = tokenResponse.refresh_token\n    ? encrypt(tokenResponse.refresh_token)\n    : null;\n\n  // Calculate token expiry time\n  const tokenExpiry = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'airtableConnection' in prisma\n    ? prisma.airtableConnection\n    : prisma;\n\n  // Upsert the connection (create or update)\n  await delegate.upsert({\n    where: { userId },\n    create: {\n      userId,\n      accessToken: encryptedAccessToken,\n      refreshToken: encryptedRefreshToken,\n      tokenExpiry,\n    },\n    update: {\n      accessToken: encryptedAccessToken,\n      refreshToken: encryptedRefreshToken,\n      tokenExpiry,\n      updatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Gets and decrypts the Airtable access token for a user\n * Automatically refreshes the token if it's expired\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance or delegate\n * @returns Decrypted access token\n */\nexport async function getAirtableAccessToken(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<string> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'airtableConnection' in prisma\n    ? prisma.airtableConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    throw new Error('Airtable connection not found for user. Please connect your Airtable account.');\n  }\n\n  // Check if token is expired or about to expire (within 5 minutes)\n  const now = new Date();\n  const expiryBuffer = new Date(now.getTime() + 5 * 60 * 1000); // 5 minutes buffer\n\n  if (connection.tokenExpiry && connection.tokenExpiry <= expiryBuffer) {\n    // Token is expired or about to expire, refresh it\n    if (!connection.refreshToken) {\n      throw new Error('Airtable refresh token not found. Please reconnect your Airtable account.');\n    }\n\n    try {\n      const newTokens = await refreshAccessToken(connection.refreshToken);\n      await storeAirtableConnection(userId, newTokens, delegate as any);\n      return newTokens.access_token;\n    } catch (error) {\n      throw new Error(\n        `Failed to refresh Airtable token: ${error instanceof Error ? error.message : 'Unknown error'}. ` +\n        'Please reconnect your Airtable account.'\n      );\n    }\n  }\n\n  // Token is still valid, decrypt and return\n  return decrypt(connection.accessToken);\n}\n\n/**\n * Revokes Airtable access and deletes the connection from the database\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance or delegate\n */\nexport async function revokeAirtableConnection(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<void> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'airtableConnection' in prisma\n    ? prisma.airtableConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    return; // No connection to revoke\n  }\n\n  // Note: Airtable doesn't provide a token revocation endpoint as of 2024\n  // So we just delete the connection from our database\n  // Users can revoke access from their Airtable account settings\n\n  await delegate.delete({\n    where: { userId },\n  });\n}\n\n/**\n * Checks if a user has an active Airtable connection\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance or delegate\n * @returns True if user has a valid connection\n */\nexport async function hasAirtableConnection(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<boolean> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'airtableConnection' in prisma\n    ? prisma.airtableConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n    select: { id: true },\n  });\n\n  return !!connection;\n}\n\n/**\n * Validates the scopes returned by Airtable match what we requested\n *\n * @param grantedScopes - Space-separated list of granted scopes\n * @returns True if all required scopes are granted\n */\nexport function validateScopes(grantedScopes: string): boolean {\n  const granted = new Set(grantedScopes.split(' '));\n  return REQUIRED_SCOPES.every(scope => granted.has(scope));\n}\n","/**\n * Wasp operations for Airtable OAuth integration\n * These functions are exposed as Wasp actions and queries\n */\n\nimport type { User, AirtableConnection } from 'wasp/entities';\nimport type { InitiateAirtableAuth, CompleteAirtableAuth, DisconnectAirtable } from 'wasp/server/operations';\nimport type { GetAirtableConnectionStatus } from 'wasp/server/operations';\nimport {\n  generateAuthorizationUrl,\n  exchangeCodeForTokens,\n  validateScopes,\n  generatePKCEChallenge,\n} from './auth';\nimport { encrypt } from './encryption';\n\n// ============================================================================\n// In-Memory Store for PKCE Code Verifiers\n// ============================================================================\n// In production, consider using Redis or database for multi-instance deployments\nconst pkceStore = new Map<string, { codeVerifier: string; timestamp: number }>();\n\n// Clean up expired PKCE entries (older than 10 minutes)\nsetInterval(() => {\n  const now = Date.now();\n  const tenMinutes = 10 * 60 * 1000;\n  for (const [userId, data] of pkceStore.entries()) {\n    if (now - data.timestamp > tenMinutes) {\n      pkceStore.delete(userId);\n    }\n  }\n}, 5 * 60 * 1000); // Run cleanup every 5 minutes\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype InitiateAirtableAuthInput = void;\ntype InitiateAirtableAuthOutput = { authUrl: string };\n\ntype CompleteAirtableAuthInput = {\n  code: string;\n  state?: string;\n};\ntype CompleteAirtableAuthOutput = {\n  success: boolean;\n  error?: string;\n};\n\ntype GetAirtableConnectionStatusInput = void;\ntype GetAirtableConnectionStatusOutput = {\n  isConnected: boolean;\n  accountId?: string;\n};\n\n// ============================================================================\n// Action: Initiate Airtable OAuth\n// ============================================================================\n\n/**\n * Generates the Airtable OAuth authorization URL with PKCE\n * User should be redirected to this URL to start the OAuth flow\n */\nexport const initiateAirtableAuth: InitiateAirtableAuth<\n  InitiateAirtableAuthInput,\n  InitiateAirtableAuthOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  // Generate PKCE challenge\n  const { codeVerifier, codeChallenge } = generatePKCEChallenge();\n\n  // Store code verifier for later use in the callback\n  pkceStore.set(context.user.id, {\n    codeVerifier,\n    timestamp: Date.now(),\n  });\n\n  // Use user ID as state for CSRF protection\n  const state = context.user.id;\n  const authUrl = generateAuthorizationUrl(state, codeChallenge);\n\n  // Debug: Log the generated URL (client_id and redirect_uri will be visible in server logs)\n  console.log('=== AIRTABLE OAUTH DEBUG ===');\n  console.log('Generated Auth URL:', authUrl);\n  console.log('PKCE Challenge:', codeChallenge);\n  console.log('===========================');\n\n  return { authUrl };\n};\n\n// ============================================================================\n// Action: Complete Airtable OAuth\n// ============================================================================\n\n/**\n * Handles the OAuth callback from Airtable\n * Exchanges code for tokens and stores them encrypted in the database\n */\nexport const completeAirtableAuth: CompleteAirtableAuth<\n  CompleteAirtableAuthInput,\n  CompleteAirtableAuthOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { code, state } = args;\n\n  // Validate required parameters\n  if (!code) {\n    return {\n      success: false,\n      error: 'Missing authorization code',\n    };\n  }\n\n  // Validate state matches user ID (CSRF protection)\n  if (state && state !== context.user.id) {\n    return {\n      success: false,\n      error: 'Invalid state parameter. Please try again.',\n    };\n  }\n\n  try {\n    // Retrieve the PKCE code verifier from our store\n    const pkceData = pkceStore.get(context.user.id);\n    if (!pkceData) {\n      return {\n        success: false,\n        error: 'OAuth session expired. Please try connecting again.',\n      };\n    }\n\n    // Clean up the PKCE data now that we're using it\n    pkceStore.delete(context.user.id);\n\n    // Exchange code for tokens with PKCE code verifier\n    const tokens = await exchangeCodeForTokens(code, pkceData.codeVerifier);\n\n    // Validate that all required scopes were granted\n    if (!validateScopes(tokens.scope)) {\n      return {\n        success: false,\n        error: 'Required permissions were not granted. Please authorize all requested scopes.',\n      };\n    }\n\n    // Encrypt tokens before storing\n    const encryptedAccessToken = encrypt(tokens.access_token);\n    const encryptedRefreshToken = tokens.refresh_token\n      ? encrypt(tokens.refresh_token)\n      : null;\n\n    // Calculate token expiry time\n    const tokenExpiry = new Date(Date.now() + tokens.expires_in * 1000);\n\n    // Store encrypted tokens in database using context.entities\n    await context.entities.AirtableConnection.upsert({\n      where: { userId: context.user.id },\n      create: {\n        userId: context.user.id,\n        accessToken: encryptedAccessToken,\n        refreshToken: encryptedRefreshToken,\n        tokenExpiry,\n      },\n      update: {\n        accessToken: encryptedAccessToken,\n        refreshToken: encryptedRefreshToken,\n        tokenExpiry,\n        updatedAt: new Date(),\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Failed to complete Airtable OAuth:', error);\n\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    // Provide user-friendly error messages\n    if (errorMessage.includes('exchange code for tokens')) {\n      return {\n        success: false,\n        error: 'Failed to connect to Airtable. The authorization code may have expired. Please try again.',\n      };\n    }\n\n    if (errorMessage.includes('AIRTABLE_CLIENT_ID')) {\n      return {\n        success: false,\n        error: 'Airtable integration is not configured. Please contact support.',\n      };\n    }\n\n    return {\n      success: false,\n      error: 'Failed to connect Airtable account. Please try again.',\n    };\n  }\n};\n\n// ============================================================================\n// Query: Get Airtable Connection Status\n// ============================================================================\n\n/**\n * Checks if the user has a valid Airtable connection\n * Returns connection status and basic account info\n */\nexport const getAirtableConnectionStatus: GetAirtableConnectionStatus<\n  GetAirtableConnectionStatusInput,\n  GetAirtableConnectionStatusOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    // Get connection details directly from context.entities\n    const connection = await context.entities.AirtableConnection.findUnique({\n      where: { userId: context.user.id },\n      select: {\n        accountId: true,\n      },\n    });\n\n    if (!connection) {\n      return { isConnected: false };\n    }\n\n    return {\n      isConnected: true,\n      accountId: connection.accountId || undefined,\n    };\n  } catch (error) {\n    console.error('Failed to get Airtable connection status:', error);\n    return { isConnected: false };\n  }\n};\n\n// ============================================================================\n// Action: Disconnect Airtable\n// ============================================================================\n\ntype DisconnectAirtableInput = void;\ntype DisconnectAirtableOutput = {\n  success: boolean;\n  error?: string;\n};\n\n/**\n * Disconnects the user's Airtable account by removing the connection from the database\n */\nexport const disconnectAirtable: DisconnectAirtable<\n  DisconnectAirtableInput,\n  DisconnectAirtableOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    // Check if connection exists\n    const connection = await context.entities.AirtableConnection.findUnique({\n      where: { userId: context.user.id },\n    });\n\n    if (!connection) {\n      return {\n        success: false,\n        error: 'No Airtable connection found',\n      };\n    }\n\n    // Delete the connection\n    await context.entities.AirtableConnection.delete({\n      where: { userId: context.user.id },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Failed to disconnect Airtable:', error);\n    return {\n      success: false,\n      error: 'Failed to disconnect Airtable account. Please try again.',\n    };\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { initiateAirtableAuth } from '../../../../../src/server/airtable/operations'\n\n\nexport default async function (args, context) {\n  return (initiateAirtableAuth as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport initiateAirtableAuth from '../../actions/initiateAirtableAuth.js'\n\nexport default createAction(initiateAirtableAuth)\n","import { prisma } from 'wasp/server'\n\nimport { completeAirtableAuth } from '../../../../../src/server/airtable/operations'\n\n\nexport default async function (args, context) {\n  return (completeAirtableAuth as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport completeAirtableAuth from '../../actions/completeAirtableAuth.js'\n\nexport default createAction(completeAirtableAuth)\n","import { prisma } from 'wasp/server'\n\nimport { disconnectAirtable } from '../../../../../src/server/airtable/operations'\n\n\nexport default async function (args, context) {\n  return (disconnectAirtable as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport disconnectAirtable from '../../actions/disconnectAirtable.js'\n\nexport default createAction(disconnectAirtable)\n","import type { PrismaClient } from '@prisma/client';\nimport type { User } from 'wasp/entities';\nimport { encrypt, decrypt } from '../airtable/encryption';\n\n// Type for Prisma delegate (from context.entities)\ntype GoogleSheetsConnectionDelegate = {\n  findUnique: PrismaClient['googleSheetsConnection']['findUnique'];\n  upsert: PrismaClient['googleSheetsConnection']['upsert'];\n  delete: PrismaClient['googleSheetsConnection']['delete'];\n};\n\n// Union type that accepts either full Prisma client or just the delegate\ntype PrismaOrDelegate = PrismaClient | GoogleSheetsConnectionDelegate;\n\n/**\n * Google OAuth Configuration\n * Docs: https://developers.google.com/identity/protocols/oauth2/web-server\n */\nconst GOOGLE_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth';\nconst GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token';\nconst GOOGLE_REVOKE_URL = 'https://oauth2.googleapis.com/revoke';\n\n// Required scopes for BaseSync\n// Only using spreadsheets scope to avoid Google CASA assessment requirements\nconst REQUIRED_SCOPES = [\n  'https://www.googleapis.com/auth/spreadsheets',\n];\n\ninterface GoogleOAuthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\ninterface GoogleTokenResponse {\n  access_token: string;\n  refresh_token?: string; // Only provided on first authorization or if access_type=offline\n  expires_in: number; // seconds\n  token_type: 'Bearer';\n  scope: string;\n}\n\ninterface GoogleUserInfo {\n  id: string;\n  email?: string;\n  verified_email?: boolean;\n  name?: string;\n  picture?: string;\n}\n\n/**\n * Gets Google OAuth configuration from environment variables\n */\nfunction getGoogleConfig(): GoogleOAuthConfig {\n  const clientId = process.env.GOOGLE_SHEETS_CLIENT_ID;\n  const clientSecret = process.env.GOOGLE_SHEETS_CLIENT_SECRET;\n  const redirectUri = process.env.GOOGLE_SHEETS_REDIRECT_URI;\n\n  if (!clientId || !clientSecret || !redirectUri) {\n    throw new Error(\n      'Missing Google OAuth configuration. Please set GOOGLE_SHEETS_CLIENT_ID, ' +\n      'GOOGLE_SHEETS_CLIENT_SECRET, and GOOGLE_SHEETS_REDIRECT_URI in your .env.server file.'\n    );\n  }\n\n  return { clientId, clientSecret, redirectUri };\n}\n\n/**\n * Generates the Google OAuth authorization URL\n * User should be redirected to this URL to start the OAuth flow\n *\n * @param state - Optional state parameter for CSRF protection\n * @returns Authorization URL to redirect the user to\n */\nexport function generateAuthorizationUrl(state?: string): string {\n  const config = getGoogleConfig();\n\n  const params = new URLSearchParams({\n    client_id: config.clientId,\n    redirect_uri: config.redirectUri,\n    response_type: 'code',\n    scope: REQUIRED_SCOPES.join(' '),\n    access_type: 'offline', // Required to get refresh token\n    prompt: 'consent', // Force consent screen to ensure refresh token is returned\n    ...(state && { state }),\n  });\n\n  return `${GOOGLE_AUTH_URL}?${params.toString()}`;\n}\n\n/**\n * Exchanges an authorization code for access and refresh tokens\n *\n * @param code - Authorization code from Google callback\n * @returns Token response from Google\n */\nexport async function exchangeCodeForTokens(\n  code: string\n): Promise<GoogleTokenResponse> {\n  const config = getGoogleConfig();\n\n  const params = new URLSearchParams({\n    grant_type: 'authorization_code',\n    code,\n    redirect_uri: config.redirectUri,\n    client_id: config.clientId,\n    client_secret: config.clientSecret,\n  });\n\n  const response = await fetch(GOOGLE_TOKEN_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: params.toString(),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to exchange code for tokens: ${response.status} ${response.statusText}. ` +\n      `Error: ${JSON.stringify(errorData)}`\n    );\n  }\n\n  return await response.json() as GoogleTokenResponse;\n}\n\n/**\n * Refreshes an expired access token using the refresh token\n *\n * @param refreshToken - The refresh token (encrypted)\n * @returns New token response from Google\n */\nexport async function refreshAccessToken(\n  refreshToken: string\n): Promise<GoogleTokenResponse> {\n  const config = getGoogleConfig();\n\n  // Decrypt the refresh token\n  const decryptedRefreshToken = decrypt(refreshToken);\n\n  const params = new URLSearchParams({\n    grant_type: 'refresh_token',\n    refresh_token: decryptedRefreshToken,\n    client_id: config.clientId,\n    client_secret: config.clientSecret,\n  });\n\n  const response = await fetch(GOOGLE_TOKEN_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: params.toString(),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to refresh access token: ${response.status} ${response.statusText}. ` +\n      `Error: ${JSON.stringify(errorData)}`\n    );\n  }\n\n  return await response.json() as GoogleTokenResponse;\n}\n\n/**\n * Stores encrypted Google OAuth tokens in the database\n * Creates a new connection or updates existing one for the user\n *\n * @param userId - User ID\n * @param tokenResponse - Token response from Google\n * @param prisma - Prisma client instance\n * @param googleAccountEmail - Optional email to store with connection\n */\nexport async function storeGoogleSheetsConnection(\n  userId: User['id'],\n  tokenResponse: GoogleTokenResponse,\n  prisma: PrismaOrDelegate,\n  googleAccountEmail?: string\n): Promise<void> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'googleSheetsConnection' in prisma\n    ? prisma.googleSheetsConnection\n    : prisma;\n\n  // Encrypt tokens before storing\n  const encryptedAccessToken = encrypt(tokenResponse.access_token);\n  const encryptedRefreshToken = tokenResponse.refresh_token\n    ? encrypt(tokenResponse.refresh_token)\n    : null;\n\n  // Calculate token expiry time\n  const tokenExpiry = new Date(Date.now() + tokenResponse.expires_in * 1000);\n\n  // Get existing connection to preserve refresh token if not provided\n  const existingConnection = await delegate.findUnique({\n    where: { userId },\n  });\n\n  // Upsert the connection (create or update)\n  await delegate.upsert({\n    where: { userId },\n    create: {\n      userId,\n      accessToken: encryptedAccessToken,\n      refreshToken: encryptedRefreshToken,\n      tokenExpiry,\n      googleAccountEmail,\n    },\n    update: {\n      accessToken: encryptedAccessToken,\n      // Only update refresh token if a new one was provided\n      // Google doesn't always return a new refresh token\n      ...(encryptedRefreshToken && { refreshToken: encryptedRefreshToken }),\n      tokenExpiry,\n      ...(googleAccountEmail && { googleAccountEmail }),\n      updatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Gets and decrypts the Google Sheets access token for a user\n * Automatically refreshes the token if it's expired\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance\n * @returns Decrypted access token\n */\nexport async function getGoogleSheetsAccessToken(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<string> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'googleSheetsConnection' in prisma\n    ? prisma.googleSheetsConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    throw new Error('Google Sheets connection not found for user. Please connect your Google account.');\n  }\n\n  // Check if token is expired or about to expire (within 5 minutes)\n  const now = new Date();\n  const expiryBuffer = new Date(now.getTime() + 5 * 60 * 1000); // 5 minutes buffer\n\n  if (connection.tokenExpiry && connection.tokenExpiry <= expiryBuffer) {\n    // Token is expired or about to expire, refresh it\n    if (!connection.refreshToken) {\n      throw new Error('Google refresh token not found. Please reconnect your Google account.');\n    }\n\n    try {\n      const newTokens = await refreshAccessToken(connection.refreshToken);\n      await storeGoogleSheetsConnection(userId, newTokens, delegate as any, connection.googleAccountEmail || undefined);\n      return newTokens.access_token;\n    } catch (error) {\n      throw new Error(\n        `Failed to refresh Google token: ${error instanceof Error ? error.message : 'Unknown error'}. ` +\n        'Please reconnect your Google account.'\n      );\n    }\n  }\n\n  // Token is still valid, decrypt and return\n  return decrypt(connection.accessToken);\n}\n\n/**\n * Fetches the user's Google account information\n *\n * @param accessToken - Valid access token\n * @returns User info from Google\n */\nexport async function getGoogleUserInfo(accessToken: string): Promise<GoogleUserInfo> {\n  const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n    },\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to fetch Google user info: ${response.status} ${response.statusText}. ` +\n      `Error: ${JSON.stringify(errorData)}`\n    );\n  }\n\n  return await response.json() as GoogleUserInfo;\n}\n\n/**\n * Revokes Google access and deletes the connection from the database\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance\n */\nexport async function revokeGoogleSheetsConnection(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<void> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'googleSheetsConnection' in prisma\n    ? prisma.googleSheetsConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    return; // No connection to revoke\n  }\n\n  // Attempt to revoke the token with Google\n  try {\n    const decryptedToken = decrypt(connection.accessToken);\n    const params = new URLSearchParams({\n      token: decryptedToken,\n    });\n\n    await fetch(`${GOOGLE_REVOKE_URL}?${params.toString()}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    });\n  } catch (error) {\n    // If revocation fails, we still delete the connection from our database\n    console.error('Failed to revoke Google token:', error);\n  }\n\n  // Delete the connection from our database\n  await delegate.delete({\n    where: { userId },\n  });\n}\n\n/**\n * Checks if a user has an active Google Sheets connection\n *\n * @param userId - User ID\n * @param prisma - Prisma client instance\n * @returns True if user has a valid connection\n */\nexport async function hasGoogleSheetsConnection(\n  userId: User['id'],\n  prisma: PrismaOrDelegate\n): Promise<boolean> {\n  // Get the delegate (either it IS the delegate, or get it from the client)\n  const delegate = 'googleSheetsConnection' in prisma\n    ? prisma.googleSheetsConnection\n    : prisma;\n\n  const connection = await delegate.findUnique({\n    where: { userId },\n    select: { id: true },\n  });\n\n  return !!connection;\n}\n\n/**\n * Validates the scopes returned by Google match what we requested\n *\n * @param grantedScopes - Space-separated list of granted scopes\n * @returns True if all required scopes are granted\n */\nexport function validateScopes(grantedScopes: string): boolean {\n  const granted = new Set(grantedScopes.split(' '));\n  return REQUIRED_SCOPES.every(scope => granted.has(scope));\n}\n","/**\n * Wasp operations for Google Sheets OAuth integration\n * These functions are exposed as Wasp actions and queries\n */\n\nimport type { User, GoogleSheetsConnection } from 'wasp/entities';\nimport type { InitiateGoogleAuth, CompleteGoogleAuth, DisconnectGoogle } from 'wasp/server/operations';\nimport type { GetGoogleConnectionStatus } from 'wasp/server/operations';\nimport {\n  generateAuthorizationUrl,\n  exchangeCodeForTokens,\n  validateScopes,\n  getGoogleUserInfo,\n} from './auth';\nimport { encrypt } from '../airtable/encryption';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype InitiateGoogleAuthInput = void;\ntype InitiateGoogleAuthOutput = { authUrl: string };\n\ntype CompleteGoogleAuthInput = {\n  code: string;\n  state?: string;\n};\ntype CompleteGoogleAuthOutput = {\n  success: boolean;\n  error?: string;\n};\n\ntype GetGoogleConnectionStatusInput = void;\ntype GetGoogleConnectionStatusOutput = {\n  isConnected: boolean;\n  googleAccountEmail?: string;\n};\n\n// ============================================================================\n// Action: Initiate Google OAuth\n// ============================================================================\n\n/**\n * Generates the Google OAuth authorization URL\n * User should be redirected to this URL to start the OAuth flow\n */\nexport const initiateGoogleAuth: InitiateGoogleAuth<\n  InitiateGoogleAuthInput,\n  InitiateGoogleAuthOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  // Use user ID as state for CSRF protection\n  const state = context.user.id;\n  const authUrl = generateAuthorizationUrl(state);\n\n  return { authUrl };\n};\n\n// ============================================================================\n// Action: Complete Google OAuth\n// ============================================================================\n\n/**\n * Handles the OAuth callback from Google\n * Exchanges code for tokens and stores them encrypted in the database\n */\nexport const completeGoogleAuth: CompleteGoogleAuth<\n  CompleteGoogleAuthInput,\n  CompleteGoogleAuthOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { code, state } = args;\n\n  // Validate required parameters\n  if (!code) {\n    return {\n      success: false,\n      error: 'Missing authorization code',\n    };\n  }\n\n  // Validate state matches user ID (CSRF protection)\n  if (state && state !== context.user.id) {\n    return {\n      success: false,\n      error: 'Invalid state parameter. Please try again.',\n    };\n  }\n\n  try {\n    // Exchange code for tokens\n    const tokens = await exchangeCodeForTokens(code);\n\n    // Validate that all required scopes were granted\n    if (!validateScopes(tokens.scope)) {\n      return {\n        success: false,\n        error: 'Required permissions were not granted. Please authorize all requested scopes.',\n      };\n    }\n\n    // Get user's Google account information\n    let googleAccountEmail: string | undefined;\n    try {\n      const userInfo = await getGoogleUserInfo(tokens.access_token);\n      googleAccountEmail = userInfo.email;\n    } catch (error) {\n      console.warn('Failed to fetch Google user info:', error);\n      // Continue without email - it's not critical\n    }\n\n    // Encrypt tokens before storing\n    const encryptedAccessToken = encrypt(tokens.access_token);\n    const encryptedRefreshToken = tokens.refresh_token\n      ? encrypt(tokens.refresh_token)\n      : null;\n\n    // Calculate token expiry time\n    const tokenExpiry = new Date(Date.now() + tokens.expires_in * 1000);\n\n    // Get existing connection to preserve refresh token if not provided\n    const existingConnection = await context.entities.GoogleSheetsConnection.findUnique({\n      where: { userId: context.user.id },\n    });\n\n    // Store encrypted tokens in database using context.entities\n    await context.entities.GoogleSheetsConnection.upsert({\n      where: { userId: context.user.id },\n      create: {\n        userId: context.user.id,\n        accessToken: encryptedAccessToken,\n        refreshToken: encryptedRefreshToken,\n        tokenExpiry,\n        googleAccountEmail,\n      },\n      update: {\n        accessToken: encryptedAccessToken,\n        // Only update refresh token if a new one was provided\n        // Google doesn't always return a new refresh token\n        ...(encryptedRefreshToken && { refreshToken: encryptedRefreshToken }),\n        tokenExpiry,\n        ...(googleAccountEmail && { googleAccountEmail }),\n        updatedAt: new Date(),\n      },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Failed to complete Google OAuth:', error);\n\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n    // Provide user-friendly error messages\n    if (errorMessage.includes('exchange code for tokens')) {\n      return {\n        success: false,\n        error: 'Failed to connect to Google. The authorization code may have expired. Please try again.',\n      };\n    }\n\n    if (errorMessage.includes('GOOGLE_SHEETS_CLIENT_ID')) {\n      return {\n        success: false,\n        error: 'Google Sheets integration is not configured. Please contact support.',\n      };\n    }\n\n    return {\n      success: false,\n      error: 'Failed to connect Google account. Please try again.',\n    };\n  }\n};\n\n// ============================================================================\n// Query: Get Google Connection Status\n// ============================================================================\n\n/**\n * Checks if the user has a valid Google Sheets connection\n * Returns connection status and basic account info\n */\nexport const getGoogleConnectionStatus: GetGoogleConnectionStatus<\n  GetGoogleConnectionStatusInput,\n  GetGoogleConnectionStatusOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    // Get connection details directly from context.entities\n    const connection = await context.entities.GoogleSheetsConnection.findUnique({\n      where: { userId: context.user.id },\n      select: {\n        googleAccountEmail: true,\n      },\n    });\n\n    if (!connection) {\n      return { isConnected: false };\n    }\n\n    return {\n      isConnected: true,\n      googleAccountEmail: connection.googleAccountEmail || undefined,\n    };\n  } catch (error) {\n    console.error('Failed to get Google Sheets connection status:', error);\n    return { isConnected: false };\n  }\n};\n\n// ============================================================================\n// Action: Disconnect Google\n// ============================================================================\n\ntype DisconnectGoogleInput = void;\ntype DisconnectGoogleOutput = {\n  success: boolean;\n  error?: string;\n};\n\n/**\n * Disconnects the user's Google Sheets account by removing the connection from the database\n */\nexport const disconnectGoogle: DisconnectGoogle<\n  DisconnectGoogleInput,\n  DisconnectGoogleOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    // Check if connection exists\n    const connection = await context.entities.GoogleSheetsConnection.findUnique({\n      where: { userId: context.user.id },\n    });\n\n    if (!connection) {\n      return {\n        success: false,\n        error: 'No Google Sheets connection found',\n      };\n    }\n\n    // Delete the connection\n    await context.entities.GoogleSheetsConnection.delete({\n      where: { userId: context.user.id },\n    });\n\n    return { success: true };\n  } catch (error) {\n    console.error('Failed to disconnect Google Sheets:', error);\n    return {\n      success: false,\n      error: 'Failed to disconnect Google account. Please try again.',\n    };\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { initiateGoogleAuth } from '../../../../../src/server/google/operations'\n\n\nexport default async function (args, context) {\n  return (initiateGoogleAuth as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport initiateGoogleAuth from '../../actions/initiateGoogleAuth.js'\n\nexport default createAction(initiateGoogleAuth)\n","import { prisma } from 'wasp/server'\n\nimport { completeGoogleAuth } from '../../../../../src/server/google/operations'\n\n\nexport default async function (args, context) {\n  return (completeGoogleAuth as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport completeGoogleAuth from '../../actions/completeGoogleAuth.js'\n\nexport default createAction(completeGoogleAuth)\n","import { prisma } from 'wasp/server'\n\nimport { disconnectGoogle } from '../../../../../src/server/google/operations'\n\n\nexport default async function (args, context) {\n  return (disconnectGoogle as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport disconnectGoogle from '../../actions/disconnectGoogle.js'\n\nexport default createAction(disconnectGoogle)\n","/**\n * Typed Airtable API Client\n * Handles API requests to Airtable with rate limiting and proper error handling\n * API Documentation: https://airtable.com/developers/web/api/introduction\n */\n\n// ============================================================================\n// Types - Airtable Field Types\n// ============================================================================\n\nexport type AirtableFieldType =\n  | 'singleLineText'\n  | 'multilineText'\n  | 'richText'\n  | 'email'\n  | 'emailAddress' // Alternative email field type name\n  | 'url'\n  | 'phoneNumber'\n  | 'phone' // Alternative phone field type name\n  | 'number'\n  | 'currency'\n  | 'percent'\n  | 'duration'\n  | 'rating'\n  | 'checkbox'\n  | 'date'\n  | 'dateTime'\n  | 'singleSelect'\n  | 'multipleSelects'\n  | 'singleCollaborator'\n  | 'multipleCollaborators'\n  | 'multipleRecordLinks'\n  | 'barcode'\n  | 'button'\n  | 'count'\n  | 'createdBy'\n  | 'createdTime'\n  | 'lastModifiedBy'\n  | 'lastModifiedTime'\n  | 'multipleAttachments'\n  | 'autoNumber'\n  | 'formula'\n  | 'rollup'\n  | 'multipleLookupValues';\n\nexport interface AirtableAttachment {\n  id: string;\n  url: string;\n  filename: string;\n  size: number;\n  type: string;\n  width?: number;\n  height?: number;\n  thumbnails?: {\n    small?: { url: string; width: number; height: number };\n    large?: { url: string; width: number; height: number };\n    full?: { url: string; width: number; height: number };\n  };\n}\n\nexport interface AirtableCollaborator {\n  id: string;\n  email: string;\n  name?: string;\n}\n\nexport type AirtableFieldValue =\n  | string\n  | number\n  | boolean\n  | string[] // multipleSelects\n  | AirtableAttachment[]\n  | AirtableCollaborator[]\n  | { id: string }[] // linked records\n  | Date\n  | null;\n\nexport interface AirtableRecord {\n  id: string;\n  createdTime: string;\n  fields: Record<string, AirtableFieldValue>;\n}\n\nexport interface AirtableField {\n  id: string;\n  name: string;\n  type: AirtableFieldType;\n  description?: string;\n  options?: {\n    choices?: Array<{ id: string; name: string; color?: string }>;\n    linkedTableId?: string;\n    isReversed?: boolean;\n    prefersSingleRecordLink?: boolean;\n    inverseLinkFieldId?: string;\n    result?: { type: string; options?: unknown };\n    [key: string]: unknown;\n  };\n}\n\nexport interface AirtableTable {\n  id: string;\n  name: string;\n  description?: string;\n  primaryFieldId: string;\n  fields: AirtableField[];\n}\n\nexport interface AirtableBase {\n  id: string;\n  name: string;\n  permissionLevel: 'none' | 'read' | 'comment' | 'edit' | 'create';\n}\n\nexport interface AirtableBaseSchema {\n  tables: AirtableTable[];\n}\n\n// ============================================================================\n// API Response Types\n// ============================================================================\n\ninterface ListBasesResponse {\n  bases: AirtableBase[];\n  offset?: string;\n}\n\ninterface ListRecordsResponse {\n  records: AirtableRecord[];\n  offset?: string;\n}\n\ninterface CreateRecordsResponse {\n  records: AirtableRecord[];\n  createdTime?: string;\n}\n\ninterface UpdateRecordsResponse {\n  records: AirtableRecord[];\n}\n\ninterface DeleteRecordsResponse {\n  records: Array<{\n    id: string;\n    deleted: boolean;\n  }>;\n}\n\n// ============================================================================\n// Options Types\n// ============================================================================\n\nexport interface ListRecordsOptions {\n  fields?: string[]; // Specific fields to return\n  filterByFormula?: string; // Airtable formula to filter records\n  maxRecords?: number; // Maximum total records to return\n  pageSize?: number; // Number of records per page (max 100)\n  sort?: Array<{ field: string; direction: 'asc' | 'desc' }>;\n  view?: string; // Name or ID of a view\n  cellFormat?: 'json' | 'string'; // Default: json\n  timeZone?: string; // e.g., 'America/Los_Angeles'\n  userLocale?: string; // e.g., 'en-us'\n  offset?: string; // For pagination\n}\n\nexport interface CreateRecordData {\n  fields: Record<string, AirtableFieldValue>;\n}\n\nexport interface UpdateRecordData {\n  id: string;\n  fields: Record<string, AirtableFieldValue>;\n}\n\n// ============================================================================\n// Rate Limiter\n// ============================================================================\n\nclass RateLimiter {\n  private queue: Array<() => Promise<void>> = [];\n  private processing = false;\n  private readonly requestsPerSecond: number;\n  private readonly minDelayMs: number;\n  private lastRequestTime = 0;\n\n  constructor(requestsPerSecond: number = 5) {\n    this.requestsPerSecond = requestsPerSecond;\n    this.minDelayMs = 1000 / requestsPerSecond;\n  }\n\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          const result = await fn();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      if (!this.processing) {\n        this.processQueue();\n      }\n    });\n  }\n\n  private async processQueue() {\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const now = Date.now();\n      const timeSinceLastRequest = now - this.lastRequestTime;\n\n      if (timeSinceLastRequest < this.minDelayMs) {\n        await this.sleep(this.minDelayMs - timeSinceLastRequest);\n      }\n\n      const task = this.queue.shift();\n      if (task) {\n        this.lastRequestTime = Date.now();\n        await task();\n      }\n    }\n\n    this.processing = false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// Global rate limiter instance (5 requests per second per Airtable limits)\nconst rateLimiter = new RateLimiter(5);\n\n// ============================================================================\n// Error Handling\n// ============================================================================\n\nexport class AirtableError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public response?: unknown\n  ) {\n    super(message);\n    this.name = 'AirtableError';\n  }\n}\n\nasync function handleAirtableResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n\n    const errorMessage =\n      (errorData as { error?: { message?: string } })?.error?.message ||\n      `Airtable API error: ${response.status} ${response.statusText}`;\n\n    throw new AirtableError(errorMessage, response.status, errorData);\n  }\n\n  return (await response.json()) as T;\n}\n\n// ============================================================================\n// Exponential Backoff for Retries\n// ============================================================================\n\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Don't retry on client errors (4xx except 429)\n      if (\n        error instanceof AirtableError &&\n        error.statusCode &&\n        error.statusCode >= 400 &&\n        error.statusCode < 500 &&\n        error.statusCode !== 429\n      ) {\n        throw error;\n      }\n\n      // Don't retry on last attempt\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      // Exponential backoff with jitter\n      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;\n      console.warn(\n        `Airtable API request failed (attempt ${attempt + 1}/${maxRetries + 1}), ` +\n        `retrying in ${Math.round(delay)}ms...`,\n        lastError.message\n      );\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n// ============================================================================\n// API Client Methods\n// ============================================================================\n\nconst AIRTABLE_API_BASE = 'https://api.airtable.com/v0';\nconst AIRTABLE_META_API_BASE = 'https://api.airtable.com/v0/meta';\n\n/**\n * Lists all bases the user has access to\n * Requires: data.records:read or schema.bases:read scope\n */\nexport async function listBases(accessToken: string): Promise<AirtableBase[]> {\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const response = await fetch(`${AIRTABLE_META_API_BASE}/bases`, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const data = await handleAirtableResponse<ListBasesResponse>(response);\n\n      // Handle pagination if there are more bases\n      let allBases = data.bases;\n      let offset = data.offset;\n\n      while (offset) {\n        const nextResponse = await fetch(\n          `${AIRTABLE_META_API_BASE}/bases?offset=${offset}`,\n          {\n            headers: {\n              Authorization: `Bearer ${accessToken}`,\n              'Content-Type': 'application/json',\n            },\n          }\n        );\n\n        const nextData = await handleAirtableResponse<ListBasesResponse>(nextResponse);\n        allBases = allBases.concat(nextData.bases);\n        offset = nextData.offset;\n      }\n\n      return allBases;\n    });\n  });\n}\n\n/**\n * Gets the schema (tables and fields) for a specific base\n * Requires: schema.bases:read scope\n */\nexport async function getBaseSchema(\n  accessToken: string,\n  baseId: string\n): Promise<AirtableBaseSchema> {\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const response = await fetch(\n        `${AIRTABLE_META_API_BASE}/bases/${baseId}/tables`,\n        {\n          headers: {\n            Authorization: `Bearer ${accessToken}`,\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n\n      return handleAirtableResponse<AirtableBaseSchema>(response);\n    });\n  });\n}\n\n/**\n * Lists records from a table with optional filtering and pagination\n * Requires: data.records:read scope\n */\nexport async function listRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  options: ListRecordsOptions = {}\n): Promise<AirtableRecord[]> {\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const params = new URLSearchParams();\n\n      if (options.fields) {\n        options.fields.forEach((field) => params.append('fields[]', field));\n      }\n      if (options.filterByFormula) {\n        params.append('filterByFormula', options.filterByFormula);\n      }\n      if (options.maxRecords) {\n        params.append('maxRecords', options.maxRecords.toString());\n      }\n      if (options.pageSize) {\n        params.append('pageSize', Math.min(options.pageSize, 100).toString());\n      }\n      if (options.sort) {\n        options.sort.forEach((sort, index) => {\n          params.append(`sort[${index}][field]`, sort.field);\n          params.append(`sort[${index}][direction]`, sort.direction);\n        });\n      }\n      if (options.view) {\n        params.append('view', options.view);\n      }\n      if (options.cellFormat) {\n        params.append('cellFormat', options.cellFormat);\n      }\n      if (options.timeZone) {\n        params.append('timeZone', options.timeZone);\n      }\n      if (options.userLocale) {\n        params.append('userLocale', options.userLocale);\n      }\n      if (options.offset) {\n        params.append('offset', options.offset);\n      }\n\n      const url = `${AIRTABLE_API_BASE}/${baseId}/${tableId}?${params.toString()}`;\n      const response = await fetch(url, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      const data = await handleAirtableResponse<ListRecordsResponse>(response);\n\n      // Handle pagination automatically\n      let allRecords = data.records;\n      let offset = data.offset;\n\n      while (offset && (!options.maxRecords || allRecords.length < options.maxRecords)) {\n        const nextOptions = { ...options, offset };\n        const nextRecords = await listRecords(accessToken, baseId, tableId, nextOptions);\n        allRecords = allRecords.concat(nextRecords);\n\n        // Break if we've fetched enough records\n        if (options.maxRecords && allRecords.length >= options.maxRecords) {\n          allRecords = allRecords.slice(0, options.maxRecords);\n          break;\n        }\n\n        offset = undefined; // Pagination is handled recursively\n      }\n\n      return allRecords;\n    });\n  });\n}\n\n/**\n * Creates records in a table (max 10 per request per Airtable limits)\n * Requires: data.records:write scope\n */\nexport async function createRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  records: CreateRecordData[]\n): Promise<AirtableRecord[]> {\n  // Validate batch size\n  if (records.length === 0) {\n    return [];\n  }\n\n  if (records.length > 10) {\n    throw new AirtableError(\n      'Cannot create more than 10 records at once. Please batch your requests.'\n    );\n  }\n\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const response = await fetch(`${AIRTABLE_API_BASE}/${baseId}/${tableId}`, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ records }),\n      });\n\n      const data = await handleAirtableResponse<CreateRecordsResponse>(response);\n      return data.records;\n    });\n  });\n}\n\n/**\n * Updates records in a table (max 10 per request per Airtable limits)\n * Requires: data.records:write scope\n */\nexport async function updateRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  records: UpdateRecordData[]\n): Promise<AirtableRecord[]> {\n  // Validate batch size\n  if (records.length === 0) {\n    return [];\n  }\n\n  if (records.length > 10) {\n    throw new AirtableError(\n      'Cannot update more than 10 records at once. Please batch your requests.'\n    );\n  }\n\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const response = await fetch(`${AIRTABLE_API_BASE}/${baseId}/${tableId}`, {\n        method: 'PATCH',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ records }),\n      });\n\n      const data = await handleAirtableResponse<UpdateRecordsResponse>(response);\n      return data.records;\n    });\n  });\n}\n\n/**\n * Deletes records from a table (max 10 per request per Airtable limits)\n * Requires: data.records:write scope\n */\nexport async function deleteRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  recordIds: string[]\n): Promise<string[]> {\n  // Validate batch size\n  if (recordIds.length === 0) {\n    return [];\n  }\n\n  if (recordIds.length > 10) {\n    throw new AirtableError(\n      'Cannot delete more than 10 records at once. Please batch your requests.'\n    );\n  }\n\n  return rateLimiter.execute(async () => {\n    return fetchWithRetry(async () => {\n      const params = new URLSearchParams();\n      recordIds.forEach((id) => params.append('records[]', id));\n\n      const response = await fetch(\n        `${AIRTABLE_API_BASE}/${baseId}/${tableId}?${params.toString()}`,\n        {\n          method: 'DELETE',\n          headers: {\n            Authorization: `Bearer ${accessToken}`,\n            'Content-Type': 'application/json',\n          },\n        }\n      );\n\n      const data = await handleAirtableResponse<DeleteRecordsResponse>(response);\n      return data.records.map((record) => record.id);\n    });\n  });\n}\n\n/**\n * Helper function to batch operations (create/update/delete) into chunks of 10\n */\nexport function batchOperations<T>(items: T[], batchSize: number = 10): T[][] {\n  const batches: T[][] = [];\n  for (let i = 0; i < items.length; i += batchSize) {\n    batches.push(items.slice(i, i + batchSize));\n  }\n  return batches;\n}\n","/**\n * Typed Google Sheets API Client\n * Handles API requests to Google Sheets and Drive APIs with proper error handling\n * API Documentation: https://developers.google.com/sheets/api/reference/rest\n */\n\n// ============================================================================\n// Types - Google Sheets API\n// ============================================================================\n\n// NOTE: GoogleSpreadsheet type removed (was only used for Drive API listing)\n\nexport interface GoogleSheet {\n  properties: {\n    sheetId: number;\n    title: string;\n    index: number;\n    sheetType: 'GRID' | 'OBJECT' | 'DATA_SOURCE';\n    gridProperties?: {\n      rowCount: number;\n      columnCount: number;\n      frozenRowCount?: number;\n      frozenColumnCount?: number;\n    };\n    hidden?: boolean;\n    tabColor?: {\n      red?: number;\n      green?: number;\n      blue?: number;\n      alpha?: number;\n    };\n  };\n}\n\nexport interface GoogleSpreadsheetMetadata {\n  spreadsheetId: string;\n  properties: {\n    title: string;\n    locale: string;\n    autoRecalc: string;\n    timeZone: string;\n    defaultFormat?: {\n      backgroundColor?: { red: number; green: number; blue: number };\n      padding?: { top: number; right: number; bottom: number; left: number };\n      textFormat?: {\n        foregroundColor?: { red: number; green: number; blue: number };\n        fontFamily?: string;\n        fontSize?: number;\n        bold?: boolean;\n        italic?: boolean;\n      };\n    };\n  };\n  sheets: GoogleSheet[];\n  spreadsheetUrl: string;\n}\n\nexport interface CellValue {\n  formattedValue?: string;\n  userEnteredValue?: {\n    stringValue?: string;\n    numberValue?: number;\n    boolValue?: boolean;\n    formulaValue?: string;\n    errorValue?: { type: string; message: string };\n  };\n  effectiveValue?: {\n    stringValue?: string;\n    numberValue?: number;\n    boolValue?: boolean;\n    errorValue?: { type: string; message: string };\n  };\n  effectiveFormat?: {\n    numberFormat?: { type: string; pattern?: string };\n    backgroundColor?: { red: number; green: number; blue: number };\n    textFormat?: {\n      foregroundColor?: { red: number; green: number; blue: number };\n      fontFamily?: string;\n      fontSize?: number;\n      bold?: boolean;\n      italic?: boolean;\n    };\n  };\n}\n\nexport interface SheetData {\n  range: string;\n  majorDimension: 'ROWS' | 'COLUMNS';\n  values: any[][]; // 2D array of cell values\n}\n\n// ============================================================================\n// Error Handling\n// ============================================================================\n\nexport class GoogleSheetsError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public response?: unknown,\n    public isQuotaError: boolean = false,\n    public isAuthError: boolean = false\n  ) {\n    super(message);\n    this.name = 'GoogleSheetsError';\n  }\n}\n\nasync function handleGoogleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n\n    const error = (errorData as { error?: { message?: string; code?: number; status?: string } })\n      ?.error;\n    const errorMessage = error?.message || `Google API error: ${response.status} ${response.statusText}`;\n    const errorCode = error?.code || response.status;\n\n    // Check for quota/rate limit errors\n    const isQuotaError =\n      errorCode === 429 ||\n      error?.status === 'RESOURCE_EXHAUSTED' ||\n      errorMessage.toLowerCase().includes('quota') ||\n      errorMessage.toLowerCase().includes('rate limit');\n\n    // Check for authentication errors\n    const isAuthError =\n      errorCode === 401 ||\n      errorCode === 403 ||\n      error?.status === 'UNAUTHENTICATED' ||\n      error?.status === 'PERMISSION_DENIED';\n\n    throw new GoogleSheetsError(errorMessage, errorCode, errorData, isQuotaError, isAuthError);\n  }\n\n  return (await response.json()) as T;\n}\n\n// ============================================================================\n// Exponential Backoff for Retries\n// ============================================================================\n\nasync function fetchWithRetry<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Don't retry on auth errors\n      if (error instanceof GoogleSheetsError && error.isAuthError) {\n        throw error;\n      }\n\n      // Don't retry on client errors (except quota/rate limits)\n      if (\n        error instanceof GoogleSheetsError &&\n        error.statusCode &&\n        error.statusCode >= 400 &&\n        error.statusCode < 500 &&\n        !error.isQuotaError\n      ) {\n        throw error;\n      }\n\n      // Don't retry on last attempt\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      // Use longer delays for quota errors\n      const delayMultiplier = error instanceof GoogleSheetsError && error.isQuotaError ? 3 : 1;\n      const delay = baseDelay * Math.pow(2, attempt) * delayMultiplier + Math.random() * 1000;\n\n      console.warn(\n        `Google Sheets API request failed (attempt ${attempt + 1}/${maxRetries + 1}), ` +\n          `retrying in ${Math.round(delay)}ms...`,\n        lastError.message\n      );\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n// ============================================================================\n// API Client Methods\n// ============================================================================\n\nconst SHEETS_API_BASE = 'https://sheets.googleapis.com/v4';\n\n// NOTE: Drive API functions removed to avoid CASA assessment requirements.\n// Users will paste spreadsheet URLs directly instead of browsing Drive.\n\n/**\n * Gets spreadsheet metadata including all sheets\n * Requires: spreadsheets.readonly or spreadsheets scope\n */\nexport async function getSpreadsheet(\n  accessToken: string,\n  spreadsheetId: string\n): Promise<GoogleSpreadsheetMetadata> {\n  return fetchWithRetry(async () => {\n    const response = await fetch(`${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}`, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n    });\n\n    return handleGoogleResponse<GoogleSpreadsheetMetadata>(response);\n  });\n}\n\n/**\n * Validates that a spreadsheet exists and the user has access to it\n * This replaces the need for Drive API browsing - validates access when user provides URL\n *\n * @param accessToken - Google OAuth access token\n * @param spreadsheetId - The spreadsheet ID to validate\n * @returns Simplified spreadsheet metadata with id, title, and sheets\n * @throws GoogleSheetsError with user-friendly messages for 404, 403, or other errors\n */\nexport async function validateAndGetSpreadsheet(\n  accessToken: string,\n  spreadsheetId: string\n): Promise<{\n  id: string;\n  title: string;\n  sheets: Array<{ sheetId: number; title: string }>;\n}> {\n  return fetchWithRetry(async () => {\n    try {\n      const response = await fetch(`${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}`, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      // Handle specific HTTP error codes before generic error handling\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        const error = (errorData as { error?: { message?: string; code?: number; status?: string } })\n          ?.error;\n        const statusCode = error?.code || response.status;\n\n        // 404 - Spreadsheet not found\n        if (statusCode === 404) {\n          throw new GoogleSheetsError(\n            'Spreadsheet not found. Please check the URL and make sure the spreadsheet exists and is shared with your Google account.',\n            404,\n            errorData,\n            false,\n            false\n          );\n        }\n\n        // 403 - No access permission\n        if (statusCode === 403) {\n          // Check if it's a permission issue specifically\n          const errorMessage = error?.message || '';\n          if (\n            errorMessage.toLowerCase().includes('permission') ||\n            errorMessage.toLowerCase().includes('access') ||\n            error?.status === 'PERMISSION_DENIED'\n          ) {\n            throw new GoogleSheetsError(\n              \"You don't have access to this spreadsheet. Make sure it's shared with your Google account, or that the link sharing settings allow access.\",\n              403,\n              errorData,\n              false,\n              true\n            );\n          }\n\n          // 403 could also be quota error\n          if (\n            errorMessage.toLowerCase().includes('quota') ||\n            errorMessage.toLowerCase().includes('rate limit') ||\n            error?.status === 'RESOURCE_EXHAUSTED'\n          ) {\n            throw new GoogleSheetsError(\n              'Google API quota exceeded. Please try again in a few moments.',\n              403,\n              errorData,\n              true,\n              false\n            );\n          }\n\n          // Generic 403\n          throw new GoogleSheetsError(\n            'Access forbidden. Please check your permissions for this spreadsheet.',\n            403,\n            errorData,\n            false,\n            true\n          );\n        }\n\n        // 401 - Authentication error\n        if (statusCode === 401) {\n          throw new GoogleSheetsError(\n            'Authentication failed. Please reconnect your Google account.',\n            401,\n            errorData,\n            false,\n            true\n          );\n        }\n\n        // 400 - Bad request (likely invalid spreadsheet ID format)\n        if (statusCode === 400) {\n          throw new GoogleSheetsError(\n            'Invalid spreadsheet ID format. Please check the URL and try again.',\n            400,\n            errorData,\n            false,\n            false\n          );\n        }\n\n        // Other errors - let generic handler deal with it\n        throw new GoogleSheetsError(\n          error?.message || `Google Sheets API error: ${response.status} ${response.statusText}`,\n          statusCode,\n          errorData,\n          false,\n          false\n        );\n      }\n\n      const metadata = (await response.json()) as GoogleSpreadsheetMetadata;\n\n      // Return simplified format\n      return {\n        id: metadata.spreadsheetId,\n        title: metadata.properties.title,\n        sheets: metadata.sheets.map((sheet) => ({\n          sheetId: sheet.properties.sheetId,\n          title: sheet.properties.title,\n        })),\n      };\n    } catch (error) {\n      // If it's already a GoogleSheetsError, re-throw it\n      if (error instanceof GoogleSheetsError) {\n        throw error;\n      }\n\n      // Network or other errors\n      if (error instanceof Error) {\n        throw new GoogleSheetsError(\n          `Failed to validate spreadsheet: ${error.message}`,\n          undefined,\n          undefined,\n          false,\n          false\n        );\n      }\n\n      throw new GoogleSheetsError(\n        'Failed to validate spreadsheet. Please try again.',\n        undefined,\n        undefined,\n        false,\n        false\n      );\n    }\n  });\n}\n\n/**\n * Gets data from a sheet\n * @param sheetId - Can be sheet name or gid (numeric ID)\n * @param range - Optional A1 notation range (e.g., \"A1:D10\"), defaults to all data\n * Requires: spreadsheets.readonly or spreadsheets scope\n */\nexport async function getSheetData(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  range?: string\n): Promise<SheetData> {\n  return fetchWithRetry(async () => {\n    // If sheetId is a number (gid), we need to first get the sheet name\n    let sheetName: string;\n\n    if (typeof sheetId === 'number') {\n      const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with gid ${sheetId} not found`);\n      }\n      sheetName = sheet.properties.title;\n    } else {\n      sheetName = sheetId;\n    }\n\n    // Build the range string\n    const rangeString = range ? `${sheetName}!${range}` : sheetName;\n\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(rangeString)}`,\n      {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    return handleGoogleResponse<SheetData>(response);\n  });\n}\n\n/**\n * Updates data in a sheet (overwrites existing data in the range)\n * @param range - A1 notation range (e.g., \"A1:D10\")\n * @param values - 2D array of values to write\n * Requires: spreadsheets scope\n */\nexport async function updateSheetData(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  range: string,\n  values: any[][]\n): Promise<{\n  updatedRange: string;\n  updatedRows: number;\n  updatedColumns: number;\n  updatedCells: number;\n}> {\n  return fetchWithRetry(async () => {\n    // If sheetId is a number (gid), get the sheet name\n    let sheetName: string;\n\n    if (typeof sheetId === 'number') {\n      const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with gid ${sheetId} not found`);\n      }\n      sheetName = sheet.properties.title;\n    } else {\n      sheetName = sheetId;\n    }\n\n    const rangeString = `${sheetName}!${range}`;\n\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(\n        rangeString\n      )}?valueInputOption=USER_ENTERED`,\n      {\n        method: 'PUT',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          range: rangeString,\n          majorDimension: 'ROWS',\n          values: values,\n        }),\n      }\n    );\n\n    return handleGoogleResponse<{\n      spreadsheetId: string;\n      updatedRange: string;\n      updatedRows: number;\n      updatedColumns: number;\n      updatedCells: number;\n    }>(response);\n  });\n}\n\n/**\n * Appends rows to the end of a sheet\n * @param values - 2D array of values to append\n * Requires: spreadsheets scope\n */\nexport async function appendRows(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  values: any[][]\n): Promise<{\n  updatedRange: string;\n  updatedRows: number;\n  updatedColumns: number;\n  updatedCells: number;\n}> {\n  return fetchWithRetry(async () => {\n    // If sheetId is a number (gid), get the sheet name\n    let sheetName: string;\n\n    if (typeof sheetId === 'number') {\n      const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with gid ${sheetId} not found`);\n      }\n      sheetName = sheet.properties.title;\n    } else {\n      sheetName = sheetId;\n    }\n\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(\n        sheetName\n      )}:append?valueInputOption=USER_ENTERED&insertDataOption=INSERT_ROWS`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          range: sheetName,\n          majorDimension: 'ROWS',\n          values: values,\n        }),\n      }\n    );\n\n    const data = await handleGoogleResponse<{\n      spreadsheetId: string;\n      tableRange: string;\n      updates: {\n        spreadsheetId: string;\n        updatedRange: string;\n        updatedRows: number;\n        updatedColumns: number;\n        updatedCells: number;\n      };\n    }>(response);\n\n    return data.updates;\n  });\n}\n\n/**\n * Deletes rows from a sheet\n * Uses the batchUpdate API to delete rows by index\n * @param sheetId - Must be the numeric sheet ID (gid), not the name\n * @param startRow - Starting row index (0-based)\n * @param count - Number of rows to delete\n * Requires: spreadsheets scope\n */\nexport async function deleteRows(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: number,\n  startRow: number,\n  count: number\n): Promise<void> {\n  return fetchWithRetry(async () => {\n    const response = await fetch(`${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        requests: [\n          {\n            deleteDimension: {\n              range: {\n                sheetId: sheetId,\n                dimension: 'ROWS',\n                startIndex: startRow,\n                endIndex: startRow + count,\n              },\n            },\n          },\n        ],\n      }),\n    });\n\n    await handleGoogleResponse<{ spreadsheetId: string; replies: unknown[] }>(response);\n  });\n}\n\n/**\n * Gets the numeric sheet ID (gid) from a sheet name\n * Helper function for operations that require the numeric ID\n */\nexport async function getSheetIdByName(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetName: string\n): Promise<number> {\n  const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n  const sheet = metadata.sheets.find((s) => s.properties.title === sheetName);\n\n  if (!sheet) {\n    throw new GoogleSheetsError(`Sheet with name \"${sheetName}\" not found`);\n  }\n\n  return sheet.properties.sheetId;\n}\n\n/**\n * Clears data from a range in a sheet (keeps formatting)\n * Requires: spreadsheets scope\n */\nexport async function clearSheetData(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  range?: string\n): Promise<{ clearedRange: string }> {\n  return fetchWithRetry(async () => {\n    // If sheetId is a number (gid), get the sheet name\n    let sheetName: string;\n\n    if (typeof sheetId === 'number') {\n      const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with gid ${sheetId} not found`);\n      }\n      sheetName = sheet.properties.title;\n    } else {\n      sheetName = sheetId;\n    }\n\n    const rangeString = range ? `${sheetName}!${range}` : sheetName;\n\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(\n        rangeString\n      )}:clear`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    return handleGoogleResponse<{ spreadsheetId: string; clearedRange: string }>(response);\n  });\n}\n\n/**\n * Creates a new sheet in a spreadsheet\n * Requires: spreadsheets scope\n */\nexport async function createSheet(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetTitle: string,\n  rowCount: number = 1000,\n  columnCount: number = 26\n): Promise<GoogleSheet> {\n  return fetchWithRetry(async () => {\n    const response = await fetch(`${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        requests: [\n          {\n            addSheet: {\n              properties: {\n                title: sheetTitle,\n                gridProperties: {\n                  rowCount,\n                  columnCount,\n                },\n              },\n            },\n          },\n        ],\n      }),\n    });\n\n    const data = await handleGoogleResponse<{\n      spreadsheetId: string;\n      replies: Array<{ addSheet: { properties: GoogleSheet['properties'] } }>;\n    }>(response);\n\n    return { properties: data.replies[0].addSheet.properties };\n  });\n}\n\n/**\n * Helper function to convert column letters to numbers (A=1, B=2, ..., Z=26, AA=27, etc.)\n */\nexport function columnLetterToNumber(column: string): number {\n  let result = 0;\n  for (let i = 0; i < column.length; i++) {\n    result = result * 26 + (column.charCodeAt(i) - 64);\n  }\n  return result;\n}\n\n/**\n * Helper function to convert column numbers to letters (1=A, 2=B, ..., 26=Z, 27=AA, etc.)\n */\nexport function columnNumberToLetter(column: number): string {\n  let result = '';\n  while (column > 0) {\n    const remainder = (column - 1) % 26;\n    result = String.fromCharCode(65 + remainder) + result;\n    column = Math.floor((column - 1) / 26);\n  }\n  return result;\n}\n\n/**\n * Detects the last column index with data in a sheet\n * @param sheetData - The sheet data from getSheetData\n * @returns The zero-based index of the last column with data (0 = A, 1 = B, etc.)\n */\nexport function detectLastColumnIndex(sheetData: SheetData): number {\n  if (!sheetData.values || sheetData.values.length === 0) {\n    return 0;\n  }\n\n  let maxColumns = 0;\n  for (const row of sheetData.values) {\n    if (row.length > maxColumns) {\n      maxColumns = row.length;\n    }\n  }\n\n  return Math.max(0, maxColumns - 1); // Zero-based index\n}\n\n/**\n * Ensures a sheet has at least the specified number of columns\n * Creates additional columns if needed\n * @param accessToken - Google OAuth access token\n * @param spreadsheetId - The spreadsheet ID\n * @param sheetId - The sheet ID (gid) or name\n * @param requiredColumnCount - Minimum number of columns needed (e.g., 27 for column AA)\n */\nexport async function ensureColumnsExist(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  requiredColumnCount: number\n): Promise<void> {\n  return fetchWithRetry(async () => {\n    // Get the numeric sheet ID and current column count\n    let numericSheetId: number;\n    let currentColumnCount: number;\n\n    const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n\n    if (typeof sheetId === 'number') {\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with ID ${sheetId} not found`);\n      }\n      numericSheetId = sheetId;\n      currentColumnCount = sheet.properties.gridProperties?.columnCount || 0;\n    } else {\n      const sheet = metadata.sheets.find((s) => s.properties.title === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet \"${sheetId}\" not found`);\n      }\n      numericSheetId = sheet.properties.sheetId;\n      currentColumnCount = sheet.properties.gridProperties?.columnCount || 0;\n    }\n\n    // If we already have enough columns, do nothing\n    if (currentColumnCount >= requiredColumnCount) {\n      return;\n    }\n\n    // Calculate how many columns to add\n    const columnsToAdd = requiredColumnCount - currentColumnCount;\n\n    // Use appendDimension to add columns\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          requests: [\n            {\n              appendDimension: {\n                sheetId: numericSheetId,\n                dimension: 'COLUMNS',\n                length: columnsToAdd,\n              },\n            },\n          ],\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new GoogleSheetsError(`Failed to add columns: ${error}`);\n    }\n  });\n}\n\n/**\n * Hides a column in a Google Sheet\n * @param accessToken - Google OAuth access token\n * @param spreadsheetId - The spreadsheet ID\n * @param sheetId - The sheet ID (gid) or name\n * @param columnIndex - Zero-based column index to hide (0 = A, 1 = B, etc.)\n */\nexport async function hideColumn(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  columnIndex: number\n): Promise<void> {\n  return fetchWithRetry(async () => {\n    // Get the numeric sheet ID\n    let numericSheetId: number;\n\n    if (typeof sheetId === 'number') {\n      numericSheetId = sheetId;\n    } else {\n      const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n      const sheet = metadata.sheets.find((s) => s.properties.title === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet \"${sheetId}\" not found`);\n      }\n      numericSheetId = sheet.properties.sheetId;\n    }\n\n    // Use batchUpdate to hide the column\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          requests: [\n            {\n              updateDimensionProperties: {\n                range: {\n                  sheetId: numericSheetId,\n                  dimension: 'COLUMNS',\n                  startIndex: columnIndex,\n                  endIndex: columnIndex + 1,\n                },\n                properties: {\n                  hiddenByUser: true,\n                },\n                fields: 'hiddenByUser',\n              },\n            },\n          ],\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new GoogleSheetsError(`Failed to hide column: ${error}`);\n    }\n  });\n}\n\n/**\n * Interface for dropdown validation options\n */\nexport interface DropdownValidationOptions {\n  /** Column index to apply validation (0-based, 0 = A, 1 = B, etc.) */\n  columnIndex: number;\n  /** List of dropdown choices */\n  choices: string[];\n  /** Starting row for validation (1-based, typically 2 to skip header) */\n  startRow?: number;\n  /** Ending row for validation (if not specified, applies to entire column) */\n  endRow?: number;\n  /** Whether to show dropdown in cell (default: true) */\n  showDropdown?: boolean;\n  /** Whether to reject invalid input (default: true) */\n  strict?: boolean;\n}\n\n/**\n * Sets up data validation (dropdown) for a column in Google Sheets\n * This matches Airtable's dropdown behavior for Single Select and Multi Select fields\n *\n * @param accessToken - Google OAuth access token\n * @param spreadsheetId - The spreadsheet ID\n * @param sheetId - The sheet ID (gid) or name\n * @param options - Dropdown validation configuration\n */\nexport async function setColumnDropdownValidation(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  options: DropdownValidationOptions\n): Promise<void> {\n  return fetchWithRetry(async () => {\n    // Get the numeric sheet ID\n    let numericSheetId: number;\n    let rowCount = 1000; // Default fallback\n\n    const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n\n    if (typeof sheetId === 'number') {\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with ID ${sheetId} not found`);\n      }\n      numericSheetId = sheetId;\n      rowCount = sheet.properties.gridProperties?.rowCount || 1000;\n    } else {\n      const sheet = metadata.sheets.find((s) => s.properties.title === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet \"${sheetId}\" not found`);\n      }\n      numericSheetId = sheet.properties.sheetId;\n      rowCount = sheet.properties.gridProperties?.rowCount || 1000;\n    }\n\n    const {\n      columnIndex,\n      choices,\n      startRow = 2, // Default: skip header row\n      endRow = rowCount,\n      showDropdown = true,\n      strict = true,\n    } = options;\n\n    // Build the data validation rule\n    // For multi-select, we'll use ONE_OF_LIST which allows users to enter comma-separated values\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          requests: [\n            {\n              setDataValidation: {\n                range: {\n                  sheetId: numericSheetId,\n                  startRowIndex: startRow - 1, // Convert to 0-based\n                  endRowIndex: endRow,\n                  startColumnIndex: columnIndex,\n                  endColumnIndex: columnIndex + 1,\n                },\n                rule: {\n                  condition: {\n                    type: 'ONE_OF_LIST',\n                    values: choices.map((choice) => ({ userEnteredValue: choice })),\n                  },\n                  showCustomUi: showDropdown,\n                  strict: strict,\n                },\n              },\n            },\n          ],\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new GoogleSheetsError(`Failed to set dropdown validation: ${error}`);\n    }\n  });\n}\n\n/**\n * Batch sets dropdown validations for multiple columns\n * More efficient than calling setColumnDropdownValidation multiple times\n *\n * @param accessToken - Google OAuth access token\n * @param spreadsheetId - The spreadsheet ID\n * @param sheetId - The sheet ID (gid) or name\n * @param validations - Array of dropdown validation configurations\n */\nexport async function batchSetDropdownValidations(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: string | number,\n  validations: DropdownValidationOptions[]\n): Promise<void> {\n  if (validations.length === 0) return;\n\n  return fetchWithRetry(async () => {\n    // Get the numeric sheet ID and row count\n    let numericSheetId: number;\n    let rowCount = 1000;\n\n    const metadata = await getSpreadsheet(accessToken, spreadsheetId);\n\n    if (typeof sheetId === 'number') {\n      const sheet = metadata.sheets.find((s) => s.properties.sheetId === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet with ID ${sheetId} not found`);\n      }\n      numericSheetId = sheetId;\n      rowCount = sheet.properties.gridProperties?.rowCount || 1000;\n    } else {\n      const sheet = metadata.sheets.find((s) => s.properties.title === sheetId);\n      if (!sheet) {\n        throw new GoogleSheetsError(`Sheet \"${sheetId}\" not found`);\n      }\n      numericSheetId = sheet.properties.sheetId;\n      rowCount = sheet.properties.gridProperties?.rowCount || 1000;\n    }\n\n    // Build all validation requests\n    const requests = validations.map((validation) => {\n      const {\n        columnIndex,\n        choices,\n        startRow = 2,\n        endRow = rowCount,\n        showDropdown = true,\n        strict = true,\n      } = validation;\n\n      const columnLetter = columnNumberToLetter(columnIndex + 1);\n      console.log(\n        `[GoogleSheets] Setting validation for column ${columnLetter} (index ${columnIndex}): ${choices.length} choices, ${strict ? 'strict' : 'lenient'}`\n      );\n\n      return {\n        setDataValidation: {\n          range: {\n            sheetId: numericSheetId,\n            startRowIndex: startRow - 1,\n            endRowIndex: endRow,\n            startColumnIndex: columnIndex,\n            endColumnIndex: columnIndex + 1,\n          },\n          rule: {\n            condition: {\n              type: 'ONE_OF_LIST',\n              values: choices.map((choice) => ({ userEnteredValue: choice })),\n            },\n            showCustomUi: showDropdown,\n            strict: strict,\n          },\n        },\n      };\n    });\n\n    console.log(`[GoogleSheets] Sending ${requests.length} validation request(s) to Sheets API...`);\n    console.log(`[GoogleSheets] Sheet ID: ${numericSheetId}, Row count: ${rowCount}`);\n\n    // Send batch request\n    const response = await fetch(\n      `${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`,\n      {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ requests }),\n      }\n    );\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(`[GoogleSheets] API Error Response:`, errorText);\n      throw new GoogleSheetsError(`Failed to batch set dropdown validations: ${errorText}`);\n    }\n\n    const result = await response.json();\n    console.log(`[GoogleSheets] âœ“ Validation API call successful:`, result);\n  });\n}\n","/**\n * Bidirectional Field Type Mapper\n * Converts field types and values between Airtable and Google Sheets\n */\n\nimport type {\n  AirtableFieldType,\n  AirtableFieldValue,\n  AirtableField,\n  AirtableAttachment,\n  AirtableRecord,\n} from '../airtable/client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface FieldMappingContext {\n  /** Airtable field metadata for type-aware conversions */\n  airtableField?: AirtableField;\n  /** Access token for fetching linked record names */\n  accessToken?: string;\n  /** Base ID for linked record lookups */\n  baseId?: string;\n  /** Table ID for linked record lookups */\n  tableId?: string;\n}\n\nexport interface FieldConversionResult {\n  value: any;\n  errors?: string[];\n  warnings?: string[];\n}\n\nexport class FieldMapperError extends Error {\n  constructor(\n    message: string,\n    public fieldName?: string,\n    public sourceType?: string,\n    public targetType?: string\n  ) {\n    super(message);\n    this.name = 'FieldMapperError';\n  }\n}\n\n// ============================================================================\n// Airtable â†’ Sheets Conversion\n// ============================================================================\n\n/**\n * Converts an Airtable field value to a Google Sheets-compatible value\n */\nexport async function airtableToSheets(\n  value: AirtableFieldValue,\n  fieldType: AirtableFieldType,\n  context?: FieldMappingContext\n): Promise<FieldConversionResult> {\n  const result: FieldConversionResult = { value: null, errors: [], warnings: [] };\n\n  try {\n    // Handle null/undefined values\n    if (value === null || value === undefined) {\n      result.value = '';\n      return result;\n    }\n\n    switch (fieldType) {\n      // Text fields â†’ string\n      case 'singleLineText':\n      case 'multilineText':\n      case 'richText':\n      case 'email':\n      case 'emailAddress': // Alternative email field type\n      case 'url':\n      case 'phoneNumber':\n      case 'phone': // Alternative phone field type\n        result.value = String(value);\n        break;\n\n      // Number fields â†’ number\n      case 'number':\n      case 'currency':\n      case 'percent':\n      case 'duration':\n      case 'rating':\n      case 'autoNumber':\n        result.value = typeof value === 'number' ? value : Number(value) || 0;\n        break;\n\n      // Checkbox â†’ \"TRUE\"/\"FALSE\"\n      case 'checkbox':\n        result.value = value ? 'TRUE' : 'FALSE';\n        break;\n\n      // Date fields â†’ ISO string or formatted date\n      case 'date':\n      case 'dateTime':\n      case 'createdTime':\n      case 'lastModifiedTime':\n        if (value instanceof Date) {\n          result.value = value.toISOString();\n        } else if (typeof value === 'string') {\n          // Already a string, validate it's a date\n          const date = new Date(value);\n          if (!isNaN(date.getTime())) {\n            result.value = date.toISOString();\n          } else {\n            result.errors?.push(`Invalid date format: ${value}`);\n            result.value = String(value);\n          }\n        } else {\n          result.errors?.push(`Unexpected date value type: ${typeof value}`);\n          result.value = String(value);\n        }\n        break;\n\n      // Single select â†’ string\n      case 'singleSelect':\n        result.value = String(value);\n        break;\n\n      // Multiple selects â†’ comma-separated string\n      case 'multipleSelects':\n        if (Array.isArray(value)) {\n          result.value = value.join(', ');\n        } else {\n          result.errors?.push(`Expected array for multipleSelects, got ${typeof value}`);\n          result.value = String(value);\n        }\n        break;\n\n      // Linked records â†’ comma-separated names (NOT IDs)\n      case 'multipleRecordLinks':\n        if (Array.isArray(value)) {\n          // If we have access to fetch linked record names\n          if (context?.accessToken && context?.baseId && context?.airtableField?.options?.linkedTableId) {\n            try {\n              const names = await fetchLinkedRecordNames(\n                value as Array<{ id: string }>,\n                context.accessToken,\n                context.baseId,\n                context.airtableField.options.linkedTableId\n              );\n              result.value = names.join(', ');\n            } catch (error) {\n              result.warnings?.push(\n                `Failed to fetch linked record names: ${error instanceof Error ? error.message : String(error)}`\n              );\n              // Fallback to IDs\n              result.value = value.map((record) => (record as { id: string }).id).join(', ');\n            }\n          } else {\n            // Fallback to IDs if we can't fetch names\n            result.value = value.map((record) => (record as { id: string }).id).join(', ');\n            result.warnings?.push(\n              'Linked records exported as IDs (no context provided for name lookup)'\n            );\n          }\n        } else {\n          result.errors?.push(`Expected array for multipleRecordLinks, got ${typeof value}`);\n          result.value = String(value);\n        }\n        break;\n\n      // Attachments â†’ comma-separated URLs\n      case 'multipleAttachments':\n        if (Array.isArray(value)) {\n          const attachments = value as AirtableAttachment[];\n          result.value = attachments.map((att) => att.url).join(', ');\n        } else {\n          result.errors?.push(`Expected array for multipleAttachments, got ${typeof value}`);\n          result.value = String(value);\n        }\n        break;\n\n      // Collaborators â†’ comma-separated names or emails\n      case 'singleCollaborator':\n        if (value && typeof value === 'object' && 'email' in value) {\n          const collab = value as { email: string; name?: string };\n          result.value = collab.name || collab.email;\n        } else {\n          result.value = String(value);\n        }\n        break;\n\n      case 'multipleCollaborators':\n        if (Array.isArray(value)) {\n          const collabs = value as Array<{ email: string; name?: string }>;\n          result.value = collabs.map((c) => c.name || c.email).join(', ');\n        } else {\n          result.errors?.push(`Expected array for multipleCollaborators, got ${typeof value}`);\n          result.value = String(value);\n        }\n        break;\n\n      // Computed fields â†’ appropriate type\n      case 'formula':\n      case 'rollup':\n      case 'count':\n      case 'multipleLookupValues':\n        // These can return various types, handle accordingly\n        if (Array.isArray(value)) {\n          result.value = value.join(', ');\n        } else if (typeof value === 'boolean') {\n          result.value = value ? 'TRUE' : 'FALSE';\n        } else if (value instanceof Date) {\n          result.value = value.toISOString();\n        } else {\n          result.value = value;\n        }\n        break;\n\n      // Barcode â†’ string representation\n      case 'barcode':\n        if (value && typeof value === 'object' && 'text' in value) {\n          result.value = (value as { text: string }).text;\n        } else {\n          result.value = String(value);\n        }\n        break;\n\n      // Button and createdBy â†’ string\n      case 'button':\n      case 'createdBy':\n      case 'lastModifiedBy':\n        result.value = String(value);\n        break;\n\n      default:\n        result.warnings?.push(`Unknown field type: ${fieldType}, converting to string`);\n        result.value = String(value);\n    }\n  } catch (error) {\n    result.errors?.push(\n      `Conversion error: ${error instanceof Error ? error.message : String(error)}`\n    );\n    result.value = String(value); // Fallback to string\n  }\n\n  return result;\n}\n\nimport { listRecords } from '../airtable/client';\n\n/**\n * Helper function to fetch linked record names from Airtable\n */\nasync function fetchLinkedRecordNames(\n  linkedRecords: Array<{ id: string }>,\n  accessToken: string,\n  baseId: string,\n  linkedTableId: string\n): Promise<string[]> {\n  if (linkedRecords.length === 0) return [];\n\n  // Fetch only the records we need using filterByFormula\n  const recordIds = linkedRecords.map((r) => r.id);\n  const formula = `OR(${recordIds.map((id) => `RECORD_ID()='${id}'`).join(',')})`;\n\n  const records = await listRecords(accessToken, baseId, linkedTableId, {\n    filterByFormula: formula,\n    maxRecords: recordIds.length,\n  });\n\n  // Get the primary field value for each record\n  return linkedRecords.map((linkedRecord) => {\n    const record = records.find((r) => r.id === linkedRecord.id);\n    if (!record) return linkedRecord.id; // Fallback to ID if not found\n\n    // Get the first field value (primary field) or use ID\n    const firstFieldValue = Object.values(record.fields)[0];\n    return firstFieldValue ? String(firstFieldValue) : linkedRecord.id;\n  });\n}\n\n// ============================================================================\n// Sheets â†’ Airtable Conversion\n// ============================================================================\n\n/**\n * Converts a Google Sheets value to an Airtable-compatible value\n */\nexport async function sheetsToAirtable(\n  value: any,\n  targetFieldType: AirtableFieldType,\n  context?: FieldMappingContext\n): Promise<FieldConversionResult> {\n  const result: FieldConversionResult = { value: null, errors: [], warnings: [] };\n\n  try {\n    // Handle empty values\n    if (value === null || value === undefined || value === '') {\n      result.value = null;\n      return result;\n    }\n\n    // Convert to string first for easier processing\n    const stringValue = String(value).trim();\n\n    switch (targetFieldType) {\n      // Text fields\n      case 'singleLineText':\n      case 'multilineText':\n      case 'richText':\n      case 'email':\n      case 'emailAddress': // Alternative email field type\n      case 'url':\n      case 'phoneNumber':\n      case 'phone': // Alternative phone field type\n        result.value = stringValue;\n        break;\n\n      // Number fields\n      case 'number':\n      case 'currency':\n      case 'percent':\n      case 'duration':\n      case 'rating':\n        const num = Number(stringValue);\n        if (isNaN(num)) {\n          result.errors?.push(`Cannot convert \"${stringValue}\" to number`);\n          result.value = null;\n        } else {\n          result.value = num;\n        }\n        break;\n\n      // Checkbox\n      case 'checkbox':\n        const upperValue = stringValue.toUpperCase();\n        if (upperValue === 'TRUE' || upperValue === '1' || upperValue === 'YES') {\n          result.value = true;\n        } else if (upperValue === 'FALSE' || upperValue === '0' || upperValue === 'NO') {\n          result.value = false;\n        } else {\n          result.errors?.push(`Cannot convert \"${stringValue}\" to checkbox (use TRUE/FALSE)`);\n          result.value = null;\n        }\n        break;\n\n      // Date fields\n      case 'date':\n      case 'dateTime':\n        const date = parseDate(stringValue);\n        if (date) {\n          // Airtable expects ISO 8601 format\n          result.value = date.toISOString();\n        } else {\n          result.errors?.push(`Cannot parse \"${stringValue}\" as date`);\n          result.value = null;\n        }\n        break;\n\n      // Single select\n      case 'singleSelect':\n        // Validate against available choices if we have field metadata\n        if (context?.airtableField?.options?.choices) {\n          const choices = context.airtableField.options.choices;\n          const matchingChoice = choices.find(\n            (c) => c.name.toLowerCase() === stringValue.toLowerCase()\n          );\n          if (matchingChoice) {\n            result.value = matchingChoice.name;\n          } else {\n            // Check if this looks like it might be wrong field mapping\n            const fieldName = context.airtableField?.name || 'this field';\n            result.errors?.push(\n              `Value \"${stringValue}\" is not a valid choice for ${fieldName}. Available options: ${choices.map((c) => c.name).join(', ')}. Check your field mappings - this column may be mapped to the wrong Airtable field.`\n            );\n            result.value = null;\n          }\n        } else {\n          result.value = stringValue;\n        }\n        break;\n\n      // Multiple selects\n      case 'multipleSelects':\n        const values = stringValue.split(',').map((v) => v.trim()).filter((v) => v);\n\n        // Validate against available choices if we have field metadata\n        if (context?.airtableField?.options?.choices) {\n          const choices = context.airtableField.options.choices;\n          const validValues: string[] = [];\n          const invalidValues: string[] = [];\n\n          values.forEach((val) => {\n            const matchingChoice = choices.find(\n              (c) => c.name.toLowerCase() === val.toLowerCase()\n            );\n            if (matchingChoice) {\n              validValues.push(matchingChoice.name);\n            } else {\n              invalidValues.push(val);\n            }\n          });\n\n          if (invalidValues.length > 0) {\n            result.warnings?.push(\n              `Some values are not valid choices: ${invalidValues.join(', ')}. Available: ${choices.map((c) => c.name).join(', ')}`\n            );\n          }\n\n          result.value = validValues.length > 0 ? validValues : null;\n        } else {\n          result.value = values.length > 0 ? values : null;\n        }\n        break;\n\n      // Linked records\n      case 'multipleRecordLinks':\n        // This requires looking up records by name in the linked table\n        if (context?.accessToken && context?.baseId && context?.airtableField?.options?.linkedTableId) {\n          try {\n            const names = stringValue.split(',').map((v) => v.trim()).filter((v) => v);\n            const recordIds = await fetchRecordIdsByNames(\n              names,\n              context.accessToken,\n              context.baseId,\n              context.airtableField.options.linkedTableId\n            );\n            result.value = recordIds.map((id) => ({ id }));\n\n            if (recordIds.length < names.length) {\n              result.warnings?.push(\n                `Some linked records could not be found: ${names.length - recordIds.length} missing`\n              );\n            }\n          } catch (error) {\n            result.errors?.push(\n              `Failed to lookup linked records: ${error instanceof Error ? error.message : String(error)}`\n            );\n            result.value = null;\n          }\n        } else {\n          result.errors?.push(\n            'Cannot convert to linked records without context (accessToken, baseId, linkedTableId required)'\n          );\n          result.value = null;\n        }\n        break;\n\n      // Read-only fields\n      case 'autoNumber':\n      case 'createdTime':\n      case 'lastModifiedTime':\n      case 'createdBy':\n      case 'lastModifiedBy':\n      case 'formula':\n      case 'rollup':\n      case 'count':\n      case 'multipleLookupValues':\n      case 'button':\n        result.warnings?.push(`Field type \"${targetFieldType}\" is read-only, skipping value`);\n        result.value = null;\n        break;\n\n      // Unsupported write fields (treat as warnings, not errors)\n      case 'multipleAttachments':\n        result.warnings?.push('Attachment upload from Sheets is not supported - field will be skipped');\n        result.value = null;\n        break;\n\n      case 'singleCollaborator':\n      case 'multipleCollaborators':\n        result.warnings?.push('Collaborator assignment from Sheets is not supported - field will be skipped');\n        result.value = null;\n        break;\n\n      case 'barcode':\n        result.warnings?.push('Barcode field type is not supported - field will be skipped');\n        result.value = null;\n        break;\n\n      default:\n        result.warnings?.push(`Unknown field type: ${targetFieldType}, treating as text`);\n        result.value = stringValue;\n    }\n  } catch (error) {\n    result.errors?.push(\n      `Conversion error: ${error instanceof Error ? error.message : String(error)}`\n    );\n    result.value = null;\n  }\n\n  return result;\n}\n\n/**\n * Helper function to parse various date formats\n */\nfunction parseDate(value: string): Date | null {\n  // Try ISO 8601 format first\n  const isoDate = new Date(value);\n  if (!isNaN(isoDate.getTime())) {\n    return isoDate;\n  }\n\n  // Try common formats\n  const formats = [\n    // MM/DD/YYYY\n    /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/,\n    // DD/MM/YYYY\n    /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/,\n    // YYYY-MM-DD\n    /^(\\d{4})-(\\d{1,2})-(\\d{1,2})$/,\n  ];\n\n  for (const format of formats) {\n    const match = value.match(format);\n    if (match) {\n      const date = new Date(value);\n      if (!isNaN(date.getTime())) {\n        return date;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Helper function to fetch record IDs by their names (primary field values)\n */\nasync function fetchRecordIdsByNames(\n  names: string[],\n  accessToken: string,\n  baseId: string,\n  tableId: string\n): Promise<string[]> {\n  if (names.length === 0) return [];\n\n  // Fetch records and filter by primary field\n  // Note: This is a simplified approach. In production, you might want to:\n  // 1. Get the table schema to identify the primary field\n  // 2. Use filterByFormula with the primary field name\n  const records = await listRecords(accessToken, baseId, tableId);\n\n  const recordIds: string[] = [];\n  names.forEach((name) => {\n    const record = records.find((r) => {\n      // Check if any field value matches (simplified - should check primary field)\n      const firstFieldValue = Object.values(r.fields)[0];\n      return String(firstFieldValue).toLowerCase() === name.toLowerCase();\n    });\n    if (record) {\n      recordIds.push(record.id);\n    }\n  });\n\n  return recordIds;\n}\n\n// ============================================================================\n// Batch Conversion Helpers\n// ============================================================================\n\n/**\n * Converts a complete Airtable record to a Sheets row\n */\nexport async function airtableRecordToSheetsRow(\n  record: AirtableRecord,\n  fields: AirtableField[],\n  context?: FieldMappingContext\n): Promise<{\n  row: any[];\n  errors: string[];\n  warnings: string[];\n}> {\n  const row: any[] = [];\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  for (const field of fields) {\n    const value = record.fields[field.name];\n    const conversionContext = { ...context, airtableField: field };\n    const result = await airtableToSheets(value, field.type, conversionContext);\n\n    row.push(result.value);\n\n    if (result.errors?.length) {\n      errors.push(`${field.name}: ${result.errors.join(', ')}`);\n    }\n    if (result.warnings?.length) {\n      warnings.push(`${field.name}: ${result.warnings.join(', ')}`);\n    }\n  }\n\n  return { row, errors, warnings };\n}\n\n/**\n * Converts a Sheets row to Airtable record fields\n */\nexport async function sheetsRowToAirtableFields(\n  row: any[],\n  fields: AirtableField[],\n  context?: FieldMappingContext\n): Promise<{\n  fields: Record<string, AirtableFieldValue>;\n  errors: string[];\n  warnings: string[];\n}> {\n  const recordFields: Record<string, AirtableFieldValue> = {};\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  for (let i = 0; i < fields.length && i < row.length; i++) {\n    const field = fields[i];\n    const value = row[i];\n    const conversionContext = { ...context, airtableField: field };\n    const result = await sheetsToAirtable(value, field.type, conversionContext);\n\n    // Only include the field if we have a value (skip read-only fields)\n    if (result.value !== null && result.value !== undefined) {\n      recordFields[field.name] = result.value;\n    }\n\n    if (result.errors?.length) {\n      errors.push(`${field.name}: ${result.errors.join(', ')}`);\n    }\n    if (result.warnings?.length) {\n      warnings.push(`${field.name}: ${result.warnings.join(', ')}`);\n    }\n  }\n\n  return { fields: recordFields, errors, warnings };\n}\n\n/**\n * Converts a Sheets row to Airtable record fields using explicit field mappings\n * This version uses the field mappings to extract values from the correct columns\n *\n * @param row - Complete row from Sheets (including ID column)\n * @param fields - Airtable fields (already filtered and sorted by mapping)\n * @param fieldMappings - Map of airtableFieldId -> columnIndex\n * @param idColumnIndex - Which column contains the Airtable record ID\n * @param context - Additional context for conversion\n */\nexport async function sheetsRowToAirtableFieldsWithMapping(\n  row: any[],\n  fields: AirtableField[],\n  fieldMappings: Record<string, number>,\n  idColumnIndex: number,\n  context?: FieldMappingContext\n): Promise<{\n  fields: Record<string, AirtableFieldValue>;\n  errors: string[];\n  warnings: string[];\n}> {\n  const recordFields: Record<string, AirtableFieldValue> = {};\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  for (const field of fields) {\n    const columnIndex = fieldMappings[field.id];\n\n    // Skip if no mapping for this field\n    if (columnIndex === undefined) {\n      continue;\n    }\n\n    // Get value from the mapped column\n    const value = row[columnIndex];\n\n    const conversionContext = { ...context, airtableField: field };\n    const result = await sheetsToAirtable(value, field.type, conversionContext);\n\n    // Only include the field if we have a value (skip read-only fields)\n    if (result.value !== null && result.value !== undefined) {\n      recordFields[field.name] = result.value;\n    }\n\n    if (result.errors?.length) {\n      errors.push(`${field.name}: ${result.errors.join(', ')}`);\n    }\n    if (result.warnings?.length) {\n      warnings.push(`${field.name}: ${result.warnings.join(', ')}`);\n    }\n  }\n\n  return { fields: recordFields, errors, warnings };\n}\n\n// ============================================================================\n// Type Guards and Validation\n// ============================================================================\n\n/**\n * Checks if an Airtable field type is read-only\n */\nexport function isReadOnlyField(fieldType: AirtableFieldType): boolean {\n  const readOnlyTypes: AirtableFieldType[] = [\n    'autoNumber',\n    'createdTime',\n    'lastModifiedTime',\n    'createdBy',\n    'lastModifiedBy',\n    'formula',\n    'rollup',\n    'count',\n    'multipleLookupValues',\n    'button',\n  ];\n  return readOnlyTypes.includes(fieldType);\n}\n\n/**\n * Checks if an Airtable field type supports writing from Sheets\n */\nexport function isWritableFromSheets(fieldType: AirtableFieldType): boolean {\n  const unsupportedTypes: AirtableFieldType[] = [\n    'multipleAttachments',\n    'singleCollaborator',\n    'multipleCollaborators',\n    'barcode',\n  ];\n  return !isReadOnlyField(fieldType) && !unsupportedTypes.includes(fieldType);\n}\n\n/**\n * Validates field type compatibility between Airtable and Sheets\n */\nexport function validateFieldCompatibility(\n  airtableField: AirtableField\n): {\n  compatible: boolean;\n  issues: string[];\n} {\n  const issues: string[] = [];\n\n  if (isReadOnlyField(airtableField.type)) {\n    issues.push('Field is read-only and cannot be synced from Sheets to Airtable');\n  }\n\n  if (!isWritableFromSheets(airtableField.type)) {\n    issues.push(`Field type \"${airtableField.type}\" is not supported for Sheets â†’ Airtable sync`);\n  }\n\n  return {\n    compatible: issues.length === 0,\n    issues,\n  };\n}\n","/**\n * Linked Record Resolver\n * Efficiently resolves linked records between IDs and human-readable names\n * Critical for BaseSync's value prop - makes linked records usable in Google Sheets\n */\n\nimport type { AirtableRecord, AirtableField } from '../airtable/client';\nimport { listRecords, getBaseSchema, createRecords } from '../airtable/client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface LinkedRecordCache {\n  /** Map of record ID to primary field value */\n  idToName: Map<string, string>;\n  /** Map of primary field value (lowercase) to record ID */\n  nameToId: Map<string, string>;\n  /** Timestamp when cache was created */\n  timestamp: number;\n}\n\nexport interface ResolveOptions {\n  /** Time-to-live for cache entries in milliseconds (default: 5 minutes) */\n  cacheTTL?: number;\n  /** Whether to create new records if names don't exist (default: false) */\n  createMissing?: boolean;\n  /** Whether to throw errors on missing records (default: true) */\n  strictMode?: boolean;\n}\n\nexport interface ResolveResult {\n  /** Successfully resolved record IDs or names */\n  resolved: string[];\n  /** Items that couldn't be resolved */\n  missing: string[];\n  /** Items that were newly created (if createMissing is true) */\n  created: string[];\n  /** Any warnings during resolution */\n  warnings: string[];\n}\n\n// ============================================================================\n// In-Memory Cache with TTL\n// ============================================================================\n\nclass LinkedRecordCacheManager {\n  private cache: Map<string, LinkedRecordCache> = new Map();\n  private defaultTTL: number = 5 * 60 * 1000; // 5 minutes\n\n  /**\n   * Generates a cache key for a specific table\n   */\n  private getCacheKey(baseId: string, tableId: string): string {\n    return `${baseId}:${tableId}`;\n  }\n\n  /**\n   * Gets cache for a table, returns undefined if expired\n   */\n  getCache(baseId: string, tableId: string, ttl?: number): LinkedRecordCache | undefined {\n    const key = this.getCacheKey(baseId, tableId);\n    const cached = this.cache.get(key);\n\n    if (!cached) return undefined;\n\n    const maxAge = ttl ?? this.defaultTTL;\n    const age = Date.now() - cached.timestamp;\n\n    if (age > maxAge) {\n      // Cache expired, remove it\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return cached;\n  }\n\n  /**\n   * Sets cache for a table\n   */\n  setCache(baseId: string, tableId: string, cache: LinkedRecordCache): void {\n    const key = this.getCacheKey(baseId, tableId);\n    this.cache.set(key, cache);\n  }\n\n  /**\n   * Updates existing cache with new records\n   */\n  updateCache(baseId: string, tableId: string, records: Array<{ id: string; name: string }>): void {\n    const key = this.getCacheKey(baseId, tableId);\n    const existing = this.cache.get(key);\n\n    if (existing) {\n      records.forEach((record) => {\n        existing.idToName.set(record.id, record.name);\n        existing.nameToId.set(record.name.toLowerCase(), record.id);\n      });\n      existing.timestamp = Date.now(); // Refresh timestamp\n    } else {\n      // Create new cache\n      const newCache: LinkedRecordCache = {\n        idToName: new Map(records.map((r) => [r.id, r.name])),\n        nameToId: new Map(records.map((r) => [r.name.toLowerCase(), r.id])),\n        timestamp: Date.now(),\n      };\n      this.cache.set(key, newCache);\n    }\n  }\n\n  /**\n   * Clears all cache entries\n   */\n  clear(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Clears cache for a specific table\n   */\n  clearTable(baseId: string, tableId: string): void {\n    const key = this.getCacheKey(baseId, tableId);\n    this.cache.delete(key);\n  }\n\n  /**\n   * Clears expired cache entries\n   */\n  clearExpired(ttl?: number): void {\n    const maxAge = ttl ?? this.defaultTTL;\n    const now = Date.now();\n\n    for (const [key, cache] of this.cache.entries()) {\n      if (now - cache.timestamp > maxAge) {\n        this.cache.delete(key);\n      }\n    }\n  }\n\n  /**\n   * Gets cache statistics\n   */\n  getStats(): {\n    totalEntries: number;\n    tables: Array<{ key: string; recordCount: number; age: number }>;\n  } {\n    const tables = Array.from(this.cache.entries()).map(([key, cache]) => ({\n      key,\n      recordCount: cache.idToName.size,\n      age: Date.now() - cache.timestamp,\n    }));\n\n    return {\n      totalEntries: this.cache.size,\n      tables,\n    };\n  }\n}\n\n// Global cache instance\nconst cacheManager = new LinkedRecordCacheManager();\n\n// ============================================================================\n// Core Resolution Functions\n// ============================================================================\n\n/**\n * Resolves linked record IDs to their primary field values (human-readable names)\n *\n * @param accessToken - Airtable access token\n * @param baseId - Airtable base ID\n * @param tableId - The linked table ID (where the records live)\n * @param recordIds - Array of record IDs to resolve\n * @param options - Resolution options\n * @returns Resolved names and resolution metadata\n */\nexport async function resolveLinkedRecordNames(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  recordIds: string[],\n  options: ResolveOptions = {}\n): Promise<ResolveResult> {\n  const { cacheTTL, strictMode = true } = options;\n  const result: ResolveResult = {\n    resolved: [],\n    missing: [],\n    created: [],\n    warnings: [],\n  };\n\n  if (recordIds.length === 0) {\n    return result;\n  }\n\n  // Check cache first\n  let cache = cacheManager.getCache(baseId, tableId, cacheTTL);\n\n  // If cache exists, try to resolve from it\n  if (cache) {\n    const uncachedIds: string[] = [];\n\n    for (const recordId of recordIds) {\n      const name = cache.idToName.get(recordId);\n      if (name) {\n        result.resolved.push(name);\n      } else {\n        uncachedIds.push(recordId);\n      }\n    }\n\n    // If all resolved from cache, return early\n    if (uncachedIds.length === 0) {\n      return result;\n    }\n\n    // Fetch only the uncached records\n    recordIds.splice(0, recordIds.length, ...uncachedIds);\n  }\n\n  // Fetch records from Airtable\n  try {\n    // Use filterByFormula to fetch only the specific records we need\n    const formula = `OR(${recordIds.map((id) => `RECORD_ID()='${id}'`).join(',')})`;\n\n    const records = await listRecords(accessToken, baseId, tableId, {\n      filterByFormula: formula,\n      maxRecords: recordIds.length,\n    });\n\n    // Get the table schema to identify the primary field\n    const schema = await getBaseSchema(accessToken, baseId);\n    const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n\n    if (!table) {\n      throw new Error(`Table ${tableId} not found in base schema`);\n    }\n\n    const primaryField = table.fields.find((f) => f.id === table.primaryFieldId);\n    if (!primaryField) {\n      result.warnings.push('Could not identify primary field, using first field value');\n    }\n\n    // Build cache updates and resolve names\n    const cacheUpdates: Array<{ id: string; name: string }> = [];\n\n    for (const recordId of recordIds) {\n      const record = records.find((r) => r.id === recordId);\n\n      if (record) {\n        // Get primary field value\n        const primaryValue = primaryField\n          ? record.fields[primaryField.name]\n          : Object.values(record.fields)[0];\n\n        const name = primaryValue ? String(primaryValue) : recordId;\n        result.resolved.push(name);\n        cacheUpdates.push({ id: recordId, name });\n      } else {\n        result.missing.push(recordId);\n        if (strictMode) {\n          result.warnings.push(`Record ID ${recordId} not found in table ${tableId}`);\n        }\n      }\n    }\n\n    // Update cache with newly fetched records\n    if (cacheUpdates.length > 0) {\n      cacheManager.updateCache(baseId, tableId, cacheUpdates);\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    result.warnings.push(`Failed to fetch linked records: ${errorMessage}`);\n\n    // In non-strict mode, return IDs as fallback\n    if (!strictMode) {\n      result.resolved.push(...recordIds);\n    } else {\n      result.missing.push(...recordIds);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Resolves human-readable names to record IDs in a linked table\n *\n * @param accessToken - Airtable access token\n * @param baseId - Airtable base ID\n * @param tableId - The linked table ID (where the records should be found/created)\n * @param names - Array of human-readable names to resolve\n * @param options - Resolution options\n * @returns Resolved record IDs and resolution metadata\n */\nexport async function resolveNamesToRecordIds(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  names: string[],\n  options: ResolveOptions = {}\n): Promise<ResolveResult> {\n  const { cacheTTL, createMissing = false, strictMode = true } = options;\n  const result: ResolveResult = {\n    resolved: [],\n    missing: [],\n    created: [],\n    warnings: [],\n  };\n\n  if (names.length === 0) {\n    return result;\n  }\n\n  // Normalize names (trim and remove duplicates)\n  const normalizedNames = [...new Set(names.map((n) => n.trim()))].filter((n) => n);\n\n  if (normalizedNames.length === 0) {\n    return result;\n  }\n\n  // Check cache first\n  let cache = cacheManager.getCache(baseId, tableId, cacheTTL);\n\n  if (cache) {\n    const uncachedNames: string[] = [];\n\n    for (const name of normalizedNames) {\n      const recordId = cache.nameToId.get(name.toLowerCase());\n      if (recordId) {\n        result.resolved.push(recordId);\n      } else {\n        uncachedNames.push(name);\n      }\n    }\n\n    // If all resolved from cache, return early\n    if (uncachedNames.length === 0) {\n      return result;\n    }\n\n    // Continue with only uncached names\n    normalizedNames.splice(0, normalizedNames.length, ...uncachedNames);\n  }\n\n  // Fetch records from Airtable\n  try {\n    // Get the table schema to identify the primary field\n    const schema = await getBaseSchema(accessToken, baseId);\n    const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n\n    if (!table) {\n      throw new Error(`Table ${tableId} not found in base schema`);\n    }\n\n    const primaryField = table.fields.find((f) => f.id === table.primaryFieldId);\n    if (!primaryField) {\n      throw new Error('Could not identify primary field for linked table');\n    }\n\n    // Fetch all records from the linked table\n    // Note: For large tables, this could be optimized with filterByFormula\n    // but that requires exact name matching which may miss case variations\n    const records = await listRecords(accessToken, baseId, tableId);\n\n    // Build a lookup map of primary field values to record IDs\n    const nameLookup = new Map<string, string>();\n    const cacheUpdates: Array<{ id: string; name: string }> = [];\n\n    for (const record of records) {\n      const primaryValue = record.fields[primaryField.name];\n      if (primaryValue) {\n        const name = String(primaryValue);\n        nameLookup.set(name.toLowerCase(), record.id);\n        cacheUpdates.push({ id: record.id, name });\n      }\n    }\n\n    // Update cache with all fetched records\n    if (cacheUpdates.length > 0) {\n      cacheManager.updateCache(baseId, tableId, cacheUpdates);\n    }\n\n    // Resolve names to IDs\n    const missingNames: string[] = [];\n\n    for (const name of normalizedNames) {\n      const recordId = nameLookup.get(name.toLowerCase());\n      if (recordId) {\n        result.resolved.push(recordId);\n      } else {\n        missingNames.push(name);\n      }\n    }\n\n    // Handle missing names\n    if (missingNames.length > 0) {\n      if (createMissing) {\n        // Create new records for missing names\n        try {\n          const newRecords = await createNewLinkedRecords(\n            accessToken,\n            baseId,\n            tableId,\n            primaryField.name,\n            missingNames\n          );\n\n          result.resolved.push(...newRecords.map((r) => r.id));\n          result.created.push(...newRecords.map((r) => r.id));\n          result.warnings.push(\n            `Created ${newRecords.length} new records: ${missingNames.join(', ')}`\n          );\n\n          // Update cache with newly created records\n          const newCacheUpdates = newRecords.map((r, i) => ({\n            id: r.id,\n            name: missingNames[i],\n          }));\n          cacheManager.updateCache(baseId, tableId, newCacheUpdates);\n        } catch (error) {\n          const errorMessage = error instanceof Error ? error.message : String(error);\n          result.warnings.push(`Failed to create new records: ${errorMessage}`);\n          result.missing.push(...missingNames);\n        }\n      } else {\n        result.missing.push(...missingNames);\n        if (strictMode) {\n          result.warnings.push(\n            `The following names were not found in linked table: ${missingNames.join(', ')}`\n          );\n        }\n      }\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    result.warnings.push(`Failed to resolve names to record IDs: ${errorMessage}`);\n    result.missing.push(...normalizedNames);\n  }\n\n  return result;\n}\n\n/**\n * Helper function to create new records in a linked table\n */\nasync function createNewLinkedRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  primaryFieldName: string,\n  names: string[]\n): Promise<AirtableRecord[]> {\n  // Create records in batches of 10 (Airtable limit)\n  const batchSize = 10;\n  const allCreatedRecords: AirtableRecord[] = [];\n\n  for (let i = 0; i < names.length; i += batchSize) {\n    const batch = names.slice(i, i + batchSize);\n    const recordData = batch.map((name) => ({\n      fields: { [primaryFieldName]: name },\n    }));\n\n    const createdRecords = await createRecords(accessToken, baseId, tableId, recordData);\n    allCreatedRecords.push(...createdRecords);\n  }\n\n  return allCreatedRecords;\n}\n\n// ============================================================================\n// Batch Resolution Helpers\n// ============================================================================\n\n/**\n * Resolves all linked record fields in multiple Airtable records\n * Optimized to minimize API calls by batching requests per linked table\n *\n * @param accessToken - Airtable access token\n * @param baseId - Airtable base ID\n * @param tableId - Current table ID (for schema lookup)\n * @param records - Array of Airtable records to process\n * @param options - Resolution options\n * @returns Records with resolved linked record names\n */\nexport async function resolveAllLinkedRecords(\n  accessToken: string,\n  baseId: string,\n  tableId: string,\n  records: AirtableRecord[],\n  options: ResolveOptions = {}\n): Promise<{\n  records: Array<AirtableRecord & { _resolvedLinks?: Record<string, string[]> }>;\n  warnings: string[];\n}> {\n  const warnings: string[] = [];\n\n  if (records.length === 0) {\n    return { records, warnings };\n  }\n\n  // Get table schema to identify linked record fields\n  const schema = await getBaseSchema(accessToken, baseId);\n  const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n\n  if (!table) {\n    warnings.push(`Table ${tableId} not found in schema`);\n    return { records, warnings };\n  }\n\n  // Find all linked record fields\n  const linkedFields = table.fields.filter((f) => f.type === 'multipleRecordLinks');\n\n  if (linkedFields.length === 0) {\n    return { records, warnings }; // No linked fields to resolve\n  }\n\n  // Group record IDs by linked table to minimize API calls\n  const linkedTableMap = new Map<\n    string,\n    { fieldName: string; recordIds: Set<string> }[]\n  >();\n\n  for (const field of linkedFields) {\n    const linkedTableId = field.options?.linkedTableId;\n    if (!linkedTableId) continue;\n\n    const fieldData = { fieldName: field.name, recordIds: new Set<string>() };\n\n    // Collect all record IDs for this field across all records\n    for (const record of records) {\n      const value = record.fields[field.name];\n      if (Array.isArray(value)) {\n        value.forEach((item) => {\n          if (item && typeof item === 'object' && 'id' in item) {\n            fieldData.recordIds.add((item as { id: string }).id);\n          }\n        });\n      }\n    }\n\n    if (fieldData.recordIds.size > 0) {\n      const existing = linkedTableMap.get(linkedTableId) || [];\n      existing.push(fieldData);\n      linkedTableMap.set(linkedTableId, existing);\n    }\n  }\n\n  // Resolve all linked records per table\n  const resolutionMap = new Map<string, Map<string, string>>(); // linkedTableId -> (recordId -> name)\n\n  for (const [linkedTableId, fields] of linkedTableMap.entries()) {\n    // Collect all unique record IDs for this linked table\n    const allRecordIds = new Set<string>();\n    fields.forEach((f) => f.recordIds.forEach((id) => allRecordIds.add(id)));\n\n    // Resolve all at once\n    const result = await resolveLinkedRecordNames(\n      accessToken,\n      baseId,\n      linkedTableId,\n      Array.from(allRecordIds),\n      options\n    );\n\n    // Build lookup map\n    const lookup = new Map<string, string>();\n    const recordIdsArray = Array.from(allRecordIds);\n    result.resolved.forEach((name, index) => {\n      if (recordIdsArray[index]) {\n        lookup.set(recordIdsArray[index], name);\n      }\n    });\n\n    resolutionMap.set(linkedTableId, lookup);\n\n    if (result.warnings.length > 0) {\n      warnings.push(...result.warnings);\n    }\n  }\n\n  // Apply resolved names to records\n  const enrichedRecords = records.map((record) => {\n    const _resolvedLinks: Record<string, string[]> = {};\n\n    for (const field of linkedFields) {\n      const linkedTableId = field.options?.linkedTableId;\n      if (!linkedTableId) continue;\n\n      const lookup = resolutionMap.get(linkedTableId);\n      if (!lookup) continue;\n\n      const value = record.fields[field.name];\n      if (Array.isArray(value)) {\n        const names = value\n          .map((item) => {\n            if (item && typeof item === 'object' && 'id' in item) {\n              const id = (item as { id: string }).id;\n              return lookup.get(id) || id; // Fallback to ID if not resolved\n            }\n            return null;\n          })\n          .filter((name): name is string => name !== null);\n\n        _resolvedLinks[field.name] = names;\n      }\n    }\n\n    return {\n      ...record,\n      _resolvedLinks: Object.keys(_resolvedLinks).length > 0 ? _resolvedLinks : undefined,\n    };\n  });\n\n  return { records: enrichedRecords, warnings };\n}\n\n// ============================================================================\n// Cache Management Utilities\n// ============================================================================\n\n/**\n * Clears the entire linked record cache\n */\nexport function clearLinkedRecordCache(): void {\n  cacheManager.clear();\n}\n\n/**\n * Clears cache for a specific table\n */\nexport function clearTableCache(baseId: string, tableId: string): void {\n  cacheManager.clearTable(baseId, tableId);\n}\n\n/**\n * Clears expired cache entries\n */\nexport function clearExpiredCache(ttl?: number): void {\n  cacheManager.clearExpired(ttl);\n}\n\n/**\n * Gets cache statistics\n */\nexport function getCacheStats(): {\n  totalEntries: number;\n  tables: Array<{ key: string; recordCount: number; age: number }>;\n} {\n  return cacheManager.getStats();\n}\n\n/**\n * Pre-loads cache for a table (useful for batch operations)\n */\nexport async function preloadTableCache(\n  accessToken: string,\n  baseId: string,\n  tableId: string\n): Promise<{ recordCount: number; duration: number }> {\n  const startTime = Date.now();\n\n  // Get table schema to find primary field\n  const schema = await getBaseSchema(accessToken, baseId);\n  const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n\n  if (!table) {\n    throw new Error(`Table ${tableId} not found in base schema`);\n  }\n\n  const primaryField = table.fields.find((f) => f.id === table.primaryFieldId);\n  if (!primaryField) {\n    throw new Error('Could not identify primary field for table');\n  }\n\n  // Fetch all records\n  const records = await listRecords(accessToken, baseId, tableId);\n\n  // Build cache\n  const cacheUpdates: Array<{ id: string; name: string }> = [];\n  for (const record of records) {\n    const primaryValue = record.fields[primaryField.name];\n    if (primaryValue) {\n      cacheUpdates.push({ id: record.id, name: String(primaryValue) });\n    }\n  }\n\n  cacheManager.updateCache(baseId, tableId, cacheUpdates);\n\n  const duration = Date.now() - startTime;\n  return { recordCount: cacheUpdates.length, duration };\n}\n","/**\n * Dropdown Field Detector\n * Detects Airtable dropdown fields (Single Select, Multi Select) and extracts their choices\n * for automatic Google Sheets data validation setup\n */\n\nimport type { AirtableField, AirtableFieldType } from '../airtable/client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface DropdownFieldInfo {\n  /** Field ID from Airtable */\n  fieldId: string;\n  /** Field name from Airtable */\n  fieldName: string;\n  /** Field type (singleSelect or multipleSelects) */\n  fieldType: 'singleSelect' | 'multipleSelects';\n  /** Column index in Google Sheets (0-based) */\n  columnIndex: number;\n  /** Available dropdown choices */\n  choices: string[];\n  /** Choice metadata (name, color, id) */\n  choiceDetails: Array<{ id: string; name: string; color?: string }>;\n}\n\n// ============================================================================\n// Detection Functions\n// ============================================================================\n\n/**\n * Checks if an Airtable field is a dropdown type\n */\nexport function isDropdownField(fieldType: AirtableFieldType): boolean {\n  return fieldType === 'singleSelect' || fieldType === 'multipleSelects';\n}\n\n/**\n * Extracts dropdown choices from an Airtable field\n * Returns null if the field is not a dropdown type or has no choices defined\n */\nexport function extractDropdownChoices(field: AirtableField): string[] | null {\n  if (!isDropdownField(field.type)) {\n    return null;\n  }\n\n  if (!field.options?.choices || !Array.isArray(field.options.choices)) {\n    console.warn(\n      `Dropdown field \"${field.name}\" (${field.type}) has no choices defined - skipping validation`\n    );\n    return null;\n  }\n\n  return field.options.choices.map((choice) => choice.name);\n}\n\n/**\n * Extracts detailed choice information from an Airtable field\n * Includes color metadata which could be used for future enhancements\n */\nexport function extractDropdownChoiceDetails(\n  field: AirtableField\n): Array<{ id: string; name: string; color?: string }> | null {\n  if (!isDropdownField(field.type)) {\n    return null;\n  }\n\n  if (!field.options?.choices || !Array.isArray(field.options.choices)) {\n    return null;\n  }\n\n  return field.options.choices.map((choice) => ({\n    id: choice.id,\n    name: choice.name,\n    color: choice.color,\n  }));\n}\n\n/**\n * Detects all dropdown fields in a list of Airtable fields\n * Maps them to their column indices based on field mappings\n *\n * @param fields - Array of Airtable fields to analyze (should be in the order they appear in Sheets)\n * @param fieldMappings - Optional mapping of fieldId -> columnIndex\n *                        If not provided, uses array index as column index\n * @returns Array of dropdown field information\n */\nexport function detectDropdownFields(\n  fields: AirtableField[],\n  fieldMappings?: Record<string, number>\n): DropdownFieldInfo[] {\n  const dropdownFields: DropdownFieldInfo[] = [];\n\n  fields.forEach((field, index) => {\n    if (!isDropdownField(field.type)) {\n      return;\n    }\n\n    const choices = extractDropdownChoices(field);\n    const choiceDetails = extractDropdownChoiceDetails(field);\n\n    if (!choices || choices.length === 0) {\n      console.warn(\n        `[DropdownDetector] Skipping field \"${field.name}\" - no choices defined`\n      );\n      return;\n    }\n\n    // Determine column index\n    let columnIndex: number;\n    if (fieldMappings && field.id in fieldMappings) {\n      // Use explicit field mapping if available\n      columnIndex = fieldMappings[field.id];\n      console.log(\n        `[DropdownDetector] Field \"${field.name}\" mapped to column ${columnIndex} via fieldMappings`\n      );\n    } else {\n      // Fallback to array index if no explicit mapping\n      // This assumes fields array is already sorted in the correct Sheets column order\n      columnIndex = index;\n      console.log(\n        `[DropdownDetector] Field \"${field.name}\" using array index ${columnIndex} (no field mapping)`\n      );\n    }\n\n    dropdownFields.push({\n      fieldId: field.id,\n      fieldName: field.name,\n      fieldType: field.type as 'singleSelect' | 'multipleSelects',\n      columnIndex,\n      choices,\n      choiceDetails: choiceDetails || [],\n    });\n  });\n\n  return dropdownFields;\n}\n\n/**\n * Converts dropdown field information to Google Sheets validation format\n */\nexport function convertToSheetsValidation(dropdownField: DropdownFieldInfo): {\n  columnIndex: number;\n  choices: string[];\n  showDropdown: boolean;\n  strict: boolean;\n} {\n  return {\n    columnIndex: dropdownField.columnIndex,\n    choices: dropdownField.choices,\n    showDropdown: true,\n    // For multi-select, we'll be less strict since users need to enter comma-separated values\n    // Single select can be strict since it's just one value\n    strict: dropdownField.fieldType === 'singleSelect',\n  };\n}\n\n/**\n * Validates that a value matches the dropdown choices\n * Used for pre-validation before syncing to Sheets\n */\nexport function validateDropdownValue(\n  value: string | string[],\n  choices: string[],\n  fieldType: 'singleSelect' | 'multipleSelects'\n): { valid: boolean; error?: string } {\n  if (fieldType === 'singleSelect') {\n    const stringValue = String(value);\n    if (!choices.includes(stringValue)) {\n      return {\n        valid: false,\n        error: `Value \"${stringValue}\" is not a valid choice. Available: ${choices.join(', ')}`,\n      };\n    }\n    return { valid: true };\n  }\n\n  // Multiple selects\n  const values = Array.isArray(value) ? value : String(value).split(',').map((v) => v.trim());\n  const invalidValues = values.filter((v) => !choices.includes(v));\n\n  if (invalidValues.length > 0) {\n    return {\n      valid: false,\n      error: `Invalid choices: ${invalidValues.join(', ')}. Available: ${choices.join(', ')}`,\n    };\n  }\n\n  return { valid: true };\n}\n\n// ============================================================================\n// Logging Helpers\n// ============================================================================\n\n/**\n * Logs detected dropdown fields (useful for debugging)\n */\nexport function logDropdownFields(dropdownFields: DropdownFieldInfo[]): void {\n  if (dropdownFields.length === 0) {\n    console.log('[DropdownDetector] No dropdown fields detected');\n    return;\n  }\n\n  console.log(`[DropdownDetector] Detected ${dropdownFields.length} dropdown field(s):`);\n  dropdownFields.forEach((field) => {\n    console.log(\n      `  - \"${field.fieldName}\" (${field.fieldType}) at column ${field.columnIndex}: ` +\n        `${field.choices.length} choices [${field.choices.join(', ')}]`\n    );\n  });\n}\n","/**\n * Airtable â†’ Google Sheets One-Way Sync\n * Syncs data from Airtable to Google Sheets with comprehensive error handling\n */\n\nimport type { AirtableRecord, AirtableField } from '../airtable/client';\nimport { listRecords, getBaseSchema } from '../airtable/client';\nimport {\n  getSheetData,\n  updateSheetData,\n  appendRows,\n  clearSheetData,\n  getSheetIdByName,\n  hideColumn,\n  columnNumberToLetter,\n  ensureColumnsExist,\n  batchSetDropdownValidations,\n  type SheetData,\n} from '../google/client';\nimport { airtableRecordToSheetsRow } from './fieldMapper';\nimport { resolveAllLinkedRecords } from './linkedRecordResolver';\nimport {\n  detectDropdownFields,\n  convertToSheetsValidation,\n  logDropdownFields,\n} from './dropdownFieldDetector';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface AirtableToSheetsSyncOptions {\n  /** Airtable access token */\n  airtableAccessToken: string;\n  /** Google Sheets access token */\n  sheetsAccessToken: string;\n  /** Airtable base ID */\n  baseId: string;\n  /** Airtable table ID or name */\n  tableId: string;\n  /** Airtable view ID or name (optional, for exact row order) */\n  viewId?: string;\n  /** Google Sheets spreadsheet ID */\n  spreadsheetId: string;\n  /** Google Sheet ID (name or gid) */\n  sheetId: string | number;\n  /** Field mappings: { airtableFieldId: columnIndex } */\n  fieldMappings?: Record<string, number>;\n  /** Whether to include a header row (default: true) */\n  includeHeader?: boolean;\n  /** Whether to clear extra rows in Sheets not in Airtable (default: false) */\n  deleteExtraRows?: boolean;\n  /** Whether to resolve linked records to names (default: true) */\n  resolveLinkedRecords?: boolean;\n  /** Column index to store Airtable record IDs (for tracking, default: 0) */\n  idColumnIndex?: number;\n  /** Maximum retries for rate limit errors (default: 3) */\n  maxRetries?: number;\n  /** Batch size for Sheets updates (default: 100 rows) */\n  batchSize?: number;\n}\n\nexport interface SyncResult {\n  /** Number of rows added to Sheets */\n  added: number;\n  /** Number of rows updated in Sheets */\n  updated: number;\n  /** Number of rows deleted from Sheets */\n  deleted: number;\n  /** Total number of records processed */\n  total: number;\n  /** Errors encountered during sync */\n  errors: SyncError[];\n  /** Warnings (non-fatal issues) */\n  warnings: string[];\n  /** Execution time in milliseconds */\n  duration: number;\n  /** Timestamp when sync started */\n  startedAt: Date;\n  /** Timestamp when sync completed */\n  completedAt: Date;\n}\n\nexport interface SyncError {\n  /** Record ID or row number where error occurred */\n  recordId?: string;\n  /** Row index in Sheets */\n  rowIndex?: number;\n  /** Error message */\n  message: string;\n  /** Error type */\n  type: 'FETCH' | 'TRANSFORM' | 'WRITE' | 'VALIDATION' | 'RATE_LIMIT' | 'UNKNOWN';\n  /** Original error object */\n  originalError?: any;\n}\n\ninterface RowDiff {\n  /** Rows to add (new records) */\n  toAdd: any[][];\n  /** Rows to update (existing records that changed) */\n  toUpdate: Array<{ rowIndex: number; data: any[] }>;\n  /** Row indices to delete */\n  toDelete: number[];\n}\n\n// ============================================================================\n// Main Sync Function\n// ============================================================================\n\n/**\n * Syncs data from Airtable to Google Sheets (one-way)\n *\n * Process:\n * 1. Fetch all records from Airtable (with pagination)\n * 2. Fetch table schema to get field metadata\n * 3. Resolve linked records to human-readable names\n * 4. Transform Airtable records to Sheets rows\n * 5. Fetch existing Sheets data\n * 6. Calculate diff (add/update/delete)\n * 7. Apply changes to Sheets in batches\n * 8. Return sync summary\n */\nexport async function syncAirtableToSheets(\n  options: AirtableToSheetsSyncOptions\n): Promise<SyncResult> {\n  const startTime = Date.now();\n  const result: SyncResult = {\n    added: 0,\n    updated: 0,\n    deleted: 0,\n    total: 0,\n    errors: [],\n    warnings: [],\n    duration: 0,\n    startedAt: new Date(),\n    completedAt: new Date(),\n  };\n\n  // Set defaults\n  const {\n    airtableAccessToken,\n    sheetsAccessToken,\n    baseId,\n    tableId,\n    viewId, // Optional view ID for exact row order\n    spreadsheetId,\n    sheetId,\n    fieldMappings,\n    includeHeader = true,\n    resolveLinkedRecords: shouldResolveLinkedRecords = true,\n    idColumnIndex = 0,\n    maxRetries = 3,\n    batchSize = 100,\n  } = options;\n\n  // CRITICAL: Use fixed column AA (index 26) for record IDs to avoid shifting user's columns\n  const FIXED_ID_COLUMN_INDEX = 26; // Column AA\n  const actualIdColumnIndex = idColumnIndex === 0 ? FIXED_ID_COLUMN_INDEX : idColumnIndex;\n\n  try {\n    // ========================================================================\n    // STEP 1: Fetch Table Schema FIRST (needed for primary field name)\n    // ========================================================================\n    console.log(`[AirtableToSheets] Fetching table schema...`);\n\n    let tableFields: AirtableField[] = [];\n    let primaryFieldName: string | undefined;\n    try {\n      const schema = await retryWithBackoff(\n        () => getBaseSchema(airtableAccessToken, baseId),\n        maxRetries,\n        'fetch table schema'\n      );\n\n      const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n      if (!table) {\n        throw new Error(`Table ${tableId} not found in base schema`);\n      }\n\n      tableFields = table.fields;\n\n      // Get primary field name for sorting (ensures consistent order)\n      const primaryField = table.fields.find((f) => f.id === table.primaryFieldId);\n      if (primaryField) {\n        primaryFieldName = primaryField.name;\n        console.log(`[AirtableToSheets] Primary field for ordering: \"${primaryFieldName}\"`);\n      }\n\n      // Apply field mappings if provided (filter to only mapped fields)\n      if (fieldMappings && Object.keys(fieldMappings).length > 0) {\n        const mappedFieldIds = Object.keys(fieldMappings);\n        tableFields = tableFields.filter((f) => mappedFieldIds.includes(f.id));\n        // Sort by column index\n        tableFields.sort((a, b) => (fieldMappings[a.id] || 0) - (fieldMappings[b.id] || 0));\n      }\n\n      console.log(`[AirtableToSheets] Found ${tableFields.length} fields to sync`);\n    } catch (error) {\n      result.errors.push({\n        type: 'FETCH',\n        message: `Failed to fetch table schema: ${error instanceof Error ? error.message : String(error)}`,\n        originalError: error,\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // ========================================================================\n    // STEP 2: Fetch Airtable Records (SORTED BY PRIMARY FIELD for consistent order)\n    // ========================================================================\n    console.log(`[AirtableToSheets] Fetching records from Airtable table ${tableId}...`);\n\n    let airtableRecords: AirtableRecord[] = [];\n    try {\n      // CRITICAL: Use view or sort by primary field to ensure consistent ordering\n      // Priority: 1) View (exact UI order), 2) Primary field sort (alphabetical), 3) Default\n      const fetchOptions: any = {};\n\n      if (viewId) {\n        // Use view for EXACT order matching Airtable UI\n        fetchOptions.view = viewId;\n        console.log(`[AirtableToSheets] Using Airtable view \"${viewId}\" for exact row order`);\n      } else if (primaryFieldName) {\n        // Fallback to sorting by primary field for consistent alphabetical order\n        fetchOptions.sort = [{ field: primaryFieldName, direction: 'asc' as const }];\n        console.log(`[AirtableToSheets] Sorting by primary field \"${primaryFieldName}\" for consistent order`);\n      } else {\n        console.warn(`[AirtableToSheets] No view or primary field - order may be unpredictable`);\n      }\n\n      airtableRecords = await retryWithBackoff(\n        () => listRecords(airtableAccessToken, baseId, tableId, fetchOptions),\n        maxRetries,\n        'fetch Airtable records'\n      );\n      console.log(`[AirtableToSheets] Fetched ${airtableRecords.length} records from Airtable`);\n    } catch (error) {\n      result.errors.push({\n        type: 'FETCH',\n        message: `Failed to fetch Airtable records: ${error instanceof Error ? error.message : String(error)}`,\n        originalError: error,\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    result.total = airtableRecords.length;\n\n    // ========================================================================\n    // STEP 3: Resolve Linked Records (Optional)\n    // ========================================================================\n    if (shouldResolveLinkedRecords && airtableRecords.length > 0) {\n      console.log(`[AirtableToSheets] Resolving linked records...`);\n\n      try {\n        const resolved = await resolveAllLinkedRecords(\n          airtableAccessToken,\n          baseId,\n          tableId,\n          airtableRecords,\n          { strictMode: false }\n        );\n\n        airtableRecords = resolved.records;\n\n        if (resolved.warnings.length > 0) {\n          result.warnings.push(...resolved.warnings);\n        }\n\n        console.log(`[AirtableToSheets] Linked records resolved`);\n      } catch (error) {\n        // Non-fatal error, continue without resolved links\n        result.warnings.push(\n          `Failed to resolve linked records: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    // ========================================================================\n    // STEP 4: Transform Airtable Records to Sheets Rows\n    // ========================================================================\n    console.log(`[AirtableToSheets] Transforming records to Sheets rows...`);\n\n    const transformedRows: any[][] = [];\n    const transformedRowsWithoutIds: any[][] = []; // Rows without record IDs for writing\n    const recordIdMapping: Map<number, string> = new Map(); // rowIndex -> recordId\n\n    for (let i = 0; i < airtableRecords.length; i++) {\n      const record = airtableRecords[i];\n\n      try {\n        const { row, errors, warnings } = await airtableRecordToSheetsRow(\n          record,\n          tableFields,\n          {\n            accessToken: airtableAccessToken,\n            baseId,\n            tableId,\n          }\n        );\n\n        // Create row WITH record ID at column AA for diff calculation\n        const rowWithId = [...row];\n        while (rowWithId.length <= actualIdColumnIndex) {\n          rowWithId.push('');\n        }\n        rowWithId[actualIdColumnIndex] = record.id;\n        transformedRows.push(rowWithId);\n\n        // Keep row WITHOUT record ID for actual writing to sheets\n        transformedRowsWithoutIds.push(row);\n        recordIdMapping.set(i, record.id);\n\n        if (errors.length > 0) {\n          result.errors.push({\n            recordId: record.id,\n            type: 'TRANSFORM',\n            message: `Transformation errors: ${errors.join('; ')}`,\n          });\n        }\n\n        if (warnings.length > 0) {\n          result.warnings.push(`Record ${record.id}: ${warnings.join('; ')}`);\n        }\n      } catch (error) {\n        result.errors.push({\n          recordId: record.id,\n          type: 'TRANSFORM',\n          message: `Failed to transform record: ${error instanceof Error ? error.message : String(error)}`,\n          originalError: error,\n        });\n      }\n    }\n\n    console.log(`[AirtableToSheets] Transformed ${transformedRows.length} rows`);\n\n    // ========================================================================\n    // STEP 5: Fetch Existing Sheets Data\n    // ========================================================================\n    console.log(`[AirtableToSheets] Fetching existing Sheets data...`);\n\n    let existingData: SheetData | null = null;\n    let headerRowOffset = includeHeader ? 1 : 0;\n\n    try {\n      existingData = await retryWithBackoff(\n        () => getSheetData(sheetsAccessToken, spreadsheetId, sheetId),\n        maxRetries,\n        'fetch Sheets data'\n      );\n\n      console.log(\n        `[AirtableToSheets] Found ${existingData.values?.length || 0} existing rows in Sheets`\n      );\n    } catch (error) {\n      // If sheet is empty or doesn't exist, treat as empty\n      console.log(`[AirtableToSheets] Sheet appears to be empty or new`);\n      existingData = { range: '', majorDimension: 'ROWS', values: [] };\n    }\n\n    // ========================================================================\n    // STEP 6: Prepare Data for Writing (PRESERVE AIRTABLE ORDER)\n    // ========================================================================\n    console.log(`[AirtableToSheets] Preparing ${transformedRowsWithoutIds.length} rows to write...`);\n\n    // CRITICAL FIX: To preserve Airtable's exact ordering in Sheets, we MUST write\n    // all data in Airtable's order. The previous approach of \"update existing + append new\"\n    // loses ordering because:\n    // 1. Existing rows stay in their (possibly wrong) Sheet positions\n    // 2. New rows get appended at the end in unpredictable order\n    //\n    // The solution: Write ALL rows in Airtable order, starting from row 2 (after header).\n    // This ensures Sheets always mirrors Airtable's exact ordering.\n\n    const startRow = includeHeader ? 2 : 1; // Row 2 if header exists, Row 1 otherwise\n\n    // Build a Set of existing record IDs in Sheets (for tracking adds vs updates)\n    const existingRecordIds = new Set<string>();\n    if (existingData.values && existingData.values.length > headerRowOffset) {\n      const dataRows = existingData.values.slice(headerRowOffset);\n      for (const row of dataRows) {\n        const recordId = row[actualIdColumnIndex] ? String(row[actualIdColumnIndex]).trim() : undefined;\n        if (recordId) {\n          existingRecordIds.add(recordId);\n        }\n      }\n    }\n\n    // Prepare all rows in AIRTABLE ORDER - this is the key to preserving order\n    const allRowsInOrder: Array<{ data: any[]; recordId: string; isNew: boolean }> = [];\n    for (let i = 0; i < airtableRecords.length; i++) {\n      const record = airtableRecords[i];\n      const rowData = transformedRowsWithoutIds[i];\n      const isNew = !existingRecordIds.has(record.id);\n      allRowsInOrder.push({ data: rowData, recordId: record.id, isNew });\n    }\n\n    const newCount = allRowsInOrder.filter(r => r.isNew).length;\n    const updateCount = allRowsInOrder.filter(r => !r.isNew).length;\n    console.log(`[AirtableToSheets] Will write ${allRowsInOrder.length} rows in Airtable order (${newCount} new, ${updateCount} existing)`);\n\n    // ========================================================================\n    // STEP 7: Write ALL Data to Sheets in Airtable Order\n    // ========================================================================\n\n    // 7.1: Add header row if needed\n    if (includeHeader && (!existingData.values || existingData.values.length === 0)) {\n      console.log(`[AirtableToSheets] Adding header row...`);\n\n      const headerRow = tableFields.map((f) => f.name);\n\n      try {\n        // Write the main header row (field names) to A1\n        await retryWithBackoff(\n          () =>\n            updateSheetData(sheetsAccessToken, spreadsheetId, sheetId, 'A1', [headerRow]),\n          maxRetries,\n          'add header row'\n        );\n\n        // Write \"Record ID\" header to column AA separately\n        if (actualIdColumnIndex === FIXED_ID_COLUMN_INDEX) {\n          const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n          const headerRange = `${columnLetter}1`;\n          await updateSheetData(sheetsAccessToken, spreadsheetId, sheetId, headerRange, [['Record ID']]);\n          console.log(`[AirtableToSheets] Added \"Record ID\" header to ${headerRange}`);\n        }\n\n        headerRowOffset = 1;\n      } catch (error) {\n        result.errors.push({\n          type: 'WRITE',\n          message: `Failed to add header row: ${error instanceof Error ? error.message : String(error)}`,\n          originalError: error,\n        });\n      }\n    }\n\n    // 7.2: Write all rows in Airtable order (batched for efficiency)\n    if (allRowsInOrder.length > 0) {\n      console.log(`[AirtableToSheets] Writing ${allRowsInOrder.length} rows in Airtable order...`);\n\n      // Write in batches for efficiency\n      const writeBatches = chunkArray(allRowsInOrder, batchSize);\n      let writtenSoFar = 0;\n\n      for (let i = 0; i < writeBatches.length; i++) {\n        const batch = writeBatches[i];\n        const batchData = batch.map(r => r.data);\n        const batchStartRow = startRow + writtenSoFar;\n\n        try {\n          // Write the batch starting at the correct row\n          const range = `A${batchStartRow}`;\n          await retryWithBackoff(\n            () => updateSheetData(sheetsAccessToken, spreadsheetId, sheetId, range, batchData),\n            maxRetries,\n            `write rows batch ${i + 1}/${writeBatches.length}`\n          );\n\n          // Track results and record ID mappings\n          for (let j = 0; j < batch.length; j++) {\n            const rowInfo = batch[j];\n            if (rowInfo.isNew) {\n              result.added++;\n            } else {\n              result.updated++;\n            }\n            // Map row index to record ID (0-based index relative to data start)\n            recordIdMapping.set(writtenSoFar + j, rowInfo.recordId);\n          }\n\n          writtenSoFar += batch.length;\n          console.log(\n            `[AirtableToSheets] Wrote batch ${i + 1}/${writeBatches.length} (${batch.length} rows)`\n          );\n        } catch (error) {\n          result.errors.push({\n            type: 'WRITE',\n            message: `Failed to write rows batch ${i + 1}: ${error instanceof Error ? error.message : String(error)}`,\n            originalError: error,\n          });\n        }\n      }\n\n      console.log(`[AirtableToSheets] âœ“ Wrote ${result.added} new + ${result.updated} updated rows in Airtable order`);\n    }\n\n    // ========================================================================\n    // STEP 8: Setup Dropdown Data Validation for Select Fields\n    // ========================================================================\n\n    // Detect dropdown fields (Single Select, Multi Select) and set up Google Sheets data validation\n    console.log(`[AirtableToSheets] Detecting dropdown fields for data validation...`);\n    console.log(`[AirtableToSheets] Total fields to check: ${tableFields.length}`);\n    console.log(`[AirtableToSheets] Field types: ${tableFields.map(f => `${f.name}:${f.type}`).join(', ')}`);\n\n    const dropdownFields = detectDropdownFields(tableFields, fieldMappings);\n\n    if (dropdownFields.length > 0) {\n      logDropdownFields(dropdownFields);\n\n      try {\n        // Convert to Sheets validation format\n        const validations = dropdownFields.map(convertToSheetsValidation);\n\n        console.log(`[AirtableToSheets] Validation configurations:`, JSON.stringify(validations, null, 2));\n\n        // Apply data validation to all dropdown columns\n        console.log(`[AirtableToSheets] Applying data validation to ${validations.length} dropdown column(s)...`);\n        await batchSetDropdownValidations(\n          sheetsAccessToken,\n          spreadsheetId,\n          sheetId,\n          validations\n        );\n        console.log(`[AirtableToSheets] âœ“ Data validation applied successfully`);\n      } catch (error) {\n        // Non-fatal error - log warning but continue\n        const errorMessage = `Failed to set up dropdown validation: ${error instanceof Error ? error.message : String(error)}`;\n        result.warnings.push(errorMessage);\n        console.error('[AirtableToSheets] Failed to set up dropdown validation:', error);\n        console.error('[AirtableToSheets] Error details:', error instanceof Error ? error.stack : error);\n      }\n    } else {\n      console.log(`[AirtableToSheets] No dropdown fields detected - skipping data validation`);\n      console.log(`[AirtableToSheets] This might mean: 1) No singleSelect/multipleSelects fields, 2) No choices defined, or 3) All dropdown fields were filtered out`);\n    }\n\n    // ========================================================================\n    // STEP 9: Write Record IDs to Column AA, Then Hide It\n    // ========================================================================\n\n    // Write record IDs to column AA and hide it to keep sheets clean for users\n    if (actualIdColumnIndex === FIXED_ID_COLUMN_INDEX && (result.added > 0 || result.updated > 0)) {\n      const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n      try {\n        // STEP 1: Ensure column AA exists\n        const requiredColumnCount = actualIdColumnIndex + 1; // Need at least 27 columns for column AA (index 26)\n        console.log(\n          `[AirtableToSheets] Ensuring column ${columnLetter} exists (need ${requiredColumnCount} columns)...`\n        );\n        await ensureColumnsExist(sheetsAccessToken, spreadsheetId, sheetId, requiredColumnCount);\n\n        // STEP 2: Write all record IDs to column AA\n        console.log(`[AirtableToSheets] Writing ${recordIdMapping.size} record IDs to column ${columnLetter}...`);\n\n        for (const [rowIndex, recordId] of recordIdMapping) {\n          const rowNumber = rowIndex + headerRowOffset + 1; // +1 for 1-based indexing\n          const range = `${columnLetter}${rowNumber}`;\n\n          try {\n            await updateSheetData(\n              sheetsAccessToken,\n              spreadsheetId,\n              sheetId,\n              range,\n              [[recordId]]\n            );\n          } catch (error) {\n            result.warnings.push(\n              `Failed to write record ID to ${range}: ${error instanceof Error ? error.message : String(error)}`\n            );\n          }\n        }\n\n        console.log(`[AirtableToSheets] âœ“ Wrote ${recordIdMapping.size} record IDs to column ${columnLetter}`);\n\n        // STEP 3: Hide column AA\n        console.log(`[AirtableToSheets] Hiding ID column ${columnLetter}...`);\n        await hideColumn(sheetsAccessToken, spreadsheetId, sheetId, actualIdColumnIndex);\n        console.log(\n          `[AirtableToSheets] âœ“ Hidden column ${columnLetter} (users won't see record IDs)`\n        );\n      } catch (error) {\n        // Non-fatal - log warning\n        result.warnings.push(\n          `Could not write/hide ID column: ${error instanceof Error ? error.message : String(error)}`\n        );\n        console.warn('[AirtableToSheets] Failed to write/hide ID column:', error);\n      }\n    }\n\n    // ========================================================================\n    // STEP 10: Finalize\n    // ========================================================================\n\n    console.log(\n      `[AirtableToSheets] Sync complete: ${result.added} added, ${result.updated} updated, ${result.deleted} deleted`\n    );\n\n    return finalizeSyncResult(result, startTime);\n  } catch (error) {\n    result.errors.push({\n      type: 'UNKNOWN',\n      message: `Unexpected error during sync: ${error instanceof Error ? error.message : String(error)}`,\n      originalError: error,\n    });\n\n    return finalizeSyncResult(result, startTime);\n  }\n}\n\n// ============================================================================\n// Diff Calculation\n// ============================================================================\n\n/**\n * Calculates the difference between new data and existing Sheets data\n */\nfunction calculateRowDiff(\n  newRows: any[][],\n  existingRows: any[][],\n  idColumnIndex: number,\n  headerRowOffset: number,\n  deleteExtra: boolean\n): RowDiff {\n  const diff: RowDiff = {\n    toAdd: [],\n    toUpdate: [],\n    toDelete: [],\n  };\n\n  // Skip header row if present\n  const dataRows = existingRows.slice(headerRowOffset);\n\n  // Build a map of existing record IDs to row indices\n  const existingRecordMap = new Map<string, number>();\n  dataRows.forEach((row, index) => {\n    const recordId = row[idColumnIndex];\n    if (recordId && recordId !== '') {\n      existingRecordMap.set(String(recordId), index);\n    }\n  });\n\n  // Process new rows\n  const processedIndices = new Set<number>();\n\n  for (const newRow of newRows) {\n    const recordId = String(newRow[idColumnIndex]);\n\n    if (existingRecordMap.has(recordId)) {\n      // Record exists - check if it changed\n      const existingIndex = existingRecordMap.get(recordId)!;\n      const existingRow = dataRows[existingIndex];\n\n      processedIndices.add(existingIndex);\n\n      if (!areRowsEqual(newRow, existingRow)) {\n        diff.toUpdate.push({\n          rowIndex: existingIndex,\n          data: newRow,\n        });\n      }\n    } else {\n      // New record - add it\n      diff.toAdd.push(newRow);\n    }\n  }\n\n  // Find rows to delete (exist in Sheets but not in new data)\n  if (deleteExtra) {\n    dataRows.forEach((row, index) => {\n      if (!processedIndices.has(index)) {\n        diff.toDelete.push(index);\n      }\n    });\n  }\n\n  return diff;\n}\n\n/**\n * Compares two rows for equality\n */\nfunction areRowsEqual(row1: any[], row2: any[]): boolean {\n  if (row1.length !== row2.length) return false;\n\n  for (let i = 0; i < row1.length; i++) {\n    const val1 = normalizeValue(row1[i]);\n    const val2 = normalizeValue(row2[i]);\n\n    if (val1 !== val2) return false;\n  }\n\n  return true;\n}\n\n/**\n * Normalizes a cell value for comparison\n */\nfunction normalizeValue(value: any): string {\n  if (value === null || value === undefined || value === '') {\n    return '';\n  }\n\n  if (typeof value === 'number') {\n    // Handle floating point precision\n    return String(Math.round(value * 1000000) / 1000000);\n  }\n\n  return String(value).trim();\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Retries a function with exponential backoff\n */\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number,\n  operation: string\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Don't retry on last attempt\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      // Check if it's a rate limit error\n      const isRateLimit =\n        lastError.message.toLowerCase().includes('rate limit') ||\n        lastError.message.toLowerCase().includes('quota') ||\n        lastError.message.includes('429');\n\n      if (!isRateLimit && attempt > 0) {\n        // Only retry non-rate-limit errors once\n        break;\n      }\n\n      // Exponential backoff with jitter\n      const delay = Math.min(1000 * Math.pow(2, attempt), 30000) + Math.random() * 1000;\n      console.warn(\n        `[AirtableToSheets] ${operation} failed (attempt ${attempt + 1}/${maxRetries + 1}), ` +\n          `retrying in ${Math.round(delay)}ms...`,\n        lastError.message\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Chunks an array into smaller arrays of specified size\n */\nfunction chunkArray<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Groups consecutive numbers into ranges\n * Example: [1, 2, 3, 5, 7, 8, 9] â†’ [{start: 1, end: 3}, {start: 5, end: 5}, {start: 7, end: 9}]\n */\nfunction groupConsecutiveNumbers(numbers: number[]): Array<{ start: number; end: number }> {\n  if (numbers.length === 0) return [];\n\n  const sorted = [...numbers].sort((a, b) => a - b);\n  const ranges: Array<{ start: number; end: number }> = [];\n\n  let rangeStart = sorted[0];\n  let rangeEnd = sorted[0];\n\n  for (let i = 1; i < sorted.length; i++) {\n    if (sorted[i] === rangeEnd + 1) {\n      // Consecutive number, extend range\n      rangeEnd = sorted[i];\n    } else {\n      // Gap found, save current range and start new one\n      ranges.push({ start: rangeStart, end: rangeEnd });\n      rangeStart = sorted[i];\n      rangeEnd = sorted[i];\n    }\n  }\n\n  // Add final range\n  ranges.push({ start: rangeStart, end: rangeEnd });\n\n  return ranges;\n}\n\n/**\n * Finalizes the sync result with duration and completion time\n */\nfunction finalizeSyncResult(result: SyncResult, startTime: number): SyncResult {\n  result.duration = Date.now() - startTime;\n  result.completedAt = new Date();\n  return result;\n}\n\n// ============================================================================\n// Helper: Delete Rows (imported from Google client)\n// ============================================================================\n\n/**\n * Local import of deleteRows to avoid circular dependency\n */\nasync function deleteRows(\n  accessToken: string,\n  spreadsheetId: string,\n  sheetId: number,\n  startRow: number,\n  count: number\n): Promise<void> {\n  const SHEETS_API_BASE = 'https://sheets.googleapis.com/v4';\n\n  const response = await fetch(`${SHEETS_API_BASE}/spreadsheets/${spreadsheetId}:batchUpdate`, {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${accessToken}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      requests: [\n        {\n          deleteDimension: {\n            range: {\n              sheetId: sheetId,\n              dimension: 'ROWS',\n              startIndex: startRow,\n              endIndex: startRow + count,\n            },\n          },\n        },\n      ],\n    }),\n  });\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({}));\n    throw new Error(\n      `Failed to delete rows: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`\n    );\n  }\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport { chunkArray, retryWithBackoff, areRowsEqual, normalizeValue };\n","/**\n * Google Sheets â†’ Airtable One-Way Sync\n * Syncs data from Google Sheets to Airtable with comprehensive error handling\n */\n\nimport type {\n  AirtableRecord,\n  AirtableField,\n  CreateRecordData,\n  UpdateRecordData,\n} from '../airtable/client';\nimport {\n  listRecords,\n  getBaseSchema,\n  createRecords,\n  updateRecords,\n  deleteRecords,\n  batchOperations,\n} from '../airtable/client';\nimport { getSheetData, updateSheetData, hideColumn, columnNumberToLetter, ensureColumnsExist } from '../google/client';\nimport { sheetsRowToAirtableFields, sheetsRowToAirtableFieldsWithMapping, isReadOnlyField } from './fieldMapper';\nimport { resolveNamesToRecordIds, preloadTableCache } from './linkedRecordResolver';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface SheetsToAirtableSyncOptions {\n  /** Google Sheets access token */\n  sheetsAccessToken: string;\n  /** Airtable access token */\n  airtableAccessToken: string;\n  /** Google Sheets spreadsheet ID */\n  spreadsheetId: string;\n  /** Google Sheet ID (name or gid) */\n  sheetId: string | number;\n  /** Airtable base ID */\n  baseId: string;\n  /** Airtable table ID or name */\n  tableId: string;\n  /** Field mappings: { airtableFieldId: columnIndex } */\n  fieldMappings?: Record<string, number>;\n  /** Column index containing Airtable record IDs (default: 0) */\n  idColumnIndex?: number;\n  /** Whether to skip header row (default: true) */\n  skipHeaderRow?: boolean;\n  /** Whether to delete records in Airtable not in Sheets (default: false) */\n  deleteExtraRecords?: boolean;\n  /** Whether to resolve linked record names to IDs (default: true) */\n  resolveLinkedRecords?: boolean;\n  /** Whether to create missing linked records (default: false) */\n  createMissingLinkedRecords?: boolean;\n  /** Maximum retries for rate limit errors (default: 3) */\n  maxRetries?: number;\n  /** Batch size for Airtable operations (max 10) */\n  batchSize?: number;\n  /** Validation mode: 'strict' throws on invalid data, 'lenient' skips invalid rows */\n  validationMode?: 'strict' | 'lenient';\n}\n\nexport interface SyncResult {\n  /** Number of records added to Airtable */\n  added: number;\n  /** Number of records updated in Airtable */\n  updated: number;\n  /** Number of records deleted from Airtable */\n  deleted: number;\n  /** Total number of rows processed */\n  total: number;\n  /** Errors encountered during sync */\n  errors: SyncError[];\n  /** Warnings (non-fatal issues) */\n  warnings: string[];\n  /** Execution time in milliseconds */\n  duration: number;\n  /** Timestamp when sync started */\n  startedAt: Date;\n  /** Timestamp when sync completed */\n  completedAt: Date;\n}\n\nexport interface SyncError {\n  /** Row number in Sheets where error occurred */\n  rowNumber?: number;\n  /** Record ID if applicable */\n  recordId?: string;\n  /** Error message */\n  message: string;\n  /** Error type */\n  type:\n    | 'FETCH'\n    | 'TRANSFORM'\n    | 'WRITE'\n    | 'VALIDATION'\n    | 'RATE_LIMIT'\n    | 'LINKED_RECORD'\n    | 'UNKNOWN';\n  /** Original error object */\n  originalError?: any;\n}\n\ninterface RecordDiff {\n  /** Records to create in Airtable */\n  toCreate: CreateRecordData[];\n  /** Records to update in Airtable */\n  toUpdate: UpdateRecordData[];\n  /** Record IDs to delete from Airtable */\n  toDelete: string[];\n  /** Mapping of row index to record ID for tracking */\n  rowToRecordMap: Map<number, string>;\n}\n\ninterface TransformedRow {\n  /** Original row index in Sheets */\n  rowIndex: number;\n  /** Airtable record ID (if exists) */\n  recordId?: string;\n  /** Transformed Airtable fields */\n  fields: Record<string, any>;\n  /** Transformation errors */\n  errors: string[];\n  /** Transformation warnings */\n  warnings: string[];\n  /** Whether this row is valid for syncing */\n  isValid: boolean;\n}\n\n// ============================================================================\n// Main Sync Function\n// ============================================================================\n\n/**\n * Syncs data from Google Sheets to Airtable (one-way)\n *\n * Process:\n * 1. Fetch all rows from Google Sheets\n * 2. Fetch table schema from Airtable\n * 3. Preload linked record caches (if needed)\n * 4. Transform Sheets rows to Airtable records\n * 5. Fetch existing Airtable records\n * 6. Calculate diff (create/update/delete)\n * 7. Apply changes to Airtable in batches (max 10 per batch)\n * 8. Return sync summary\n */\nexport async function syncSheetsToAirtable(\n  options: SheetsToAirtableSyncOptions\n): Promise<SyncResult> {\n  const startTime = Date.now();\n  const result: SyncResult = {\n    added: 0,\n    updated: 0,\n    deleted: 0,\n    total: 0,\n    errors: [],\n    warnings: [],\n    duration: 0,\n    startedAt: new Date(),\n    completedAt: new Date(),\n  };\n\n  // Set defaults\n  const {\n    sheetsAccessToken,\n    airtableAccessToken,\n    spreadsheetId,\n    sheetId,\n    baseId,\n    tableId,\n    fieldMappings,\n    idColumnIndex = 0,\n    skipHeaderRow = true,\n    deleteExtraRecords = false,\n    resolveLinkedRecords: shouldResolveLinkedRecords = true,\n    createMissingLinkedRecords = false,\n    maxRetries = 3,\n    batchSize = 10,\n    validationMode = 'lenient',\n  } = options;\n\n  // Validate batch size\n  const effectiveBatchSize = Math.min(Math.max(1, batchSize), 10);\n\n  try {\n    // ========================================================================\n    // STEP 1: Fetch Sheets Data\n    // ========================================================================\n    console.log(`[SheetsToAirtable] Fetching data from Google Sheets...`);\n\n    let sheetsData: any[][] = [];\n    let sheetData: any;\n    let actualIdColumnIndex = idColumnIndex;\n\n    try {\n      // CRITICAL: ALWAYS use a fixed far-right column for IDs to avoid shifting user's visible columns\n      // We use column AA (index 26) by default - far enough that it won't interfere with typical data\n      // This column will be hidden, so users won't see it, and it won't affect their A-Z column layout\n      // This applies to EVERY sync, regardless of whether data exists or not\n      if (idColumnIndex === 0) {\n        const FIXED_ID_COLUMN_INDEX = 26; // Column AA (A=0, B=1, ..., Z=25, AA=26)\n        actualIdColumnIndex = FIXED_ID_COLUMN_INDEX;\n\n        const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n\n        console.log(\n          `[SheetsToAirtable] Using fixed column ${columnLetter} (index ${actualIdColumnIndex}) for record IDs (will be hidden)`\n        );\n      }\n\n      // CRITICAL FIX: Fetch data up to column AA explicitly to ensure ID column is included\n      // Without this, Google Sheets API might not return trailing empty columns\n      const fetchRange = `A:${columnNumberToLetter(actualIdColumnIndex + 1)}`;\n      console.log(`[SheetsToAirtable] Fetching range: ${fetchRange} (includes ID column)`);\n\n      sheetData = await retryWithBackoff(\n        () => getSheetData(sheetsAccessToken, spreadsheetId, sheetId, fetchRange),\n        maxRetries,\n        'fetch Sheets data'\n      );\n\n      sheetsData = sheetData.values || [];\n\n      // Skip header row if configured\n      if (skipHeaderRow && sheetsData.length > 0) {\n        sheetsData = sheetsData.slice(1);\n      }\n\n      console.log(`[SheetsToAirtable] Fetched ${sheetsData.length} rows from Sheets`);\n    } catch (error) {\n      result.errors.push({\n        type: 'FETCH',\n        message: `Failed to fetch Sheets data: ${error instanceof Error ? error.message : String(error)}`,\n        originalError: error,\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // Handle empty sheet\n    if (sheetsData.length === 0) {\n      console.log(`[SheetsToAirtable] Sheet is empty, no data to sync`);\n      result.warnings.push('Sheet is empty, no data to sync');\n      return finalizeSyncResult(result, startTime);\n    }\n\n    result.total = sheetsData.length;\n\n    // ========================================================================\n    // STEP 2: Fetch Airtable Table Schema\n    // ========================================================================\n    console.log(`[SheetsToAirtable] Fetching Airtable table schema...`);\n\n    let tableFields: AirtableField[] = [];\n    let primaryFieldId: string = '';\n    let primaryFieldName: string | undefined;\n\n    try {\n      const schema = await retryWithBackoff(\n        () => getBaseSchema(airtableAccessToken, baseId),\n        maxRetries,\n        'fetch table schema'\n      );\n\n      const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n      if (!table) {\n        throw new Error(`Table ${tableId} not found in base schema`);\n      }\n\n      tableFields = table.fields;\n      primaryFieldId = table.primaryFieldId;\n\n      // Get primary field name for smart matching\n      const primaryField = tableFields.find((f) => f.id === primaryFieldId);\n      if (primaryField) {\n        primaryFieldName = primaryField.name;\n        console.log(`[SheetsToAirtable] Primary field for matching: \"${primaryFieldName}\"`);\n      }\n\n      // Filter out read-only fields\n      const writableFields = tableFields.filter((f) => !isReadOnlyField(f.type));\n\n      // Apply field mappings if provided\n      if (fieldMappings && Object.keys(fieldMappings).length > 0) {\n        const mappedFieldIds = Object.keys(fieldMappings);\n        tableFields = writableFields.filter((f) => mappedFieldIds.includes(f.id));\n        // Sort by column index\n        tableFields.sort((a, b) => (fieldMappings[a.id] || 0) - (fieldMappings[b.id] || 0));\n      } else {\n        tableFields = writableFields;\n      }\n\n      console.log(`[SheetsToAirtable] Found ${tableFields.length} writable fields`);\n    } catch (error) {\n      result.errors.push({\n        type: 'FETCH',\n        message: `Failed to fetch table schema: ${error instanceof Error ? error.message : String(error)}`,\n        originalError: error,\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // ========================================================================\n    // STEP 3: Preload Linked Record Caches (Optional)\n    // ========================================================================\n    if (shouldResolveLinkedRecords) {\n      console.log(`[SheetsToAirtable] Preloading linked record caches...`);\n\n      const linkedFields = tableFields.filter((f) => f.type === 'multipleRecordLinks');\n\n      for (const field of linkedFields) {\n        const linkedTableId = field.options?.linkedTableId;\n        if (!linkedTableId) continue;\n\n        try {\n          const { recordCount, duration } = await preloadTableCache(\n            airtableAccessToken,\n            baseId,\n            linkedTableId\n          );\n          console.log(\n            `[SheetsToAirtable] Preloaded ${recordCount} records from linked table ${linkedTableId} in ${duration}ms`\n          );\n        } catch (error) {\n          result.warnings.push(\n            `Failed to preload cache for linked table ${linkedTableId}: ${error instanceof Error ? error.message : String(error)}`\n          );\n        }\n      }\n    }\n\n    // ========================================================================\n    // STEP 4: Transform Sheets Rows to Airtable Records\n    // ========================================================================\n    console.log(`[SheetsToAirtable] Transforming Sheets rows to Airtable records...`);\n\n    const transformedRows: TransformedRow[] = [];\n\n    for (let i = 0; i < sheetsData.length; i++) {\n      const row = sheetsData[i];\n      const rowNumber = i + (skipHeaderRow ? 2 : 1); // Account for header and 1-based indexing\n\n      // Extract record ID from ID column\n      const recordId = row[actualIdColumnIndex] ? String(row[actualIdColumnIndex]).trim() : undefined;\n\n      console.log(`[SheetsToAirtable] Row ${i}: Column ${actualIdColumnIndex} value = \"${row[actualIdColumnIndex]}\" | Parsed ID = \"${recordId}\" | Row length = ${row.length}`);\n\n      // Skip completely empty rows\n      if (isRowEmpty(row)) {\n        result.warnings.push(`Row ${rowNumber} is empty, skipping`);\n        continue;\n      }\n\n      try {\n        // Transform to Airtable fields using field mappings\n        // If we have field mappings, extract values from the correct columns\n        // Otherwise, use positional mapping (after removing ID column)\n        const transformed = fieldMappings && Object.keys(fieldMappings).length > 0\n          ? await sheetsRowToAirtableFieldsWithMapping(row, tableFields, fieldMappings, actualIdColumnIndex, {\n              accessToken: airtableAccessToken,\n              baseId,\n              tableId,\n            })\n          : await sheetsRowToAirtableFields(\n              (() => {\n                const dataRow = [...row];\n                dataRow.splice(actualIdColumnIndex, 1);\n                return dataRow;\n              })(),\n              tableFields,\n              {\n                accessToken: airtableAccessToken,\n                baseId,\n                tableId,\n              }\n            );\n\n        // Handle linked record resolution\n        if (shouldResolveLinkedRecords) {\n          for (const field of tableFields) {\n            if (field.type !== 'multipleRecordLinks') continue;\n\n            const linkedTableId = field.options?.linkedTableId;\n            if (!linkedTableId || !transformed.fields[field.name]) continue;\n\n            // Value should be comma-separated names (string)\n            const namesValue = transformed.fields[field.name];\n            if (typeof namesValue !== 'string') continue;\n\n            const names = namesValue.split(',').map((n) => n.trim()).filter((n) => n);\n            if (names.length === 0) continue;\n\n            try {\n              const resolveResult = await resolveNamesToRecordIds(\n                airtableAccessToken,\n                baseId,\n                linkedTableId,\n                names,\n                {\n                  createMissing: createMissingLinkedRecords,\n                  strictMode: validationMode === 'strict',\n                }\n              );\n\n              // Convert to Airtable format\n              transformed.fields[field.name] = resolveResult.resolved.map((id) => ({ id }));\n\n              if (resolveResult.warnings.length > 0) {\n                transformed.warnings.push(...resolveResult.warnings);\n              }\n\n              if (resolveResult.missing.length > 0) {\n                const msg = `Row ${rowNumber}, field ${field.name}: Could not resolve names: ${resolveResult.missing.join(', ')}`;\n                if (validationMode === 'strict') {\n                  transformed.errors.push(msg);\n                } else {\n                  transformed.warnings.push(msg);\n                }\n              }\n            } catch (error) {\n              const msg = `Row ${rowNumber}, field ${field.name}: Failed to resolve linked records: ${error instanceof Error ? error.message : String(error)}`;\n              if (validationMode === 'strict') {\n                transformed.errors.push(msg);\n              } else {\n                transformed.warnings.push(msg);\n              }\n            }\n          }\n        }\n\n        // Check if row is valid\n        const isValid = validationMode === 'lenient' || transformed.errors.length === 0;\n\n        transformedRows.push({\n          rowIndex: i,\n          recordId,\n          fields: transformed.fields,\n          errors: transformed.errors,\n          warnings: transformed.warnings,\n          isValid,\n        });\n\n        // Log errors and warnings\n        if (transformed.errors.length > 0) {\n          result.errors.push({\n            rowNumber,\n            recordId,\n            type: 'TRANSFORM',\n            message: `Transformation errors: ${transformed.errors.join('; ')}`,\n          });\n        }\n\n        if (transformed.warnings.length > 0) {\n          result.warnings.push(`Row ${rowNumber}: ${transformed.warnings.join('; ')}`);\n        }\n      } catch (error) {\n        const msg = `Failed to transform row ${rowNumber}: ${error instanceof Error ? error.message : String(error)}`;\n\n        if (validationMode === 'strict') {\n          result.errors.push({\n            rowNumber,\n            recordId,\n            type: 'TRANSFORM',\n            message: msg,\n            originalError: error,\n          });\n        } else {\n          result.warnings.push(msg);\n          // Add invalid row\n          transformedRows.push({\n            rowIndex: i,\n            recordId,\n            fields: {},\n            errors: [msg],\n            warnings: [],\n            isValid: false,\n          });\n        }\n      }\n    }\n\n    // Filter to only valid rows\n    const validRows = transformedRows.filter((r) => r.isValid);\n    console.log(\n      `[SheetsToAirtable] Transformed ${validRows.length}/${transformedRows.length} valid rows`\n    );\n\n    if (validRows.length === 0 && transformedRows.length > 0) {\n      result.errors.push({\n        type: 'VALIDATION',\n        message: 'No valid rows to sync after transformation',\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // ========================================================================\n    // STEP 5: Fetch Existing Airtable Records\n    // ========================================================================\n    console.log(`[SheetsToAirtable] Fetching existing Airtable records...`);\n\n    let existingRecords: AirtableRecord[] = [];\n    try {\n      existingRecords = await retryWithBackoff(\n        () => listRecords(airtableAccessToken, baseId, tableId),\n        maxRetries,\n        'fetch Airtable records'\n      );\n\n      console.log(`[SheetsToAirtable] Found ${existingRecords.length} existing records in Airtable`);\n    } catch (error) {\n      result.errors.push({\n        type: 'FETCH',\n        message: `Failed to fetch existing Airtable records: ${error instanceof Error ? error.message : String(error)}`,\n        originalError: error,\n      });\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // ========================================================================\n    // STEP 6: Calculate Diff (Create/Update/Delete)\n    // ========================================================================\n    console.log(`[SheetsToAirtable] Calculating changes...`);\n\n    const diff = calculateRecordDiff(validRows, existingRecords, deleteExtraRecords, primaryFieldName);\n\n    console.log(\n      `[SheetsToAirtable] Changes: ${diff.toCreate.length} to create, ${diff.toUpdate.length} to update, ${diff.toDelete.length} to delete`\n    );\n\n    // ========================================================================\n    // STEP 7: Apply Changes to Airtable\n    // ========================================================================\n\n    // 7.1: Create new records (in batches of 10)\n    const newRecordIdUpdates: Array<{ row: number; recordId: string }> = [];\n\n    if (diff.toCreate.length > 0) {\n      console.log(`[SheetsToAirtable] Creating ${diff.toCreate.length} new records...`);\n\n      const createBatches = batchOperations(diff.toCreate, effectiveBatchSize);\n      let createdSoFar = 0;\n\n      for (let i = 0; i < createBatches.length; i++) {\n        const batch = createBatches[i];\n\n        try {\n          const created = await retryWithBackoff(\n            () => createRecords(airtableAccessToken, baseId, tableId, batch),\n            maxRetries,\n            `create records batch ${i + 1}/${createBatches.length}`\n          );\n\n          // Track which rows got which record IDs so we can write them back to Sheets\n          for (let j = 0; j < created.length; j++) {\n            const createdRecord = created[j];\n            const originalRowIndex = validRows.filter(r => !r.recordId)[createdSoFar + j]?.rowIndex;\n\n            if (originalRowIndex !== undefined && createdRecord.id) {\n              // Store the row number (accounting for header) and the new record ID\n              const sheetRowNumber = originalRowIndex + (skipHeaderRow ? 2 : 1);\n              newRecordIdUpdates.push({ row: sheetRowNumber, recordId: createdRecord.id });\n            }\n          }\n\n          createdSoFar += created.length;\n          result.added += created.length;\n          console.log(\n            `[SheetsToAirtable] Created batch ${i + 1}/${createBatches.length} (${created.length} records)`\n          );\n        } catch (error) {\n          result.errors.push({\n            type: 'WRITE',\n            message: `Failed to create records batch ${i + 1}: ${error instanceof Error ? error.message : String(error)}`,\n            originalError: error,\n          });\n\n          // In lenient mode, continue with remaining batches\n          if (validationMode === 'strict') {\n            return finalizeSyncResult(result, startTime);\n          }\n        }\n      }\n    }\n\n    // 7.2: Update existing records (in batches of 10)\n    if (diff.toUpdate.length > 0) {\n      console.log(`[SheetsToAirtable] Updating ${diff.toUpdate.length} records...`);\n\n      const updateBatches = batchOperations(diff.toUpdate, effectiveBatchSize);\n\n      for (let i = 0; i < updateBatches.length; i++) {\n        const batch = updateBatches[i];\n\n        try {\n          const updated = await retryWithBackoff(\n            () => updateRecords(airtableAccessToken, baseId, tableId, batch),\n            maxRetries,\n            `update records batch ${i + 1}/${updateBatches.length}`\n          );\n\n          result.updated += updated.length;\n          console.log(\n            `[SheetsToAirtable] Updated batch ${i + 1}/${updateBatches.length} (${updated.length} records)`\n          );\n        } catch (error) {\n          result.errors.push({\n            type: 'WRITE',\n            message: `Failed to update records batch ${i + 1}: ${error instanceof Error ? error.message : String(error)}`,\n            originalError: error,\n          });\n\n          // In lenient mode, continue with remaining batches\n          if (validationMode === 'strict') {\n            return finalizeSyncResult(result, startTime);\n          }\n        }\n      }\n    }\n\n    // 7.3: Delete extra records (in batches of 10)\n    if (diff.toDelete.length > 0 && deleteExtraRecords) {\n      console.log(`[SheetsToAirtable] Deleting ${diff.toDelete.length} extra records...`);\n\n      const deleteBatches = batchOperations(diff.toDelete, effectiveBatchSize);\n\n      for (let i = 0; i < deleteBatches.length; i++) {\n        const batch = deleteBatches[i];\n\n        try {\n          const deleted = await retryWithBackoff(\n            () => deleteRecords(airtableAccessToken, baseId, tableId, batch),\n            maxRetries,\n            `delete records batch ${i + 1}/${deleteBatches.length}`\n          );\n\n          result.deleted += deleted.length;\n          console.log(\n            `[SheetsToAirtable] Deleted batch ${i + 1}/${deleteBatches.length} (${deleted.length} records)`\n          );\n        } catch (error) {\n          result.errors.push({\n            type: 'WRITE',\n            message: `Failed to delete records batch ${i + 1}: ${error instanceof Error ? error.message : String(error)}`,\n            originalError: error,\n          });\n\n          // In lenient mode, continue with remaining batches\n          if (validationMode === 'strict') {\n            return finalizeSyncResult(result, startTime);\n          }\n        }\n      }\n    }\n\n    // ========================================================================\n    // STEP 7.4: Write new record IDs back to Google Sheets\n    // ========================================================================\n    // CRITICAL: This prevents duplicate records on subsequent syncs\n    if (newRecordIdUpdates.length > 0) {\n      console.log(\n        `[SheetsToAirtable] Writing ${newRecordIdUpdates.length} new record IDs back to Sheets...`\n      );\n\n      try {\n        const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n\n        // STEP 1: Ensure column AA (index 26) exists before writing to it\n        // This prevents errors when the sheet only has columns A-Z (0-25)\n        const requiredColumnCount = actualIdColumnIndex + 1; // Need at least this many columns (index 26 = 27 columns total)\n        console.log(\n          `[SheetsToAirtable] Ensuring column ${columnLetter} exists (need ${requiredColumnCount} columns)...`\n        );\n        await ensureColumnsExist(sheetsAccessToken, spreadsheetId, sheetId, requiredColumnCount);\n\n        // STEP 2: Write record IDs to column AA\n        // Sort by row number to ensure correct order\n        newRecordIdUpdates.sort((a, b) => a.row - b.row);\n\n        // Update each row's ID column with the new Airtable record ID\n        // We'll batch these updates for efficiency\n        const updatePromises: Promise<any>[] = [];\n\n        for (const update of newRecordIdUpdates) {\n          // Convert row number to A1 notation for the ID column\n          const range = `${columnLetter}${update.row}`;\n\n          updatePromises.push(\n            updateSheetData(\n              sheetsAccessToken,\n              spreadsheetId,\n              sheetId,\n              range,\n              [[update.recordId]]\n            ).catch((error) => {\n              // Log error but don't fail the entire sync\n              result.warnings.push(\n                `Failed to write record ID ${update.recordId} to row ${update.row}: ${error instanceof Error ? error.message : String(error)}`\n              );\n              console.warn(\n                `[SheetsToAirtable] Failed to write ID for row ${update.row}:`,\n                error\n              );\n            })\n          );\n\n          // Batch updates in groups of 10 to avoid rate limits\n          if (updatePromises.length >= 10) {\n            await Promise.all(updatePromises);\n            updatePromises.length = 0;\n            // Small delay to respect rate limits\n            await new Promise((resolve) => setTimeout(resolve, 100));\n          }\n        }\n\n        // Process remaining updates\n        if (updatePromises.length > 0) {\n          await Promise.all(updatePromises);\n        }\n\n        console.log(\n          `[SheetsToAirtable] âœ“ Successfully wrote ${newRecordIdUpdates.length} record IDs to column ${columnLetter}`\n        );\n\n        // STEP 3: Hide column AA to keep sheets clean for users\n        try {\n          await hideColumn(sheetsAccessToken, spreadsheetId, sheetId, actualIdColumnIndex);\n          console.log(\n            `[SheetsToAirtable] âœ“ Hidden column ${columnLetter} (users won't see record IDs)`\n          );\n        } catch (error) {\n          // Non-fatal - log warning\n          result.warnings.push(\n            `Could not auto-hide ID column: ${error instanceof Error ? error.message : String(error)}`\n          );\n          console.warn('[SheetsToAirtable] Failed to hide ID column:', error);\n        }\n      } catch (error) {\n        // Non-fatal error - log warning but don't fail the sync\n        const warningMsg = `Failed to write some record IDs back to Sheets: ${error instanceof Error ? error.message : String(error)}. You may experience duplicate records on next sync.`;\n        result.warnings.push(warningMsg);\n        console.error('[SheetsToAirtable] Error writing IDs back to Sheets:', error);\n      }\n    }\n\n    // ========================================================================\n    // STEP 8: Finalize\n    // ========================================================================\n\n    console.log(\n      `[SheetsToAirtable] Sync complete: ${result.added} added, ${result.updated} updated, ${result.deleted} deleted`\n    );\n\n    return finalizeSyncResult(result, startTime);\n  } catch (error) {\n    result.errors.push({\n      type: 'UNKNOWN',\n      message: `Unexpected error during sync: ${error instanceof Error ? error.message : String(error)}`,\n      originalError: error,\n    });\n\n    return finalizeSyncResult(result, startTime);\n  }\n}\n\n// ============================================================================\n// Diff Calculation\n// ============================================================================\n\n/**\n * Calculates the difference between Sheets data and existing Airtable records\n *\n * Smart Matching Strategy:\n * 1. If row has a record ID (from previous sync) â†’ Match by ID (exact match)\n * 2. If no ID, try to match by primary field value (e.g., Name, Email)\n * 3. If still no match â†’ Create new record\n *\n * This allows first-time syncs to work without IDs while preventing duplicates\n */\nfunction calculateRecordDiff(\n  transformedRows: TransformedRow[],\n  existingRecords: AirtableRecord[],\n  deleteExtra: boolean,\n  primaryFieldName?: string\n): RecordDiff {\n  const diff: RecordDiff = {\n    toCreate: [],\n    toUpdate: [],\n    toDelete: [],\n    rowToRecordMap: new Map(),\n  };\n\n  // Build map of existing records by ID\n  const existingRecordsMap = new Map<string, AirtableRecord>(\n    existingRecords.map((r) => [r.id, r])\n  );\n\n  // Build map of existing records by primary field (for smart matching)\n  const existingRecordsByPrimaryField = new Map<string, AirtableRecord>();\n  if (primaryFieldName) {\n    for (const record of existingRecords) {\n      const primaryValue = record.fields[primaryFieldName];\n      if (primaryValue) {\n        const normalizedValue = String(primaryValue).trim().toLowerCase();\n        if (normalizedValue) {\n          existingRecordsByPrimaryField.set(normalizedValue, record);\n        }\n      }\n    }\n  }\n\n  // Track which existing records are still in Sheets\n  const processedRecordIds = new Set<string>();\n\n  // Process transformed rows\n  for (const row of transformedRows) {\n    if (!row.isValid) continue;\n\n    let matchedRecord: AirtableRecord | undefined;\n\n    // Strategy 1: Match by record ID (if available)\n    if (row.recordId && existingRecordsMap.has(row.recordId)) {\n      matchedRecord = existingRecordsMap.get(row.recordId)!;\n    }\n    // Strategy 2: Match by primary field (fallback when no ID)\n    else if (!row.recordId && primaryFieldName && row.fields[primaryFieldName]) {\n      const primaryValue = String(row.fields[primaryFieldName]).trim().toLowerCase();\n      if (primaryValue) {\n        matchedRecord = existingRecordsByPrimaryField.get(primaryValue);\n        if (matchedRecord) {\n          console.log(\n            `[SheetsToAirtable] Matched row ${row.rowIndex} to existing record ${matchedRecord.id} by primary field \"${primaryFieldName}\"`\n          );\n        }\n      }\n    }\n\n    if (matchedRecord) {\n      // Record exists (either by ID or primary field match) - check if it needs updating\n      processedRecordIds.add(matchedRecord.id);\n\n      if (hasRecordChanged(row.fields, matchedRecord.fields)) {\n        diff.toUpdate.push({\n          id: matchedRecord.id,\n          fields: row.fields,\n        });\n      }\n\n      diff.rowToRecordMap.set(row.rowIndex, matchedRecord.id);\n    } else {\n      // New record - create it\n      // Remove empty fields to avoid validation errors\n      const cleanedFields = Object.fromEntries(\n        Object.entries(row.fields).filter(([_, value]) => value !== null && value !== undefined)\n      );\n\n      diff.toCreate.push({\n        fields: cleanedFields,\n      });\n    }\n  }\n\n  // Find records to delete (exist in Airtable but not in Sheets)\n  if (deleteExtra) {\n    for (const record of existingRecords) {\n      if (!processedRecordIds.has(record.id)) {\n        diff.toDelete.push(record.id);\n      }\n    }\n  }\n\n  return diff;\n}\n\n/**\n * Checks if a record has changed by comparing fields\n */\nfunction hasRecordChanged(\n  newFields: Record<string, any>,\n  existingFields: Record<string, any>\n): boolean {\n  // Get all field names from both objects\n  const allFieldNames = new Set([\n    ...Object.keys(newFields),\n    ...Object.keys(existingFields),\n  ]);\n\n  for (const fieldName of allFieldNames) {\n    const newValue = normalizeFieldValue(newFields[fieldName]);\n    const existingValue = normalizeFieldValue(existingFields[fieldName]);\n\n    if (!areValuesEqual(newValue, existingValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Normalizes a field value for comparison\n */\nfunction normalizeFieldValue(value: any): any {\n  if (value === null || value === undefined || value === '') {\n    return null;\n  }\n\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    // Handle floating point precision\n    return Math.round(value * 1000000) / 1000000;\n  }\n\n  if (Array.isArray(value)) {\n    // For linked records, sort by ID\n    if (value.length > 0 && typeof value[0] === 'object' && 'id' in value[0]) {\n      return value.map((v) => v.id).sort();\n    }\n    return value.map(normalizeFieldValue).sort();\n  }\n\n  if (typeof value === 'object') {\n    // For objects like linked records, extract ID\n    if ('id' in value) {\n      return value.id;\n    }\n  }\n\n  return value;\n}\n\n/**\n * Compares two normalized values for equality\n */\nfunction areValuesEqual(val1: any, val2: any): boolean {\n  if (val1 === val2) return true;\n  if (val1 === null || val2 === null) return val1 === val2;\n\n  if (Array.isArray(val1) && Array.isArray(val2)) {\n    if (val1.length !== val2.length) return false;\n    return val1.every((v, i) => v === val2[i]);\n  }\n\n  return false;\n}\n\n/**\n * Checks if a row is completely empty\n */\nfunction isRowEmpty(row: any[]): boolean {\n  return row.every((cell) => cell === null || cell === undefined || String(cell).trim() === '');\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Retries a function with exponential backoff\n */\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number,\n  operation: string\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Don't retry on last attempt\n      if (attempt === maxRetries) {\n        break;\n      }\n\n      // Check if it's a rate limit error\n      const isRateLimit =\n        lastError.message.toLowerCase().includes('rate limit') ||\n        lastError.message.toLowerCase().includes('quota') ||\n        lastError.message.includes('429');\n\n      // Check if it's a validation error (don't retry these)\n      const isValidationError =\n        lastError.message.toLowerCase().includes('invalid') ||\n        lastError.message.toLowerCase().includes('validation') ||\n        lastError.message.includes('422');\n\n      if (isValidationError) {\n        // Don't retry validation errors\n        throw lastError;\n      }\n\n      if (!isRateLimit && attempt > 0) {\n        // Only retry non-rate-limit errors once\n        break;\n      }\n\n      // Exponential backoff with jitter\n      const delay = Math.min(1000 * Math.pow(2, attempt), 30000) + Math.random() * 1000;\n      console.warn(\n        `[SheetsToAirtable] ${operation} failed (attempt ${attempt + 1}/${maxRetries + 1}), ` +\n          `retrying in ${Math.round(delay)}ms...`,\n        lastError.message\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Finalizes the sync result with duration and completion time\n */\nfunction finalizeSyncResult(result: SyncResult, startTime: number): SyncResult {\n  result.duration = Date.now() - startTime;\n  result.completedAt = new Date();\n  return result;\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n  retryWithBackoff,\n  hasRecordChanged,\n  normalizeFieldValue,\n  areValuesEqual,\n  isRowEmpty,\n};\n","/**\n * Conflict Detector for Bidirectional Sync\n * Detects and resolves conflicts when the same record changes in both Airtable and Sheets\n */\n\nimport crypto from 'crypto';\nimport type { AirtableRecord } from '../airtable/client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type ConflictResolutionStrategy = 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS';\n\nexport interface RecordState {\n  /** Record ID (Airtable record ID) */\n  recordId: string;\n  /** Hash of all field values (for change detection) */\n  contentHash: string;\n  /** Last modification timestamp from Airtable */\n  airtableModifiedTime?: string;\n  /** Last modification timestamp from Sheets (or last sync time) */\n  sheetsModifiedTime?: string;\n  /** Timestamp when this state was captured */\n  capturedAt: number;\n}\n\nexport interface SyncState {\n  /** Sync config ID this state belongs to */\n  syncConfigId: string;\n  /** Map of record ID to last known state */\n  records: Map<string, RecordState>;\n  /** Timestamp of last sync operation */\n  lastSyncTime: number;\n}\n\nexport interface ConflictInfo {\n  /** Record ID experiencing conflict */\n  recordId: string;\n  /** Current state in Airtable */\n  airtableState: {\n    record: AirtableRecord;\n    contentHash: string;\n    modifiedTime?: string;\n  };\n  /** Current state in Sheets */\n  sheetsState: {\n    row: any[];\n    contentHash: string;\n    modifiedTime?: string;\n  };\n  /** Last known state from previous sync */\n  lastKnownState?: RecordState;\n  /** Type of conflict detected */\n  conflictType: 'BOTH_MODIFIED' | 'DELETED_IN_AIRTABLE' | 'DELETED_IN_SHEETS';\n}\n\nexport interface ConflictResolution {\n  /** Record ID */\n  recordId: string;\n  /** Resolved action to take */\n  action: 'USE_AIRTABLE' | 'USE_SHEETS' | 'DELETE' | 'SKIP';\n  /** Source that won the conflict */\n  winner: 'AIRTABLE' | 'SHEETS' | 'NONE';\n  /** Reason for resolution */\n  reason: string;\n}\n\nexport interface ConflictDetectionResult {\n  /** Records that have conflicts */\n  conflicts: ConflictInfo[];\n  /** Records changed only in Airtable */\n  airtableOnlyChanges: string[];\n  /** Records changed only in Sheets */\n  sheetsOnlyChanges: string[];\n  /** Records with no changes */\n  noChanges: string[];\n  /** New records in Airtable */\n  newInAirtable: string[];\n  /** New records in Sheets */\n  newInSheets: number[];\n}\n\n// ============================================================================\n// In-Memory State Storage\n// ============================================================================\n\nclass SyncStateManager {\n  private states: Map<string, SyncState> = new Map();\n\n  /**\n   * Gets the sync state for a config\n   */\n  getState(syncConfigId: string): SyncState | undefined {\n    return this.states.get(syncConfigId);\n  }\n\n  /**\n   * Sets the sync state for a config\n   */\n  setState(syncConfigId: string, state: SyncState): void {\n    this.states.set(syncConfigId, state);\n  }\n\n  /**\n   * Updates the state for a single record\n   */\n  updateRecordState(syncConfigId: string, recordState: RecordState): void {\n    let state = this.states.get(syncConfigId);\n    if (!state) {\n      state = {\n        syncConfigId,\n        records: new Map(),\n        lastSyncTime: Date.now(),\n      };\n      this.states.set(syncConfigId, state);\n    }\n    state.records.set(recordState.recordId, recordState);\n  }\n\n  /**\n   * Removes a record from state\n   */\n  removeRecordState(syncConfigId: string, recordId: string): void {\n    const state = this.states.get(syncConfigId);\n    if (state) {\n      state.records.delete(recordId);\n    }\n  }\n\n  /**\n   * Clears state for a sync config\n   */\n  clearState(syncConfigId: string): void {\n    this.states.delete(syncConfigId);\n  }\n\n  /**\n   * Clears all states\n   */\n  clearAll(): void {\n    this.states.clear();\n  }\n\n  /**\n   * Gets statistics about stored states\n   */\n  getStats(): {\n    totalConfigs: number;\n    totalRecords: number;\n    configs: Array<{ id: string; recordCount: number; lastSync: number }>;\n  } {\n    const configs = Array.from(this.states.entries()).map(([id, state]) => ({\n      id,\n      recordCount: state.records.size,\n      lastSync: state.lastSyncTime,\n    }));\n\n    const totalRecords = configs.reduce((sum, c) => sum + c.recordCount, 0);\n\n    return {\n      totalConfigs: this.states.size,\n      totalRecords,\n      configs,\n    };\n  }\n}\n\n// Global state manager instance\nconst stateManager = new SyncStateManager();\n\n// ============================================================================\n// Hash Generation\n// ============================================================================\n\n/**\n * Generates a hash of record field values for change detection\n * This allows us to detect actual changes vs. no-op updates\n */\nexport function generateRecordHash(fields: Record<string, any>): string {\n  // Sort keys to ensure consistent hash regardless of field order\n  const sortedFields = Object.keys(fields)\n    .sort()\n    .reduce((acc, key) => {\n      acc[key] = normalizeFieldValue(fields[key]);\n      return acc;\n    }, {} as Record<string, any>);\n\n  const content = JSON.stringify(sortedFields);\n  return crypto.createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Generates a hash of a Sheets row for change detection\n */\nexport function generateRowHash(row: any[]): string {\n  // Normalize array values\n  const normalized = row.map(normalizeFieldValue);\n  const content = JSON.stringify(normalized);\n  return crypto.createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Normalizes field values for consistent hashing\n */\nfunction normalizeFieldValue(value: any): any {\n  if (value === null || value === undefined || value === '') {\n    return null;\n  }\n\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n\n  if (typeof value === 'number') {\n    // Handle floating point precision issues\n    return Math.round(value * 1000000) / 1000000;\n  }\n\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(normalizeFieldValue).sort();\n  }\n\n  if (typeof value === 'object') {\n    // For objects (like linked records), sort by ID\n    if ('id' in value) {\n      return value.id;\n    }\n    // For other objects, recursively normalize\n    return Object.keys(value)\n      .sort()\n      .reduce((acc, key) => {\n        acc[key] = normalizeFieldValue(value[key]);\n        return acc;\n      }, {} as Record<string, any>);\n  }\n\n  return value;\n}\n\n// ============================================================================\n// State Capture\n// ============================================================================\n\n/**\n * Captures the current state of Airtable records\n * @param records - Airtable records to capture\n *\n * CRITICAL: Always hashes ALL fields in Airtable records, not just mapped fields.\n * This ensures we detect changes to any field in Airtable, even if it's not mapped to Sheets.\n */\nexport function captureAirtableState(\n  records: AirtableRecord[]\n): RecordState[] {\n  const now = Date.now();\n\n  return records.map((record) => {\n    // Hash all fields to detect any changes\n    const fieldsToHash = record.fields;\n\n    return {\n      recordId: record.id,\n      contentHash: generateRecordHash(fieldsToHash),\n      airtableModifiedTime: record.createdTime,\n      capturedAt: now,\n    };\n  });\n}\n\n/**\n * Captures the current state of Sheets rows\n * @param rows - Array of rows from Sheets\n * @param idColumnIndex - Column index containing Airtable record IDs (optional)\n */\nexport function captureSheetsState(\n  rows: any[][],\n  idColumnIndex?: number\n): Map<string, RecordState> {\n  const now = Date.now();\n  const states = new Map<string, RecordState>();\n\n  rows.forEach((row, rowIndex) => {\n    // CRITICAL FIX: If row doesn't have a record ID yet (first sync), use row index as identifier\n    // This allows initial bidirectional sync to work when Sheets has data but no record IDs\n    const hasRecordId = idColumnIndex !== undefined && row[idColumnIndex] && String(row[idColumnIndex]).trim() !== '';\n    const recordId = hasRecordId\n      ? String(row[idColumnIndex]).trim()\n      : `row_${rowIndex}`;\n\n    // Skip completely empty rows\n    if (isRowEmpty(row)) {\n      return;\n    }\n\n    // CRITICAL: Exclude ID column from hash to avoid false-positive change detection\n    // The ID column is metadata for sync tracking, not user data\n    const rowDataOnly = idColumnIndex !== undefined\n      ? row.filter((_, idx) => idx !== idColumnIndex)\n      : row;\n\n    states.set(recordId, {\n      recordId: recordId,\n      contentHash: generateRowHash(rowDataOnly),\n      sheetsModifiedTime: new Date().toISOString(), // Sheets doesn't provide cell-level timestamps\n      capturedAt: now,\n    });\n  });\n\n  return states;\n}\n\n/**\n * Checks if a row is completely empty\n */\nfunction isRowEmpty(row: any[]): boolean {\n  return row.every((cell) => cell === null || cell === undefined || String(cell).trim() === '');\n}\n\n// ============================================================================\n// Conflict Detection\n// ============================================================================\n\n/**\n * Detects conflicts between Airtable and Sheets states\n *\n * @param airtableRecords - Current records from Airtable\n * @param sheetsRows - Current rows from Sheets\n * @param syncConfigId - Sync configuration ID\n * @param idColumnIndex - Column index in Sheets containing Airtable record IDs\n * @returns Conflict detection results\n */\nexport function detectConflicts(\n  airtableRecords: AirtableRecord[],\n  sheetsRows: any[][],\n  syncConfigId: string,\n  idColumnIndex?: number\n): ConflictDetectionResult {\n  const result: ConflictDetectionResult = {\n    conflicts: [],\n    airtableOnlyChanges: [],\n    sheetsOnlyChanges: [],\n    noChanges: [],\n    newInAirtable: [],\n    newInSheets: [],\n  };\n\n  // Get last known state\n  const lastState = stateManager.getState(syncConfigId);\n\n  // Capture current states\n  // CRITICAL: Airtable state now includes ALL fields (not filtered by mappings)\n  // This ensures we detect changes to any Airtable field, even unmapped ones\n  const currentAirtableStates = new Map(\n    captureAirtableState(airtableRecords).map((s) => [s.recordId, s])\n  );\n  const currentSheetsStates = captureSheetsState(sheetsRows, idColumnIndex);\n\n  // DEBUG: Log state for troubleshooting\n  console.log(`[ConflictDetector] ========== DEBUG INFO ==========`);\n  console.log(`[ConflictDetector] Tracking ALL Airtable fields (not filtered by mappings)`);\n  console.log(`[ConflictDetector] ID column index: ${idColumnIndex}`);\n  console.log(`[ConflictDetector] Airtable records: ${airtableRecords.length}`);\n  console.log(`[ConflictDetector] Sheets rows: ${sheetsRows.length}`);\n  console.log(`[ConflictDetector] Has previous state: ${!!lastState}`);\n\n  if (lastState) {\n    console.log(`[ConflictDetector] Previous state records: ${lastState.records.size}`);\n  }\n\n  // Log first record comparison for debugging\n  if (airtableRecords.length > 0) {\n    const firstRecord = airtableRecords[0];\n    const airtableState = currentAirtableStates.get(firstRecord.id);\n    const sheetsState = currentSheetsStates.get(firstRecord.id);\n    const lastKnown = lastState?.records.get(firstRecord.id);\n\n    console.log(`[ConflictDetector] --- First Record Debug (${firstRecord.id}) ---`);\n    console.log(`[ConflictDetector] Airtable fields:`, JSON.stringify(firstRecord.fields, null, 2));\n\n    // Get the row from Sheets\n    const sheetsRow = sheetsRows.find(row => row[idColumnIndex || 0] === firstRecord.id);\n    console.log(`[ConflictDetector] Sheets row:`, JSON.stringify(sheetsRow, null, 2));\n\n    console.log(`[ConflictDetector] Airtable hash: ${airtableState?.contentHash?.substring(0, 16)}...`);\n    console.log(`[ConflictDetector] Sheets hash:   ${sheetsState?.contentHash?.substring(0, 16) || 'NOT FOUND'}...`);\n    console.log(`[ConflictDetector] Last hash:     ${lastKnown?.contentHash?.substring(0, 16) || 'NO PREVIOUS STATE'}...`);\n\n    if (lastKnown) {\n      console.log(`[ConflictDetector] Airtable changed: ${airtableState?.contentHash !== lastKnown.contentHash}`);\n      console.log(`[ConflictDetector] Sheets changed:   ${sheetsState?.contentHash !== lastKnown.contentHash}`);\n    }\n  }\n  console.log(`[ConflictDetector] ================================`);\n\n  // If no previous state, everything is new\n  if (!lastState) {\n    result.newInAirtable = Array.from(currentAirtableStates.keys());\n\n    // CRITICAL FIX: newInSheets should contain row indices for rows without record IDs\n    // Parse `row_X` identifiers back to row indices\n    result.newInSheets = Array.from(currentSheetsStates.keys())\n      .filter((id) => id.startsWith('row_'))\n      .map((id) => parseInt(id.replace('row_', ''), 10))\n      .filter((n) => !isNaN(n));\n\n    console.log(`[ConflictDetector] First sync detected: ${result.newInAirtable.length} new in Airtable, ${result.newInSheets.length} new in Sheets`);\n\n    return result;\n  }\n\n  const lastKnownRecords = lastState.records;\n  const processedRecords = new Set<string>();\n\n  // Check Airtable records for changes and conflicts\n  for (const [recordId, airtableState] of currentAirtableStates.entries()) {\n    processedRecords.add(recordId);\n\n    const sheetsState = currentSheetsStates.get(recordId);\n    const lastKnown = lastKnownRecords.get(recordId);\n\n    // New record in Airtable\n    if (!lastKnown) {\n      result.newInAirtable.push(recordId);\n      continue;\n    }\n\n    // Record deleted in Sheets\n    if (!sheetsState) {\n      const airtableChanged = airtableState.contentHash !== lastKnown.contentHash;\n\n      if (airtableChanged) {\n        // Conflict: modified in Airtable but deleted in Sheets\n        const record = airtableRecords.find((r) => r.id === recordId)!;\n        result.conflicts.push({\n          recordId,\n          airtableState: {\n            record,\n            contentHash: airtableState.contentHash,\n            modifiedTime: airtableState.airtableModifiedTime,\n          },\n          sheetsState: {\n            row: [],\n            contentHash: '',\n            modifiedTime: undefined,\n          },\n          lastKnownState: lastKnown,\n          conflictType: 'DELETED_IN_SHEETS',\n        });\n      } else {\n        // Just deleted in Sheets, no conflict\n        result.sheetsOnlyChanges.push(recordId);\n      }\n      continue;\n    }\n\n    // Check for changes\n    const airtableChanged = airtableState.contentHash !== lastKnown.contentHash;\n    const sheetsChanged = sheetsState.contentHash !== lastKnown.contentHash;\n\n    if (airtableChanged && sheetsChanged) {\n      // Conflict: both sides modified\n      const record = airtableRecords.find((r) => r.id === recordId)!;\n      const rowIndex = Array.from(currentSheetsStates.entries()).findIndex(\n        ([id]) => id === recordId\n      );\n      result.conflicts.push({\n        recordId,\n        airtableState: {\n          record,\n          contentHash: airtableState.contentHash,\n          modifiedTime: airtableState.airtableModifiedTime,\n        },\n        sheetsState: {\n          row: sheetsRows[rowIndex],\n          contentHash: sheetsState.contentHash,\n          modifiedTime: sheetsState.sheetsModifiedTime,\n        },\n        lastKnownState: lastKnown,\n        conflictType: 'BOTH_MODIFIED',\n      });\n    } else if (airtableChanged) {\n      result.airtableOnlyChanges.push(recordId);\n    } else if (sheetsChanged) {\n      result.sheetsOnlyChanges.push(recordId);\n    } else {\n      result.noChanges.push(recordId);\n    }\n  }\n\n  // Check for records that exist in Sheets but not in Airtable\n  for (const [recordId, sheetsState] of currentSheetsStates.entries()) {\n    if (processedRecords.has(recordId)) continue;\n\n    const lastKnown = lastKnownRecords.get(recordId);\n\n    // New record in Sheets\n    if (!lastKnown) {\n      // CRITICAL FIX: Find the row index for this record ID or row identifier\n      let rowIndex = -1;\n\n      if (recordId.startsWith('row_')) {\n        // Row without record ID - extract index from identifier\n        rowIndex = parseInt(recordId.replace('row_', ''), 10);\n      } else {\n        // Row with record ID - find it in sheetsRows by matching the ID column\n        rowIndex = sheetsRows.findIndex((row) =>\n          idColumnIndex !== undefined && row[idColumnIndex] && String(row[idColumnIndex]).trim() === recordId\n        );\n      }\n\n      if (rowIndex >= 0 && !isNaN(rowIndex)) {\n        result.newInSheets.push(rowIndex);\n      }\n      continue;\n    }\n\n    // Record deleted in Airtable\n    const sheetsChanged = sheetsState.contentHash !== lastKnown.contentHash;\n\n    if (sheetsChanged) {\n      // Conflict: modified in Sheets but deleted in Airtable\n      // Find row index for this record\n      let rowIndex = -1;\n      if (recordId.startsWith('row_')) {\n        rowIndex = parseInt(recordId.replace('row_', ''), 10);\n      } else {\n        rowIndex = sheetsRows.findIndex((row) =>\n          idColumnIndex !== undefined && row[idColumnIndex] && String(row[idColumnIndex]).trim() === recordId\n        );\n      }\n\n      result.conflicts.push({\n        recordId,\n        airtableState: {\n          record: { id: recordId, createdTime: '', fields: {} },\n          contentHash: '',\n          modifiedTime: undefined,\n        },\n        sheetsState: {\n          row: rowIndex >= 0 ? sheetsRows[rowIndex] : [],\n          contentHash: sheetsState.contentHash,\n          modifiedTime: sheetsState.sheetsModifiedTime,\n        },\n        lastKnownState: lastKnown,\n        conflictType: 'DELETED_IN_AIRTABLE',\n      });\n    } else {\n      // Just deleted in Airtable, no conflict\n      result.airtableOnlyChanges.push(recordId);\n    }\n  }\n\n  return result;\n}\n\n// ============================================================================\n// Conflict Resolution\n// ============================================================================\n\n/**\n * Resolves conflicts based on the specified strategy\n *\n * @param conflicts - Array of detected conflicts\n * @param strategy - Conflict resolution strategy\n * @returns Array of conflict resolutions\n */\nexport function resolveConflicts(\n  conflicts: ConflictInfo[],\n  strategy: ConflictResolutionStrategy\n): ConflictResolution[] {\n  return conflicts.map((conflict) => resolveConflict(conflict, strategy));\n}\n\n/**\n * Resolves a single conflict based on the strategy\n */\nfunction resolveConflict(\n  conflict: ConflictInfo,\n  strategy: ConflictResolutionStrategy\n): ConflictResolution {\n  // Handle deletion conflicts\n  if (conflict.conflictType === 'DELETED_IN_AIRTABLE') {\n    if (strategy === 'AIRTABLE_WINS') {\n      return {\n        recordId: conflict.recordId,\n        action: 'DELETE',\n        winner: 'AIRTABLE',\n        reason: 'Record deleted in Airtable, applying deletion to Sheets (AIRTABLE_WINS)',\n      };\n    } else if (strategy === 'SHEETS_WINS') {\n      return {\n        recordId: conflict.recordId,\n        action: 'USE_SHEETS',\n        winner: 'SHEETS',\n        reason: 'Record modified in Sheets but deleted in Airtable, recreating in Airtable (SHEETS_WINS)',\n      };\n    } else {\n      // NEWEST_WINS - deletion is considered newer\n      return {\n        recordId: conflict.recordId,\n        action: 'DELETE',\n        winner: 'AIRTABLE',\n        reason: 'Record deleted in Airtable (deletion considered most recent)',\n      };\n    }\n  }\n\n  if (conflict.conflictType === 'DELETED_IN_SHEETS') {\n    if (strategy === 'AIRTABLE_WINS') {\n      return {\n        recordId: conflict.recordId,\n        action: 'USE_AIRTABLE',\n        winner: 'AIRTABLE',\n        reason: 'Record modified in Airtable but deleted in Sheets, restoring to Sheets (AIRTABLE_WINS)',\n      };\n    } else if (strategy === 'SHEETS_WINS') {\n      return {\n        recordId: conflict.recordId,\n        action: 'DELETE',\n        winner: 'SHEETS',\n        reason: 'Record deleted in Sheets, applying deletion to Airtable (SHEETS_WINS)',\n      };\n    } else {\n      // NEWEST_WINS - deletion is considered newer\n      return {\n        recordId: conflict.recordId,\n        action: 'DELETE',\n        winner: 'SHEETS',\n        reason: 'Record deleted in Sheets (deletion considered most recent)',\n      };\n    }\n  }\n\n  // Handle BOTH_MODIFIED conflicts\n  if (strategy === 'AIRTABLE_WINS') {\n    return {\n      recordId: conflict.recordId,\n      action: 'USE_AIRTABLE',\n      winner: 'AIRTABLE',\n      reason: 'Both sides modified, Airtable takes precedence (AIRTABLE_WINS)',\n    };\n  }\n\n  if (strategy === 'SHEETS_WINS') {\n    return {\n      recordId: conflict.recordId,\n      action: 'USE_SHEETS',\n      winner: 'SHEETS',\n      reason: 'Both sides modified, Sheets takes precedence (SHEETS_WINS)',\n    };\n  }\n\n  // NEWEST_WINS - Since reliable timestamps aren't available (Airtable only has createdTime,\n  // Sheets has no modification timestamps), we default to Airtable as source of truth\n  // when both sides have truly been modified since last sync\n  return {\n    recordId: conflict.recordId,\n    action: 'USE_AIRTABLE',\n    winner: 'AIRTABLE',\n    reason: 'Both sides modified since last sync, no reliable modification timestamps available, defaulting to Airtable as source of truth',\n  };\n}\n\n// ============================================================================\n// State Management\n// ============================================================================\n\n/**\n * Updates the sync state after a successful sync\n */\nexport function updateSyncState(\n  syncConfigId: string,\n  airtableRecords: AirtableRecord[],\n  sheetsRows: any[][],\n  idColumnIndex?: number\n): void {\n  const airtableStates = captureAirtableState(airtableRecords);\n  const sheetsStates = captureSheetsState(sheetsRows, idColumnIndex);\n\n  // Merge both states\n  const allRecords = new Map<string, RecordState>();\n\n  airtableStates.forEach((state) => {\n    allRecords.set(state.recordId, state);\n  });\n\n  // Update with Sheets data where available\n  sheetsStates.forEach((state, recordId) => {\n    const existing = allRecords.get(recordId);\n    if (existing) {\n      // Merge timestamps\n      allRecords.set(recordId, {\n        ...existing,\n        sheetsModifiedTime: state.sheetsModifiedTime,\n      });\n    } else {\n      allRecords.set(recordId, state);\n    }\n  });\n\n  stateManager.setState(syncConfigId, {\n    syncConfigId,\n    records: allRecords,\n    lastSyncTime: Date.now(),\n  });\n}\n\n/**\n * Gets the current sync state for a config\n */\nexport function getSyncState(syncConfigId: string): SyncState | undefined {\n  return stateManager.getState(syncConfigId);\n}\n\n/**\n * Clears the sync state for a config\n */\nexport function clearSyncState(syncConfigId: string): void {\n  stateManager.clearState(syncConfigId);\n}\n\n/**\n * Gets statistics about sync states\n */\nexport function getSyncStateStats(): {\n  totalConfigs: number;\n  totalRecords: number;\n  configs: Array<{ id: string; recordCount: number; lastSync: number }>;\n} {\n  return stateManager.getStats();\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\n/**\n * Checks if a record has actually changed based on content hash\n */\nexport function hasRecordChanged(\n  currentHash: string,\n  previousHash?: string\n): boolean {\n  if (!previousHash) return true;\n  return currentHash !== previousHash;\n}\n\n/**\n * Gets a summary of conflict detection results\n */\nexport function summarizeConflicts(result: ConflictDetectionResult): {\n  totalConflicts: number;\n  totalChanges: number;\n  summary: string;\n} {\n  const totalConflicts = result.conflicts.length;\n  const totalChanges =\n    result.airtableOnlyChanges.length +\n    result.sheetsOnlyChanges.length +\n    result.newInAirtable.length +\n    result.newInSheets.length;\n\n  const parts: string[] = [];\n  if (result.conflicts.length > 0) {\n    parts.push(`${result.conflicts.length} conflicts`);\n  }\n  if (result.airtableOnlyChanges.length > 0) {\n    parts.push(`${result.airtableOnlyChanges.length} Airtable changes`);\n  }\n  if (result.sheetsOnlyChanges.length > 0) {\n    parts.push(`${result.sheetsOnlyChanges.length} Sheets changes`);\n  }\n  if (result.newInAirtable.length > 0) {\n    parts.push(`${result.newInAirtable.length} new in Airtable`);\n  }\n  if (result.newInSheets.length > 0) {\n    parts.push(`${result.newInSheets.length} new in Sheets`);\n  }\n  if (result.noChanges.length > 0) {\n    parts.push(`${result.noChanges.length} unchanged`);\n  }\n\n  return {\n    totalConflicts,\n    totalChanges,\n    summary: parts.join(', '),\n  };\n}\n","/**\n * Bidirectional Sync Orchestrator\n * Orchestrates two-way sync between Airtable and Google Sheets with conflict detection and resolution\n *\n * This is the most complex sync function - coordinates multiple sync operations,\n * detects conflicts, applies resolution strategies, and maintains sync state.\n */\n\nimport { prisma } from 'wasp/server';\nimport type { AirtableRecord, AirtableField } from '../airtable/client';\nimport { listRecords, getBaseSchema, updateRecords, createRecords } from '../airtable/client';\nimport {\n  getSheetData,\n  updateSheetData,\n  appendRows,\n  getSpreadsheet,\n  detectLastColumnIndex,\n  hideColumn,\n  ensureColumnsExist,\n  columnNumberToLetter,\n  type SheetData,\n} from '../google/client';\nimport { airtableRecordToSheetsRow, sheetsRowToAirtableFields } from './fieldMapper';\nimport { resolveAllLinkedRecords, preloadTableCache } from './linkedRecordResolver';\nimport {\n  detectConflicts,\n  resolveConflicts,\n  updateSyncState,\n  getSyncState,\n  summarizeConflicts,\n  type ConflictResolutionStrategy,\n  type ConflictInfo,\n  type ConflictResolution,\n  type ConflictDetectionResult,\n} from './conflictDetector';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface BidirectionalSyncOptions {\n  /** Sync configuration ID (for state tracking) */\n  syncConfigId: string;\n  /** Airtable access token */\n  airtableAccessToken: string;\n  /** Google Sheets access token */\n  sheetsAccessToken: string;\n  /** Airtable base ID */\n  baseId: string;\n  /** Airtable table ID or name */\n  tableId: string;\n  /** Airtable view ID or name (optional, for exact row order) */\n  viewId?: string;\n  /** Google Sheets spreadsheet ID */\n  spreadsheetId: string;\n  /** Google Sheet ID (name or gid) */\n  sheetId: string | number;\n  /** Conflict resolution strategy */\n  conflictResolution: ConflictResolutionStrategy;\n  /** Field mappings: { airtableFieldId: columnIndex } */\n  fieldMappings?: Record<string, number>;\n  /** Column index for Airtable record IDs (default: 0) */\n  idColumnIndex?: number;\n  /** Column index for last sync timestamp marker (default: last column + 1) */\n  syncTimestampColumnIndex?: number;\n  /** Whether to include header row (default: true) */\n  includeHeader?: boolean;\n  /** Whether to resolve linked records (default: true) */\n  resolveLinkedRecords?: boolean;\n  /** Whether to create missing linked records (default: false) */\n  createMissingLinkedRecords?: boolean;\n  /** Maximum retries for rate limit errors (default: 3) */\n  maxRetries?: number;\n  /** Batch size for operations (default: 10 for Airtable, 100 for Sheets) */\n  batchSize?: number;\n  /** Whether to perform dry run (no writes, just report changes) */\n  dryRun?: boolean;\n}\n\nexport interface BidirectionalSyncResult {\n  /** Overall sync status */\n  status: 'SUCCESS' | 'PARTIAL' | 'FAILED';\n  /** Summary of operations */\n  summary: {\n    /** Records synced from Airtable to Sheets */\n    airtableToSheets: {\n      added: number;\n      updated: number;\n      deleted: number;\n    };\n    /** Records synced from Sheets to Airtable */\n    sheetsToAirtable: {\n      added: number;\n      updated: number;\n      deleted: number;\n    };\n    /** Conflicts detected and resolved */\n    conflicts: {\n      total: number;\n      airtableWins: number;\n      sheetsWins: number;\n      deleted: number;\n      skipped: number;\n    };\n  };\n  /** Detailed sync phases */\n  phases: {\n    fetch: PhaseResult;\n    conflictDetection: PhaseResult;\n    conflictResolution: PhaseResult;\n    airtableToSheets: PhaseResult;\n    sheetsToAirtable: PhaseResult;\n    stateUpdate: PhaseResult;\n  };\n  /** All errors across all phases */\n  errors: SyncError[];\n  /** All warnings across all phases */\n  warnings: string[];\n  /** Execution time in milliseconds */\n  duration: number;\n  /** Timestamp when sync started */\n  startedAt: Date;\n  /** Timestamp when sync completed */\n  completedAt: Date;\n  /** Last sync timestamp for next sync */\n  lastSyncAt: Date;\n}\n\nexport interface PhaseResult {\n  /** Phase name */\n  phase: string;\n  /** Phase status */\n  status: 'SUCCESS' | 'FAILED' | 'SKIPPED';\n  /** Duration in milliseconds */\n  duration: number;\n  /** Errors in this phase */\n  errors: SyncError[];\n  /** Warnings in this phase */\n  warnings: string[];\n  /** Additional phase-specific data */\n  metadata?: Record<string, any>;\n}\n\nexport interface SyncError {\n  /** Phase where error occurred */\n  phase: string;\n  /** Record ID or row number */\n  recordId?: string;\n  rowNumber?: number;\n  /** Error message */\n  message: string;\n  /** Error type */\n  type: 'FETCH' | 'TRANSFORM' | 'WRITE' | 'CONFLICT' | 'VALIDATION' | 'STATE' | 'RATE_LIMIT' | 'OAUTH' | 'NETWORK' | 'UNKNOWN';\n  /** Original error */\n  originalError?: any;\n  /** Whether error is recoverable */\n  recoverable?: boolean;\n  /** Retry count for this error */\n  retryCount?: number;\n}\n\ninterface SyncCheckpoint {\n  /** Records in Airtable */\n  airtableRecords: AirtableRecord[];\n  /** Rows in Sheets (excluding header) */\n  sheetsRows: any[][];\n  /** Table field definitions */\n  tableFields: AirtableField[];\n  /** Primary field name (for smart matching) */\n  primaryFieldName?: string;\n  /** Conflict detection results */\n  conflictResults?: ConflictDetectionResult;\n  /** Conflict resolutions */\n  conflictResolutions?: ConflictResolution[];\n}\n\n// ============================================================================\n// Main Bidirectional Sync Function\n// ============================================================================\n\n/**\n * Orchestrates bidirectional sync between Airtable and Google Sheets\n *\n * This function:\n * 1. Fetches current state from both sources\n * 2. Detects changes since last sync\n * 3. Identifies and resolves conflicts\n * 4. Applies changes bidirectionally\n * 5. Updates sync state for next run\n *\n * Uses a checkpoint system to track sync state and enable recovery.\n */\nexport async function syncBidirectional(\n  options: BidirectionalSyncOptions\n): Promise<BidirectionalSyncResult> {\n  const startTime = Date.now();\n  const result: BidirectionalSyncResult = {\n    status: 'SUCCESS',\n    summary: {\n      airtableToSheets: { added: 0, updated: 0, deleted: 0 },\n      sheetsToAirtable: { added: 0, updated: 0, deleted: 0 },\n      conflicts: { total: 0, airtableWins: 0, sheetsWins: 0, deleted: 0, skipped: 0 },\n    },\n    phases: {\n      fetch: createPhaseResult('fetch'),\n      conflictDetection: createPhaseResult('conflictDetection'),\n      conflictResolution: createPhaseResult('conflictResolution'),\n      airtableToSheets: createPhaseResult('airtableToSheets'),\n      sheetsToAirtable: createPhaseResult('sheetsToAirtable'),\n      stateUpdate: createPhaseResult('stateUpdate'),\n    },\n    errors: [],\n    warnings: [],\n    duration: 0,\n    startedAt: new Date(),\n    completedAt: new Date(),\n    lastSyncAt: new Date(),\n  };\n\n  // Set defaults\n  const {\n    syncConfigId,\n    airtableAccessToken,\n    sheetsAccessToken,\n    baseId,\n    tableId,\n    viewId, // CRITICAL: Extract viewId for Airtable record ordering\n    spreadsheetId,\n    sheetId,\n    conflictResolution,\n    fieldMappings,\n    idColumnIndex = 0,\n    syncTimestampColumnIndex,\n    includeHeader = true,\n    resolveLinkedRecords: shouldResolveLinkedRecords = true,\n    createMissingLinkedRecords = false,\n    maxRetries = 3,\n    batchSize = 10,\n    dryRun = false,\n  } = options;\n\n  const checkpoint: SyncCheckpoint = {\n    airtableRecords: [],\n    sheetsRows: [],\n    tableFields: [],\n  };\n\n  // Track the actual ID column index (will be set after detecting last column)\n  let actualIdColumnIndex = idColumnIndex;\n\n  console.log(`\\n${'='.repeat(80)}`);\n  console.log(`[BidirectionalSync] Starting bidirectional sync for config: ${syncConfigId}`);\n  console.log(`[BidirectionalSync] Conflict resolution strategy: ${conflictResolution}`);\n  console.log(`[BidirectionalSync] Dry run: ${dryRun}`);\n  console.log(`${'='.repeat(80)}\\n`);\n\n  try {\n    // ========================================================================\n    // PHASE 1: FETCH CURRENT STATE FROM BOTH SOURCES\n    // ========================================================================\n    const fetchPhase = await executePhase('fetch', async () => {\n      console.log(`[Phase 1: Fetch] Fetching current state from Airtable and Sheets...`);\n\n      // 1.1: Fetch table schema FIRST (needed for primary field fallback ordering)\n      console.log(`[Phase 1: Fetch] Fetching table schema...`);\n      const schema = await retryWithBackoff(\n        () => getBaseSchema(airtableAccessToken, baseId),\n        maxRetries,\n        'fetch table schema'\n      );\n\n      const table = schema.tables.find((t) => t.id === tableId || t.name === tableId);\n      if (!table) {\n        throw new Error(`Table ${tableId} not found in base schema`);\n      }\n\n      checkpoint.tableFields = table.fields;\n\n      // Get primary field name for smart matching (when no record IDs available)\n      const primaryField = table.fields.find((f) => f.id === table.primaryFieldId);\n      if (primaryField) {\n        checkpoint.primaryFieldName = primaryField.name;\n        console.log(`[Phase 1: Fetch] Primary field for matching: \"${checkpoint.primaryFieldName}\"`);\n      }\n\n      // 1.2: Fetch Airtable records\n      // CRITICAL: Use viewId if provided to ensure records are fetched in the exact order\n      // shown in Airtable's UI. Without this, records come in an arbitrary order which\n      // causes the data in Sheets to be in a different order than Airtable.\n      console.log(`[Phase 1: Fetch] Fetching Airtable records...`);\n\n      // Build fetch options for consistent ordering\n      // Priority: 1) View (exact UI order), 2) Primary field sort (alphabetical), 3) Default\n      const listRecordsOptions: { view?: string; sort?: Array<{ field: string; direction: 'asc' | 'desc' }> } = {};\n\n      if (viewId) {\n        // Use view for EXACT order matching Airtable UI\n        listRecordsOptions.view = viewId;\n        console.log(`[Phase 1: Fetch] Using view \"${viewId}\" for exact row ordering`);\n      } else if (checkpoint.primaryFieldName) {\n        // Fallback to sorting by primary field for consistent alphabetical order\n        listRecordsOptions.sort = [{ field: checkpoint.primaryFieldName, direction: 'asc' }];\n        console.log(`[Phase 1: Fetch] Sorting by primary field \"${checkpoint.primaryFieldName}\" for consistent order`);\n      } else {\n        console.warn(`[Phase 1: Fetch] No view or primary field - order may be unpredictable`);\n      }\n\n      checkpoint.airtableRecords = await retryWithBackoff(\n        () => listRecords(airtableAccessToken, baseId, tableId, listRecordsOptions),\n        maxRetries,\n        'fetch Airtable records'\n      );\n      console.log(`[Phase 1: Fetch] âœ“ Fetched ${checkpoint.airtableRecords.length} Airtable records`);\n\n      // Apply field mappings if provided\n      if (fieldMappings && Object.keys(fieldMappings).length > 0) {\n        const mappedFieldIds = Object.keys(fieldMappings);\n        checkpoint.tableFields = checkpoint.tableFields.filter((f) =>\n          mappedFieldIds.includes(f.id)\n        );\n        checkpoint.tableFields.sort(\n          (a, b) => (fieldMappings[a.id] || 0) - (fieldMappings[b.id] || 0)\n        );\n      }\n\n      console.log(`[Phase 1: Fetch] âœ“ Found ${checkpoint.tableFields.length} fields`);\n\n      // 1.3: Resolve linked records in Airtable data\n      if (shouldResolveLinkedRecords && checkpoint.airtableRecords.length > 0) {\n        console.log(`[Phase 1: Fetch] Resolving linked records...`);\n        const resolved = await resolveAllLinkedRecords(\n          airtableAccessToken,\n          baseId,\n          tableId,\n          checkpoint.airtableRecords,\n          { strictMode: false }\n        );\n        checkpoint.airtableRecords = resolved.records;\n\n        if (resolved.warnings.length > 0) {\n          return { warnings: resolved.warnings };\n        }\n\n        console.log(`[Phase 1: Fetch] âœ“ Linked records resolved`);\n      }\n\n      // 1.4: Fetch Sheets data\n      console.log(`[Phase 1: Fetch] Fetching Sheets data...`);\n      const sheetData = await retryWithBackoff(\n        () => getSheetData(sheetsAccessToken, spreadsheetId, sheetId),\n        maxRetries,\n        'fetch Sheets data'\n      );\n\n      checkpoint.sheetsRows = sheetData.values || [];\n\n      // CRITICAL: ALWAYS use a fixed far-right column for IDs to avoid shifting user's visible columns\n      // We use column AA (index 26) by default - far enough that it won't interfere with typical data\n      // This applies to EVERY sync, regardless of whether data exists or not\n      if (idColumnIndex === 0) {\n        const FIXED_ID_COLUMN_INDEX = 26; // Column AA (A=0, B=1, ..., Z=25, AA=26)\n        actualIdColumnIndex = FIXED_ID_COLUMN_INDEX;\n\n        const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n\n        console.log(\n          `[Phase 1: Fetch] Using fixed column ${columnLetter} (index ${actualIdColumnIndex}) for record IDs (will be hidden)`\n        );\n      }\n\n      // Skip header row if configured\n      if (includeHeader && checkpoint.sheetsRows.length > 0) {\n        checkpoint.sheetsRows = checkpoint.sheetsRows.slice(1);\n      }\n\n      console.log(`[Phase 1: Fetch] âœ“ Fetched ${checkpoint.sheetsRows.length} Sheets rows`);\n\n      return {\n        metadata: {\n          airtableRecords: checkpoint.airtableRecords.length,\n          sheetsRows: checkpoint.sheetsRows.length,\n          fields: checkpoint.tableFields.length,\n        },\n      };\n    });\n\n    result.phases.fetch = fetchPhase;\n    if (fetchPhase.status === 'FAILED') {\n      result.status = 'FAILED';\n      return finalizeSyncResult(result, startTime);\n    }\n\n    // ========================================================================\n    // PHASE 2: DETECT CHANGES AND CONFLICTS\n    // ========================================================================\n    const conflictDetectionPhase = await executePhase('conflictDetection', async () => {\n      console.log(`\\n[Phase 2: Conflict Detection] Detecting changes and conflicts...`);\n\n      checkpoint.conflictResults = detectConflicts(\n        checkpoint.airtableRecords,\n        checkpoint.sheetsRows,\n        syncConfigId,\n        actualIdColumnIndex\n      );\n\n      const summary = summarizeConflicts(checkpoint.conflictResults);\n      console.log(`[Phase 2: Conflict Detection] ${summary.summary}`);\n\n      if (checkpoint.conflictResults.conflicts.length > 0) {\n        console.log(\n          `[Phase 2: Conflict Detection] âš ï¸  ${checkpoint.conflictResults.conflicts.length} conflicts detected`\n        );\n      }\n\n      return {\n        metadata: {\n          conflicts: checkpoint.conflictResults.conflicts.length,\n          airtableOnlyChanges: checkpoint.conflictResults.airtableOnlyChanges.length,\n          sheetsOnlyChanges: checkpoint.conflictResults.sheetsOnlyChanges.length,\n          newInAirtable: checkpoint.conflictResults.newInAirtable.length,\n          newInSheets: checkpoint.conflictResults.newInSheets.length,\n          noChanges: checkpoint.conflictResults.noChanges.length,\n        },\n      };\n    });\n\n    result.phases.conflictDetection = conflictDetectionPhase;\n\n    // ========================================================================\n    // PHASE 3: RESOLVE CONFLICTS\n    // ========================================================================\n    if (checkpoint.conflictResults && checkpoint.conflictResults.conflicts.length > 0) {\n      const conflictResolutionPhase = await executePhase('conflictResolution', async () => {\n        console.log(\n          `\\n[Phase 3: Conflict Resolution] Resolving ${checkpoint.conflictResults!.conflicts.length} conflicts...`\n        );\n        console.log(`[Phase 3: Conflict Resolution] Strategy: ${conflictResolution}`);\n\n        checkpoint.conflictResolutions = resolveConflicts(\n          checkpoint.conflictResults!.conflicts,\n          conflictResolution\n        );\n\n        // Count resolutions by type\n        const resolutionCounts = {\n          USE_AIRTABLE: 0,\n          USE_SHEETS: 0,\n          DELETE: 0,\n          SKIP: 0,\n        };\n\n        checkpoint.conflictResolutions.forEach((resolution) => {\n          resolutionCounts[resolution.action]++;\n          console.log(\n            `[Phase 3: Conflict Resolution]   ${resolution.recordId}: ${resolution.action} (${resolution.reason})`\n          );\n        });\n\n        result.summary.conflicts.total = checkpoint.conflictResolutions.length;\n        result.summary.conflicts.airtableWins = resolutionCounts.USE_AIRTABLE;\n        result.summary.conflicts.sheetsWins = resolutionCounts.USE_SHEETS;\n        result.summary.conflicts.deleted = resolutionCounts.DELETE;\n        result.summary.conflicts.skipped = resolutionCounts.SKIP;\n\n        return { metadata: resolutionCounts };\n      });\n\n      result.phases.conflictResolution = conflictResolutionPhase;\n    } else {\n      result.phases.conflictResolution.status = 'SKIPPED';\n      console.log(`\\n[Phase 3: Conflict Resolution] No conflicts to resolve`);\n    }\n\n    // ========================================================================\n    // PHASE 4: PUSH AIRTABLE CHANGES TO SHEETS\n    // ========================================================================\n    const airtableToSheetsPhase = await executePhase('airtableToSheets', async () => {\n      console.log(`\\n[Phase 4: Airtable â†’ Sheets] Syncing Airtable changes to Sheets...`);\n\n      if (!checkpoint.conflictResults) {\n        throw new Error('Conflict results not available');\n      }\n\n      // Determine which records to sync from Airtable\n      const recordsToSync = new Set<string>([\n        ...checkpoint.conflictResults.airtableOnlyChanges,\n        ...checkpoint.conflictResults.newInAirtable,\n      ]);\n\n      // Add conflict resolutions that favor Airtable\n      if (checkpoint.conflictResolutions) {\n        checkpoint.conflictResolutions.forEach((resolution) => {\n          if (resolution.action === 'USE_AIRTABLE') {\n            recordsToSync.add(resolution.recordId);\n          }\n        });\n      }\n\n      if (recordsToSync.size === 0) {\n        console.log(`[Phase 4: Airtable â†’ Sheets] No changes to sync`);\n        return { metadata: { synced: 0 } };\n      }\n\n      console.log(`[Phase 4: Airtable â†’ Sheets] Syncing ${recordsToSync.size} records...`);\n\n      if (dryRun) {\n        console.log(`[Phase 4: Airtable â†’ Sheets] DRY RUN - Would sync ${recordsToSync.size} records`);\n        return { metadata: { synced: recordsToSync.size, dryRun: true } };\n      }\n\n      // Transform and update Sheets\n      const recordsToUpdate = checkpoint.airtableRecords.filter((r) => recordsToSync.has(r.id));\n\n      let added = 0;\n      let updated = 0;\n      const phaseErrors: SyncError[] = [];\n\n      // Track which rows need record IDs written to column AA\n      const rowsNeedingRecordIds: Array<{ rowNumber: number; recordId: string }> = [];\n\n      for (const record of recordsToUpdate) {\n        try {\n          const { row } = await airtableRecordToSheetsRow(record, checkpoint.tableFields, {\n            accessToken: airtableAccessToken,\n            baseId,\n            tableId,\n          });\n\n          // Find if row exists in Sheets\n          const existingRowIndex = checkpoint.sheetsRows.findIndex(\n            (r) => r[actualIdColumnIndex] === record.id\n          );\n\n          if (existingRowIndex >= 0) {\n            // Update existing row with just the data (no record ID in the array)\n            const rowNumber = existingRowIndex + (includeHeader ? 2 : 1);\n            await retryWithBackoff(\n              () =>\n                updateSheetData(sheetsAccessToken, spreadsheetId, sheetId, `A${rowNumber}`, [\n                  row,\n                ]),\n              maxRetries,\n              `update row ${rowNumber}`,\n              { recordId: record.id, phase: 'airtableToSheets' }\n            );\n            updated++;\n            rowsNeedingRecordIds.push({ rowNumber, recordId: record.id });\n          } else {\n            // Append new row with just the data (no record ID in the array)\n            await retryWithBackoff(\n              () => appendRows(sheetsAccessToken, spreadsheetId, sheetId, [row]),\n              maxRetries,\n              `append row for ${record.id}`,\n              { recordId: record.id, phase: 'airtableToSheets' }\n            );\n            added++;\n            // Calculate row number for newly appended row\n            const newRowNumber = checkpoint.sheetsRows.length + added + (includeHeader ? 1 : 0);\n            rowsNeedingRecordIds.push({ rowNumber: newRowNumber, recordId: record.id });\n          }\n        } catch (error) {\n          // Log error but continue with other records\n          const syncError = classifyError(error, 'airtableToSheets', record.id);\n          phaseErrors.push(syncError);\n          console.error(\n            `[Phase 4: Airtable â†’ Sheets] âœ— Failed to sync record ${record.id}: ${syncError.message}`\n          );\n\n          // If it's an OAuth error, stop the entire sync\n          if (syncError.type === 'OAUTH') {\n            throw error;\n          }\n          // Otherwise, continue with next record\n        }\n      }\n\n      result.summary.airtableToSheets.added = added;\n      result.summary.airtableToSheets.updated = updated;\n\n      const totalAttempted = recordsToSync.size;\n      const totalSuccessful = added + updated;\n      const totalFailed = phaseErrors.length;\n\n      if (totalFailed > 0) {\n        console.log(\n          `[Phase 4: Airtable â†’ Sheets] âš ï¸  Synced ${totalSuccessful}/${totalAttempted} records (${totalFailed} failed)`\n        );\n      } else {\n        console.log(\n          `[Phase 4: Airtable â†’ Sheets] âœ“ Synced ${totalSuccessful} records (${added} added, ${updated} updated)`\n        );\n      }\n\n      // After syncing Airtable â†’ Sheets, write record IDs to column AA and hide it\n      if ((added > 0 || updated > 0) && !dryRun) {\n        try {\n          const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n\n          // STEP 1: Ensure column AA exists\n          // This prevents errors when the sheet only has columns A-Z (0-25)\n          const requiredColumnCount = actualIdColumnIndex + 1; // Need at least 27 columns for column AA (index 26)\n          console.log(\n            `[Phase 4: Airtable â†’ Sheets] Ensuring column ${columnLetter} exists (need ${requiredColumnCount} columns)...`\n          );\n          await ensureColumnsExist(sheetsAccessToken, spreadsheetId, sheetId, requiredColumnCount);\n\n          // STEP 2: Write record IDs to column AA\n          console.log(\n            `[Phase 4: Airtable â†’ Sheets] Writing ${rowsNeedingRecordIds.length} record IDs to column ${columnLetter}...`\n          );\n          for (const { rowNumber, recordId } of rowsNeedingRecordIds) {\n            const range = `${columnLetter}${rowNumber}`;\n            try {\n              await updateSheetData(sheetsAccessToken, spreadsheetId, sheetId, range, [[recordId]]);\n            } catch (error) {\n              console.warn(\n                `[Phase 4: Airtable â†’ Sheets] Failed to write record ID to ${range}:`,\n                error\n              );\n            }\n          }\n          console.log(`[Phase 4: Airtable â†’ Sheets] âœ“ Wrote record IDs to column ${columnLetter}`);\n\n          // STEP 3: Hide column AA to keep sheets clean for users\n          console.log(`[Phase 4: Airtable â†’ Sheets] Hiding ID column ${columnLetter}...`);\n          await hideColumn(sheetsAccessToken, spreadsheetId, sheetId, actualIdColumnIndex);\n          console.log(\n            `[Phase 4: Airtable â†’ Sheets] âœ“ Hidden column ${columnLetter} (users won't see record IDs)`\n          );\n        } catch (error) {\n          console.warn('[Phase 4: Airtable â†’ Sheets] Failed to write/hide ID column:', error);\n        }\n      }\n\n      return {\n        metadata: { added, updated, failed: totalFailed },\n        errors: phaseErrors,\n      };\n    });\n\n    result.phases.airtableToSheets = airtableToSheetsPhase;\n\n    // ========================================================================\n    // PHASE 5: PUSH SHEETS CHANGES TO AIRTABLE\n    // ========================================================================\n    const sheetsToAirtablePhase = await executePhase('sheetsToAirtable', async () => {\n      console.log(`\\n[Phase 5: Sheets â†’ Airtable] Syncing Sheets changes to Airtable...`);\n\n      if (!checkpoint.conflictResults) {\n        throw new Error('Conflict results not available');\n      }\n\n      // Determine which rows to sync from Sheets\n      const rowsToSync = new Set<number>();\n\n      // Add rows that changed only in Sheets\n      for (const id of checkpoint.conflictResults.sheetsOnlyChanges) {\n        const rowIndex = checkpoint.sheetsRows.findIndex((r) => r[actualIdColumnIndex] === id);\n        if (rowIndex >= 0) {\n          rowsToSync.add(rowIndex);\n        }\n      }\n\n      // Add new rows in Sheets\n      // CRITICAL FIX: newInSheets can contain:\n      // 1. Row indices (when rows don't have record IDs)\n      // 2. Parsed from `row_X` identifiers\n      for (const item of checkpoint.conflictResults.newInSheets) {\n        // If it's a valid row index, use it directly\n        if (typeof item === 'number' && item >= 0 && item < checkpoint.sheetsRows.length) {\n          rowsToSync.add(item);\n        }\n      }\n\n      // Add conflict resolutions that favor Sheets\n      if (checkpoint.conflictResolutions) {\n        checkpoint.conflictResolutions.forEach((resolution) => {\n          if (resolution.action === 'USE_SHEETS') {\n            const rowIndex = checkpoint.sheetsRows.findIndex(\n              (r) => r[actualIdColumnIndex] === resolution.recordId\n            );\n            if (rowIndex >= 0) {\n              rowsToSync.add(rowIndex);\n            }\n          }\n        });\n      }\n\n      // Filter out invalid indices\n      const validRows = Array.from(rowsToSync).filter((i) => i >= 0 && i < checkpoint.sheetsRows.length);\n\n      if (validRows.length === 0) {\n        console.log(`[Phase 5: Sheets â†’ Airtable] No changes to sync`);\n        return { metadata: { synced: 0 } };\n      }\n\n      console.log(`[Phase 5: Sheets â†’ Airtable] Syncing ${validRows.length} rows...`);\n\n      if (dryRun) {\n        console.log(`[Phase 5: Sheets â†’ Airtable] DRY RUN - Would sync ${validRows.length} rows`);\n        return { metadata: { synced: validRows.length, dryRun: true } };\n      }\n\n      // Preload linked record caches\n      if (shouldResolveLinkedRecords) {\n        const linkedFields = checkpoint.tableFields.filter((f) => f.type === 'multipleRecordLinks');\n        for (const field of linkedFields) {\n          const linkedTableId = field.options?.linkedTableId;\n          if (linkedTableId) {\n            await preloadTableCache(airtableAccessToken, baseId, linkedTableId);\n          }\n        }\n      }\n\n      let added = 0;\n      let updated = 0;\n      const phaseErrors: SyncError[] = [];\n      const newRecordIdUpdates: Array<{ row: number; recordId: string }> = [];\n\n      // Process rows in batches of 10 (Airtable limit)\n      const batchedRows = chunkArray(validRows, Math.min(batchSize, 10));\n\n      for (const batchIndices of batchedRows) {\n        const recordsToCreate: any[] = [];\n        const recordsToUpdate: any[] = [];\n        const rowMetadata: Map<number, { recordId?: string; rowIndex: number }> = new Map();\n\n        for (const rowIndex of batchIndices) {\n          try {\n            const row = checkpoint.sheetsRows[rowIndex];\n            const recordId = row[actualIdColumnIndex] ? String(row[actualIdColumnIndex]).trim() : undefined;\n\n            // Remove ID column from data\n            const dataRow = [...row];\n            dataRow.splice(actualIdColumnIndex, 1);\n\n            // Transform to Airtable fields\n            const { fields } = await sheetsRowToAirtableFields(dataRow, checkpoint.tableFields, {\n              accessToken: airtableAccessToken,\n              baseId,\n              tableId,\n            });\n\n            let matchedRecord: AirtableRecord | undefined;\n\n            // Strategy 1: Match by record ID (if available)\n            if (recordId) {\n              matchedRecord = checkpoint.airtableRecords.find((r) => r.id === recordId);\n            }\n\n            // Strategy 2: Match by primary field (fallback when no ID)\n            if (!matchedRecord && !recordId && checkpoint.primaryFieldName && fields[checkpoint.primaryFieldName]) {\n              const primaryValue = String(fields[checkpoint.primaryFieldName]).trim().toLowerCase();\n              if (primaryValue) {\n                matchedRecord = checkpoint.airtableRecords.find((r) => {\n                  const recordPrimaryValue = r.fields[checkpoint.primaryFieldName!];\n                  return recordPrimaryValue &&\n                         String(recordPrimaryValue).trim().toLowerCase() === primaryValue;\n                });\n\n                if (matchedRecord) {\n                  console.log(\n                    `[Phase 5: Sheets â†’ Airtable] Matched row ${rowIndex} to existing record ${matchedRecord.id} by primary field \"${checkpoint.primaryFieldName}\"`\n                  );\n                }\n              }\n            }\n\n            if (matchedRecord) {\n              // Update existing record (matched by ID or primary field)\n              const updateIndex = recordsToUpdate.length;\n              recordsToUpdate.push({ id: matchedRecord.id, fields });\n              rowMetadata.set(updateIndex, { recordId: matchedRecord.id, rowIndex });\n            } else {\n              // Create new record\n              const createIndex = recordsToCreate.length;\n              recordsToCreate.push({ fields });\n              rowMetadata.set(createIndex, { rowIndex });\n            }\n          } catch (error) {\n            // Log transformation error but continue with other rows\n            const syncError = classifyError(error, 'sheetsToAirtable', undefined, rowIndex);\n            phaseErrors.push(syncError);\n            console.error(\n              `[Phase 5: Sheets â†’ Airtable] âœ— Failed to transform row ${rowIndex}: ${syncError.message}`\n            );\n          }\n        }\n\n        // Execute batch operations with error handling\n        if (recordsToCreate.length > 0) {\n          try {\n            const created = await retryWithBackoff(\n              () => createRecords(airtableAccessToken, baseId, tableId, recordsToCreate),\n              maxRetries,\n              'create records batch',\n              { phase: 'sheetsToAirtable' }\n            );\n            added += created.length;\n\n            // Track new record IDs to write back to Sheets\n            for (let i = 0; i < created.length; i++) {\n              const createdRecord = created[i];\n              const metadata = Array.from(rowMetadata.values())[i];\n              if (metadata && !metadata.recordId && createdRecord.id) {\n                // This was a new record - track its ID and row number\n                const sheetRowNumber = metadata.rowIndex + (includeHeader ? 2 : 1);\n                newRecordIdUpdates.push({ row: sheetRowNumber, recordId: createdRecord.id });\n              }\n            }\n          } catch (error) {\n            // Batch create failed - log error for all records in batch\n            const syncError = classifyError(error, 'sheetsToAirtable');\n            phaseErrors.push(syncError);\n            console.error(\n              `[Phase 5: Sheets â†’ Airtable] âœ— Failed to create ${recordsToCreate.length} records: ${syncError.message}`\n            );\n\n            // If it's an OAuth error, stop the entire sync\n            if (syncError.type === 'OAUTH') {\n              throw error;\n            }\n          }\n        }\n\n        if (recordsToUpdate.length > 0) {\n          try {\n            const updated_batch = await retryWithBackoff(\n              () => updateRecords(airtableAccessToken, baseId, tableId, recordsToUpdate),\n              maxRetries,\n              'update records batch',\n              { phase: 'sheetsToAirtable' }\n            );\n            updated += updated_batch.length;\n          } catch (error) {\n            // Batch update failed - log error for all records in batch\n            const syncError = classifyError(error, 'sheetsToAirtable');\n            phaseErrors.push(syncError);\n            console.error(\n              `[Phase 5: Sheets â†’ Airtable] âœ— Failed to update ${recordsToUpdate.length} records: ${syncError.message}`\n            );\n\n            // If it's an OAuth error, stop the entire sync\n            if (syncError.type === 'OAUTH') {\n              throw error;\n            }\n          }\n        }\n      }\n\n      result.summary.sheetsToAirtable.added = added;\n      result.summary.sheetsToAirtable.updated = updated;\n\n      const totalAttempted = validRows.length;\n      const totalSuccessful = added + updated;\n      const totalFailed = phaseErrors.length;\n\n      if (totalFailed > 0) {\n        console.log(\n          `[Phase 5: Sheets â†’ Airtable] âš ï¸  Synced ${totalSuccessful}/${totalAttempted} records (${totalFailed} failed)`\n        );\n      } else {\n        console.log(\n          `[Phase 5: Sheets â†’ Airtable] âœ“ Synced ${totalSuccessful} records (${added} added, ${updated} updated)`\n        );\n      }\n\n      // Write new record IDs back to Google Sheets to prevent duplicates on next sync\n      if (newRecordIdUpdates.length > 0 && !dryRun) {\n        console.log(\n          `[Phase 5: Sheets â†’ Airtable] Writing ${newRecordIdUpdates.length} new record IDs back to Sheets...`\n        );\n\n        try {\n          const columnLetter = columnNumberToLetter(actualIdColumnIndex + 1);\n\n          // STEP 1: Ensure column AA exists before writing to it\n          // This prevents errors when the sheet only has columns A-Z (0-25)\n          const requiredColumnCount = actualIdColumnIndex + 1; // Need at least 27 columns for column AA (index 26)\n          console.log(\n            `[Phase 5: Sheets â†’ Airtable] Ensuring column ${columnLetter} exists (need ${requiredColumnCount} columns)...`\n          );\n          await ensureColumnsExist(sheetsAccessToken, spreadsheetId, sheetId, requiredColumnCount);\n\n          // STEP 2: Write record IDs to column AA\n          // Sort by row number\n          newRecordIdUpdates.sort((a, b) => a.row - b.row);\n\n          // Update each row's ID column\n          const updatePromises: Promise<any>[] = [];\n\n          for (const update of newRecordIdUpdates) {\n            const range = `${columnLetter}${update.row}`;\n\n            updatePromises.push(\n              updateSheetData(\n                sheetsAccessToken,\n                spreadsheetId,\n                sheetId,\n                range,\n                [[update.recordId]]\n              ).catch((error) => {\n                console.warn(\n                  `[Phase 5: Sheets â†’ Airtable] Failed to write ID for row ${update.row}:`,\n                  error\n                );\n              })\n            );\n\n            // Batch updates to avoid rate limits\n            if (updatePromises.length >= 10) {\n              await Promise.all(updatePromises);\n              updatePromises.length = 0;\n              await new Promise((resolve) => setTimeout(resolve, 100));\n            }\n          }\n\n          // Process remaining updates\n          if (updatePromises.length > 0) {\n            await Promise.all(updatePromises);\n          }\n\n          console.log(\n            `[Phase 5: Sheets â†’ Airtable] âœ“ Successfully wrote ${newRecordIdUpdates.length} record IDs to column ${columnLetter}`\n          );\n\n          // STEP 3: Hide column AA to keep sheets clean for users\n          try {\n            await hideColumn(sheetsAccessToken, spreadsheetId, sheetId, actualIdColumnIndex);\n            console.log(\n              `[Phase 5: Sheets â†’ Airtable] âœ“ Hidden column ${columnLetter} (users won't see record IDs)`\n            );\n          } catch (error) {\n            console.warn('[Phase 5: Sheets â†’ Airtable] Failed to hide ID column:', error);\n          }\n        } catch (error) {\n          console.error('[Phase 5: Sheets â†’ Airtable] Error writing IDs back to Sheets:', error);\n        }\n      }\n\n      return {\n        metadata: { added, updated, failed: totalFailed },\n        errors: phaseErrors,\n      };\n    });\n\n    result.phases.sheetsToAirtable = sheetsToAirtablePhase;\n\n    // ========================================================================\n    // PHASE 6: UPDATE SYNC STATE\n    // ========================================================================\n    const stateUpdatePhase = await executePhase('stateUpdate', async () => {\n      console.log(`\\n[Phase 6: State Update] Updating sync state...`);\n\n      if (dryRun) {\n        console.log(`[Phase 6: State Update] DRY RUN - Would update sync state`);\n        return { metadata: { dryRun: true } };\n      }\n\n      // Re-fetch current state to update sync checkpoint\n      // CRITICAL: Use viewId or primary field to maintain consistent ordering for state tracking\n      const stateListOptions: { view?: string; sort?: Array<{ field: string; direction: 'asc' | 'desc' }> } = {};\n      if (viewId) {\n        stateListOptions.view = viewId;\n      } else if (checkpoint.primaryFieldName) {\n        stateListOptions.sort = [{ field: checkpoint.primaryFieldName, direction: 'asc' }];\n      }\n      const updatedRecords = await listRecords(airtableAccessToken, baseId, tableId, stateListOptions);\n      const updatedSheetData = await getSheetData(sheetsAccessToken, spreadsheetId, sheetId);\n      const updatedRows = (updatedSheetData.values || []).slice(includeHeader ? 1 : 0);\n\n      updateSyncState(syncConfigId, updatedRecords, updatedRows, actualIdColumnIndex);\n\n      result.lastSyncAt = new Date();\n\n      console.log(`[Phase 6: State Update] âœ“ Sync state updated`);\n\n      return { metadata: { timestamp: result.lastSyncAt.toISOString() } };\n    });\n\n    result.phases.stateUpdate = stateUpdatePhase;\n\n    // ========================================================================\n    // FINALIZE RESULT\n    // ========================================================================\n\n    // Determine overall status\n    const hasErrors = Object.values(result.phases).some((p) => p.errors.length > 0);\n    const hasCriticalFailure = Object.values(result.phases).some((p) => p.status === 'FAILED');\n\n    if (hasCriticalFailure) {\n      result.status = 'FAILED';\n    } else if (hasErrors) {\n      result.status = 'PARTIAL';\n    } else {\n      result.status = 'SUCCESS';\n    }\n\n    // Aggregate errors and warnings\n    Object.values(result.phases).forEach((phase) => {\n      result.errors.push(...phase.errors);\n      result.warnings.push(...phase.warnings);\n    });\n\n    console.log(`\\n${'='.repeat(80)}`);\n    console.log(`[BidirectionalSync] Sync complete - Status: ${result.status}`);\n    console.log(\n      `[BidirectionalSync] Airtable â†’ Sheets: ${result.summary.airtableToSheets.added} added, ${result.summary.airtableToSheets.updated} updated`\n    );\n    console.log(\n      `[BidirectionalSync] Sheets â†’ Airtable: ${result.summary.sheetsToAirtable.added} added, ${result.summary.sheetsToAirtable.updated} updated`\n    );\n    console.log(\n      `[BidirectionalSync] Conflicts: ${result.summary.conflicts.total} resolved`\n    );\n    console.log(`[BidirectionalSync] Errors: ${result.errors.length}, Warnings: ${result.warnings.length}`);\n    console.log(`${'='.repeat(80)}\\n`);\n\n    const finalResult = finalizeSyncResult(result, startTime);\n\n    // Save results to database (including error info for dashboard)\n    await saveSyncResults(syncConfigId, finalResult);\n\n    return finalResult;\n  } catch (error) {\n    console.error(`\\n[BidirectionalSync] Fatal error:`, error);\n    console.error(`[BidirectionalSync] Error type:`, error?.constructor?.name);\n    console.error(`[BidirectionalSync] Error message:`, error instanceof Error ? error.message : String(error));\n    console.error(`[BidirectionalSync] Error stack:`, error instanceof Error ? error.stack : 'No stack trace');\n\n    // Log full error object for debugging\n    if (error && typeof error === 'object') {\n      console.error(`[BidirectionalSync] Error details:`, JSON.stringify(error, Object.getOwnPropertyNames(error), 2));\n    }\n\n    result.status = 'FAILED';\n\n    // Classify the fatal error\n    const syncError = classifyError(error, 'sync');\n    result.errors.push(syncError);\n\n    const finalResult = finalizeSyncResult(result, startTime);\n\n    // Save results to database (including error info for dashboard)\n    await saveSyncResults(syncConfigId, finalResult);\n\n    return finalResult;\n  }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Creates a new phase result\n */\nfunction createPhaseResult(phase: string): PhaseResult {\n  return {\n    phase,\n    status: 'SUCCESS',\n    duration: 0,\n    errors: [],\n    warnings: [],\n  };\n}\n\n/**\n * Executes a sync phase with error handling and timing\n */\nasync function executePhase(\n  phaseName: string,\n  fn: () => Promise<{ errors?: SyncError[]; warnings?: string[]; metadata?: any }>\n): Promise<PhaseResult> {\n  const startTime = Date.now();\n  const result = createPhaseResult(phaseName);\n\n  try {\n    const phaseResult = await fn();\n\n    if (phaseResult.errors && phaseResult.errors.length > 0) {\n      result.errors.push(...phaseResult.errors);\n      result.status = 'FAILED';\n    }\n\n    if (phaseResult.warnings && phaseResult.warnings.length > 0) {\n      result.warnings.push(...phaseResult.warnings);\n    }\n\n    if (phaseResult.metadata) {\n      result.metadata = phaseResult.metadata;\n    }\n  } catch (error) {\n    result.status = 'FAILED';\n    result.errors.push({\n      phase: phaseName,\n      type: 'UNKNOWN',\n      message: `Phase failed: ${error instanceof Error ? error.message : String(error)}`,\n      originalError: error,\n    });\n  }\n\n  result.duration = Date.now() - startTime;\n  return result;\n}\n\n/**\n * Classifies an error into a SyncError with appropriate type and metadata\n */\nfunction classifyError(\n  error: unknown,\n  phase: string,\n  recordId?: string,\n  rowNumber?: number\n): SyncError {\n  const errorMessage = error instanceof Error ? error.message : String(error);\n  const lowerMessage = errorMessage.toLowerCase();\n\n  // Detect OAuth/authentication errors\n  const oauthPatterns = [\n    'invalid_grant',\n    'refresh token',\n    'revoked',\n    'unauthorized',\n    'invalid_client',\n    'please reconnect',\n    'needs reauthorization',\n    '401',\n    'authentication failed',\n    'token expired',\n  ];\n\n  if (oauthPatterns.some((pattern) => lowerMessage.includes(pattern))) {\n    return {\n      phase,\n      recordId,\n      rowNumber,\n      message: 'OAuth token invalid or expired. Please reconnect your account.',\n      type: 'OAUTH',\n      originalError: error,\n      recoverable: false,\n    };\n  }\n\n  // Detect rate limit errors\n  const rateLimitPatterns = ['rate limit', 'quota', '429', 'too many requests'];\n\n  if (rateLimitPatterns.some((pattern) => lowerMessage.includes(pattern))) {\n    return {\n      phase,\n      recordId,\n      rowNumber,\n      message: 'API rate limit exceeded. Will retry with backoff.',\n      type: 'RATE_LIMIT',\n      originalError: error,\n      recoverable: true,\n    };\n  }\n\n  // Detect network errors\n  const networkPatterns = [\n    'network',\n    'econnrefused',\n    'enotfound',\n    'etimedout',\n    'fetch failed',\n    'socket',\n    'connection',\n    'dns',\n  ];\n\n  if (networkPatterns.some((pattern) => lowerMessage.includes(pattern))) {\n    return {\n      phase,\n      recordId,\n      rowNumber,\n      message: 'Network error. Will retry.',\n      type: 'NETWORK',\n      originalError: error,\n      recoverable: true,\n    };\n  }\n\n  // Detect validation errors\n  const validationPatterns = [\n    'invalid',\n    'validation',\n    'required field',\n    'type mismatch',\n    'schema',\n    'format',\n  ];\n\n  if (validationPatterns.some((pattern) => lowerMessage.includes(pattern))) {\n    return {\n      phase,\n      recordId,\n      rowNumber,\n      message: errorMessage,\n      type: 'VALIDATION',\n      originalError: error,\n      recoverable: false,\n    };\n  }\n\n  // Default to unknown error\n  return {\n    phase,\n    recordId,\n    rowNumber,\n    message: errorMessage,\n    type: 'UNKNOWN',\n    originalError: error,\n    recoverable: true,\n  };\n}\n\n/**\n * Retries a function with exponential backoff\n */\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number,\n  operation: string,\n  context?: { recordId?: string; rowNumber?: number; phase?: string }\n): Promise<T> {\n  let lastError: Error | undefined;\n  let retryCount = 0;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      retryCount = attempt;\n\n      // Classify the error\n      const syncError = classifyError(\n        error,\n        context?.phase || 'retry',\n        context?.recordId,\n        context?.rowNumber\n      );\n\n      // Don't retry OAuth errors - these need user intervention\n      if (syncError.type === 'OAUTH') {\n        console.error(`[RetryBackoff] ${operation} failed with OAuth error - stopping retry`);\n        throw lastError;\n      }\n\n      // Don't retry validation errors - data is bad\n      if (syncError.type === 'VALIDATION') {\n        console.error(`[RetryBackoff] ${operation} failed with validation error - stopping retry`);\n        throw lastError;\n      }\n\n      // Check if we should retry\n      if (attempt === maxRetries) break;\n\n      // Only retry rate limit and network errors after first attempt\n      const shouldRetry = syncError.type === 'RATE_LIMIT' || syncError.type === 'NETWORK';\n\n      if (!shouldRetry && attempt > 0) {\n        console.warn(`[RetryBackoff] ${operation} failed with non-retryable error type: ${syncError.type}`);\n        break;\n      }\n\n      // Calculate delay with exponential backoff\n      const baseDelay = syncError.type === 'RATE_LIMIT' ? 2000 : 1000;\n      const delay = Math.min(baseDelay * Math.pow(2, attempt), 30000) + Math.random() * 1000;\n\n      console.warn(\n        `[RetryBackoff] ${operation} failed (attempt ${attempt + 1}/${maxRetries + 1}) - ${syncError.type}, ` +\n          `retrying in ${Math.round(delay)}ms...`\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Chunks an array into smaller arrays\n */\nfunction chunkArray<T>(array: T[], size: number): T[][] {\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n/**\n * Finalizes the sync result\n */\nfunction finalizeSyncResult(\n  result: BidirectionalSyncResult,\n  startTime: number\n): BidirectionalSyncResult {\n  result.duration = Date.now() - startTime;\n  result.completedAt = new Date();\n  return result;\n}\n\n/**\n * Marks OAuth connections as needing reauth if OAuth errors occurred\n */\nasync function handleOAuthErrors(syncConfigId: string, errors: SyncError[]): Promise<void> {\n  const oauthErrors = errors.filter((e) => e.type === 'OAUTH');\n  if (oauthErrors.length === 0) return;\n\n  try {\n    // Get the sync config to find the user\n    const syncConfig = await prisma.syncConfig.findUnique({\n      where: { id: syncConfigId },\n      select: { userId: true },\n    });\n\n    if (!syncConfig) {\n      console.error(`[HandleOAuthErrors] SyncConfig ${syncConfigId} not found`);\n      return;\n    }\n\n    const userId = syncConfig.userId;\n    const now = new Date();\n\n    // Mark both connections as needing reauth (we don't know which one failed)\n    // In a real scenario, we'd track which API call failed\n    const errorMessage = 'OAuth token invalid or expired during sync. Please reconnect.';\n\n    // Update Airtable connection\n    const airtableConn = await prisma.airtableConnection.findUnique({\n      where: { userId },\n    });\n\n    if (airtableConn) {\n      await prisma.airtableConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: true,\n          lastRefreshError: errorMessage,\n          lastRefreshAttempt: now,\n        },\n      });\n      console.warn(`[HandleOAuthErrors] Marked Airtable connection for user ${userId} as needing reauth`);\n    }\n\n    // Update Google Sheets connection\n    const googleConn = await prisma.googleSheetsConnection.findUnique({\n      where: { userId },\n    });\n\n    if (googleConn) {\n      await prisma.googleSheetsConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: true,\n          lastRefreshError: errorMessage,\n          lastRefreshAttempt: now,\n        },\n      });\n      console.warn(`[HandleOAuthErrors] Marked Google connection for user ${userId} as needing reauth`);\n    }\n  } catch (error) {\n    console.error(`[HandleOAuthErrors] Failed to mark connections as needing reauth:`, error);\n    // Don't throw - this is a non-critical operation\n  }\n}\n\n/**\n * Saves sync results to the database, including error information\n */\nasync function saveSyncResults(\n  syncConfigId: string,\n  result: BidirectionalSyncResult\n): Promise<void> {\n  try {\n    const now = new Date();\n\n    // Handle OAuth errors by marking connections as needing reauth\n    if (result.errors.some((e) => e.type === 'OAUTH')) {\n      await handleOAuthErrors(syncConfigId, result.errors);\n    }\n\n    // Prepare error message for dashboard (user-friendly)\n    let lastErrorMessage: string | null = null;\n    let lastErrorAt: Date | null = null;\n\n    if (result.errors.length > 0) {\n      lastErrorAt = now;\n\n      // Group errors by type\n      const errorsByType = result.errors.reduce((acc, err) => {\n        acc[err.type] = (acc[err.type] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n      // Create user-friendly error summary\n      const errorSummary = Object.entries(errorsByType)\n        .map(([type, count]) => {\n          switch (type) {\n            case 'OAUTH':\n              return 'Authentication failed - please reconnect your account';\n            case 'RATE_LIMIT':\n              return `Rate limit exceeded (${count} ${count === 1 ? 'error' : 'errors'})`;\n            case 'NETWORK':\n              return `Network errors (${count} ${count === 1 ? 'error' : 'errors'})`;\n            case 'VALIDATION':\n              return `Data validation errors (${count} ${count === 1 ? 'error' : 'errors'})`;\n            default:\n              return `${count} ${count === 1 ? 'error' : 'errors'}`;\n          }\n        })\n        .join('; ');\n\n      lastErrorMessage = errorSummary;\n\n      // If there's a critical OAuth error, use a more specific message\n      const oauthError = result.errors.find((e) => e.type === 'OAUTH');\n      if (oauthError) {\n        lastErrorMessage = 'Authentication failed - please reconnect your account in Settings';\n      }\n    }\n\n    // Update SyncConfig with results\n    await prisma.syncConfig.update({\n      where: { id: syncConfigId },\n      data: {\n        lastSyncAt: now,\n        lastSyncStatus: result.status.toLowerCase(),\n        lastErrorAt: lastErrorAt,\n        lastErrorMessage: lastErrorMessage,\n      },\n    });\n\n    console.log(`[SaveSyncResults] Updated SyncConfig ${syncConfigId} with status: ${result.status}`);\n  } catch (error) {\n    console.error(\n      `[SaveSyncResults] Failed to save sync results for config ${syncConfigId}:`,\n      error\n    );\n    // Don't throw - this is a non-critical operation\n  }\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport { createPhaseResult, executePhase, retryWithBackoff, chunkArray, classifyError };\n","/**\n * Centralized Token Management\n *\n * Handles OAuth token lifecycle for both Airtable and Google Sheets:\n * - Automatic token refresh before expiry\n * - Error handling and retry logic\n * - Connection status tracking\n * - User notifications for reauth needs\n */\n\nimport type { User, AirtableConnection, GoogleSheetsConnection } from 'wasp/entities';\nimport { prisma } from 'wasp/server';\nimport {\n  refreshAccessToken as refreshAirtableToken,\n  storeAirtableConnection,\n  getAirtableAccessToken as getAirtableTokenRaw,\n} from '../airtable/auth';\nimport {\n  refreshAccessToken as refreshGoogleToken,\n  storeGoogleSheetsConnection,\n  getGoogleSheetsAccessToken as getGoogleTokenRaw,\n} from '../google/auth';\nimport { decrypt } from '../airtable/encryption';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport type ConnectionType = 'airtable' | 'google';\n\nexport type ConnectionStatus = 'active' | 'expired' | 'needs_reauth' | 'revoked';\n\nexport interface TokenRefreshResult {\n  success: boolean;\n  accessToken?: string;\n  error?: string;\n  needsReauth: boolean;\n}\n\nexport interface ConnectionHealth {\n  type: ConnectionType;\n  status: ConnectionStatus;\n  expiresAt?: Date | null;\n  lastRefreshAttempt?: Date | null;\n  lastRefreshError?: string | null;\n  needsReauth: boolean;\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst TOKEN_EXPIRY_BUFFER_MS = 5 * 60 * 1000; // 5 minutes\nconst MAX_REFRESH_RETRIES = 3;\nconst REFRESH_RETRY_DELAY_MS = 1000; // 1 second between retries\n\n// Error messages that indicate reauth is needed\nconst REAUTH_ERROR_PATTERNS = [\n  'invalid_grant',\n  'refresh token',\n  'revoked',\n  'expired',\n  'unauthorized',\n  'invalid_client',\n  'Please reconnect',\n];\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Check if an error message indicates that reauth is required\n */\nfunction isReauthError(error: string): boolean {\n  const lowerError = error.toLowerCase();\n  return REAUTH_ERROR_PATTERNS.some((pattern) => lowerError.includes(pattern.toLowerCase()));\n}\n\n/**\n * Sleep for a specified duration\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Check if a token is expired or about to expire\n */\nfunction isTokenExpiringSoon(expiryDate: Date | null): boolean {\n  if (!expiryDate) {\n    return true; // No expiry date means we should refresh\n  }\n  const now = Date.now();\n  const expiryBuffer = now + TOKEN_EXPIRY_BUFFER_MS;\n  return expiryDate.getTime() <= expiryBuffer;\n}\n\n/**\n * Mark connection as needing reauth in the database\n */\nasync function markConnectionNeedsReauth(\n  userId: string,\n  type: ConnectionType,\n  errorMessage: string\n): Promise<void> {\n  const timestamp = new Date();\n\n  try {\n    if (type === 'airtable') {\n      await prisma.airtableConnection.update({\n        where: { userId },\n        data: {\n          lastRefreshError: errorMessage,\n          lastRefreshAttempt: timestamp,\n          needsReauth: true,\n        },\n      });\n    } else {\n      await prisma.googleSheetsConnection.update({\n        where: { userId },\n        data: {\n          lastRefreshError: errorMessage,\n          lastRefreshAttempt: timestamp,\n          needsReauth: true,\n        },\n      });\n    }\n\n    console.warn(`[TokenManager] Marked ${type} connection for user ${userId} as needing reauth: ${errorMessage}`);\n  } catch (dbError) {\n    console.error(`[TokenManager] Failed to mark ${type} connection as needing reauth:`, dbError);\n  }\n}\n\n/**\n * Clear reauth flag when connection is restored\n */\nasync function clearReauthFlag(userId: string, type: ConnectionType): Promise<void> {\n  try {\n    if (type === 'airtable') {\n      await prisma.airtableConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: false,\n          lastRefreshError: null,\n        },\n      });\n    } else {\n      await prisma.googleSheetsConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: false,\n          lastRefreshError: null,\n        },\n      });\n    }\n\n    console.log(`[TokenManager] Cleared reauth flag for ${type} connection for user ${userId}`);\n  } catch (dbError) {\n    console.error(`[TokenManager] Failed to clear reauth flag:`, dbError);\n  }\n}\n\n// ============================================================================\n// Token Refresh with Retry Logic\n// ============================================================================\n\n/**\n * Refresh an Airtable access token with retry logic\n */\nasync function refreshAirtableTokenWithRetry(\n  userId: string,\n  refreshToken: string,\n  retries: number = MAX_REFRESH_RETRIES\n): Promise<TokenRefreshResult> {\n  let lastError: Error | null = null;\n\n  for (let attempt = 1; attempt <= retries; attempt++) {\n    try {\n      console.log(`[TokenManager] Attempting to refresh Airtable token for user ${userId} (attempt ${attempt}/${retries})`);\n\n      const tokenResponse = await refreshAirtableToken(refreshToken);\n      await storeAirtableConnection(userId, tokenResponse, prisma);\n      await clearReauthFlag(userId, 'airtable');\n\n      console.log(`[TokenManager] âœ“ Successfully refreshed Airtable token for user ${userId}`);\n\n      return {\n        success: true,\n        accessToken: tokenResponse.access_token,\n        needsReauth: false,\n      };\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      const errorMessage = lastError.message;\n\n      console.error(`[TokenManager] âœ— Failed to refresh Airtable token (attempt ${attempt}/${retries}):`, errorMessage);\n\n      // Check if this is a reauth error (don't retry these)\n      if (isReauthError(errorMessage)) {\n        await markConnectionNeedsReauth(userId, 'airtable', errorMessage);\n        return {\n          success: false,\n          error: errorMessage,\n          needsReauth: true,\n        };\n      }\n\n      // If we have retries left and it's a network error, wait and retry\n      if (attempt < retries) {\n        await sleep(REFRESH_RETRY_DELAY_MS * attempt); // Exponential backoff\n      }\n    }\n  }\n\n  // All retries failed\n  const errorMessage = lastError?.message || 'Unknown error';\n  await markConnectionNeedsReauth(userId, 'airtable', `Failed after ${retries} attempts: ${errorMessage}`);\n\n  return {\n    success: false,\n    error: errorMessage,\n    needsReauth: true,\n  };\n}\n\n/**\n * Refresh a Google Sheets access token with retry logic\n */\nasync function refreshGoogleTokenWithRetry(\n  userId: string,\n  refreshToken: string,\n  retries: number = MAX_REFRESH_RETRIES\n): Promise<TokenRefreshResult> {\n  let lastError: Error | null = null;\n\n  for (let attempt = 1; attempt <= retries; attempt++) {\n    try {\n      console.log(`[TokenManager] Attempting to refresh Google token for user ${userId} (attempt ${attempt}/${retries})`);\n\n      const tokenResponse = await refreshGoogleToken(refreshToken);\n      await storeGoogleSheetsConnection(userId, tokenResponse, prisma);\n      await clearReauthFlag(userId, 'google');\n\n      console.log(`[TokenManager] âœ“ Successfully refreshed Google token for user ${userId}`);\n\n      return {\n        success: true,\n        accessToken: tokenResponse.access_token,\n        needsReauth: false,\n      };\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      const errorMessage = lastError.message;\n\n      console.error(`[TokenManager] âœ— Failed to refresh Google token (attempt ${attempt}/${retries}):`, errorMessage);\n\n      // Check if this is a reauth error (don't retry these)\n      if (isReauthError(errorMessage)) {\n        await markConnectionNeedsReauth(userId, 'google', errorMessage);\n        return {\n          success: false,\n          error: errorMessage,\n          needsReauth: true,\n        };\n      }\n\n      // If we have retries left and it's a network error, wait and retry\n      if (attempt < retries) {\n        await sleep(REFRESH_RETRY_DELAY_MS * attempt); // Exponential backoff\n      }\n    }\n  }\n\n  // All retries failed\n  const errorMessage = lastError?.message || 'Unknown error';\n  await markConnectionNeedsReauth(userId, 'google', `Failed after ${retries} attempts: ${errorMessage}`);\n\n  return {\n    success: false,\n    error: errorMessage,\n    needsReauth: true,\n  };\n}\n\n// ============================================================================\n// Public API - Token Management\n// ============================================================================\n\n/**\n * Get a valid Airtable access token for a user\n * Automatically refreshes if expired or about to expire\n *\n * @param userId - User ID\n * @returns Valid access token\n * @throws Error if token cannot be refreshed and reauth is needed\n */\nexport async function getValidAirtableToken(userId: string): Promise<string> {\n  console.log(`[TokenManager] Getting valid Airtable token for user ${userId}`);\n\n  const connection = await prisma.airtableConnection.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    throw new Error('Airtable connection not found. Please connect your Airtable account.');\n  }\n\n  // Check if connection is marked as needing reauth\n  if (connection.needsReauth) {\n    throw new Error(\n      `Airtable connection needs reauthorization. ${connection.lastRefreshError || 'Please reconnect your Airtable account.'}`\n    );\n  }\n\n  // Check if token is expired or about to expire\n  if (isTokenExpiringSoon(connection.tokenExpiry)) {\n    console.log(`[TokenManager] Airtable token expired or expiring soon, refreshing...`);\n\n    if (!connection.refreshToken) {\n      await markConnectionNeedsReauth(userId, 'airtable', 'No refresh token available');\n      throw new Error('Airtable refresh token not found. Please reconnect your Airtable account.');\n    }\n\n    const refreshResult = await refreshAirtableTokenWithRetry(userId, connection.refreshToken);\n\n    if (!refreshResult.success) {\n      throw new Error(\n        `Failed to refresh Airtable token: ${refreshResult.error}. Please reconnect your Airtable account.`\n      );\n    }\n\n    return refreshResult.accessToken!;\n  }\n\n  // Token is still valid, decrypt and return\n  console.log(`[TokenManager] Airtable token still valid, returning cached token`);\n  return decrypt(connection.accessToken);\n}\n\n/**\n * Get a valid Google Sheets access token for a user\n * Automatically refreshes if expired or about to expire\n *\n * @param userId - User ID\n * @returns Valid access token\n * @throws Error if token cannot be refreshed and reauth is needed\n */\nexport async function getValidGoogleToken(userId: string): Promise<string> {\n  console.log(`[TokenManager] Getting valid Google token for user ${userId}`);\n\n  const connection = await prisma.googleSheetsConnection.findUnique({\n    where: { userId },\n  });\n\n  if (!connection) {\n    throw new Error('Google Sheets connection not found. Please connect your Google account.');\n  }\n\n  // Check if connection is marked as needing reauth\n  if (connection.needsReauth) {\n    throw new Error(\n      `Google Sheets connection needs reauthorization. ${connection.lastRefreshError || 'Please reconnect your Google account.'}`\n    );\n  }\n\n  // Check if token is expired or about to expire\n  if (isTokenExpiringSoon(connection.tokenExpiry)) {\n    console.log(`[TokenManager] Google token expired or expiring soon, refreshing...`);\n\n    if (!connection.refreshToken) {\n      await markConnectionNeedsReauth(userId, 'google', 'No refresh token available');\n      throw new Error('Google refresh token not found. Please reconnect your Google account.');\n    }\n\n    const refreshResult = await refreshGoogleTokenWithRetry(userId, connection.refreshToken);\n\n    if (!refreshResult.success) {\n      throw new Error(\n        `Failed to refresh Google token: ${refreshResult.error}. Please reconnect your Google account.`\n      );\n    }\n\n    return refreshResult.accessToken!;\n  }\n\n  // Token is still valid, decrypt and return\n  console.log(`[TokenManager] Google token still valid, returning cached token`);\n  return decrypt(connection.accessToken);\n}\n\n/**\n * Get a valid token for either service\n * Convenience wrapper around getValidAirtableToken and getValidGoogleToken\n *\n * @param userId - User ID\n * @param type - Connection type ('airtable' or 'google')\n * @returns Valid access token\n */\nexport async function getValidToken(userId: string, type: ConnectionType): Promise<string> {\n  if (type === 'airtable') {\n    return getValidAirtableToken(userId);\n  } else {\n    return getValidGoogleToken(userId);\n  }\n}\n\n// ============================================================================\n// Connection Health Checks\n// ============================================================================\n\n/**\n * Get the health status of a connection\n *\n * @param userId - User ID\n * @param type - Connection type\n * @returns Connection health information\n */\nexport async function getConnectionHealth(\n  userId: string,\n  type: ConnectionType\n): Promise<ConnectionHealth | null> {\n  const connection =\n    type === 'airtable'\n      ? await prisma.airtableConnection.findUnique({ where: { userId } })\n      : await prisma.googleSheetsConnection.findUnique({ where: { userId } });\n\n  if (!connection) {\n    return null;\n  }\n\n  // Determine status\n  let status: ConnectionStatus;\n  if (connection.needsReauth) {\n    status = 'needs_reauth';\n  } else if (connection.tokenExpiry && connection.tokenExpiry < new Date()) {\n    status = 'expired';\n  } else if (connection.tokenExpiry && isTokenExpiringSoon(connection.tokenExpiry)) {\n    status = 'expired';\n  } else {\n    status = 'active';\n  }\n\n  return {\n    type,\n    status,\n    expiresAt: connection.tokenExpiry ?? null,\n    lastRefreshAttempt: connection.lastRefreshAttempt ?? null,\n    lastRefreshError: connection.lastRefreshError ?? null,\n    needsReauth: connection.needsReauth || false,\n  };\n}\n\n/**\n * Get health status for all connections for a user\n *\n * @param userId - User ID\n * @returns Array of connection health statuses\n */\nexport async function getAllConnectionsHealth(userId: string): Promise<ConnectionHealth[]> {\n  const airtableHealth = await getConnectionHealth(userId, 'airtable');\n  const googleHealth = await getConnectionHealth(userId, 'google');\n\n  return [airtableHealth, googleHealth].filter((h): h is ConnectionHealth => h !== null);\n}\n\n/**\n * Check if any connections need reauth\n *\n * @param userId - User ID\n * @returns True if any connection needs reauth\n */\nexport async function hasConnectionsNeedingReauth(userId: string): Promise<boolean> {\n  const [airtable, google] = await Promise.all([\n    prisma.airtableConnection.findUnique({\n      where: { userId },\n      select: { needsReauth: true },\n    }),\n    prisma.googleSheetsConnection.findUnique({\n      where: { userId },\n      select: { needsReauth: true },\n    }),\n  ]);\n\n  return !!(airtable?.needsReauth || google?.needsReauth);\n}\n\n// ============================================================================\n// Manual Token Operations\n// ============================================================================\n\n/**\n * Force refresh a token (useful for testing or manual operations)\n *\n * @param userId - User ID\n * @param type - Connection type\n * @returns Refresh result\n */\nexport async function forceRefreshToken(\n  userId: string,\n  type: ConnectionType\n): Promise<TokenRefreshResult> {\n  console.log(`[TokenManager] Force refreshing ${type} token for user ${userId}`);\n\n  const connection =\n    type === 'airtable'\n      ? await prisma.airtableConnection.findUnique({ where: { userId } })\n      : await prisma.googleSheetsConnection.findUnique({ where: { userId } });\n\n  if (!connection) {\n    return {\n      success: false,\n      error: `${type} connection not found`,\n      needsReauth: true,\n    };\n  }\n\n  if (!connection.refreshToken) {\n    return {\n      success: false,\n      error: 'No refresh token available',\n      needsReauth: true,\n    };\n  }\n\n  if (type === 'airtable') {\n    return refreshAirtableTokenWithRetry(userId, connection.refreshToken);\n  } else {\n    return refreshGoogleTokenWithRetry(userId, connection.refreshToken);\n  }\n}\n\n/**\n * Clear the \"needs reauth\" flag manually (after user has reconnected)\n *\n * @param userId - User ID\n * @param type - Connection type\n */\nexport async function clearNeedsReauth(userId: string, type: ConnectionType): Promise<void> {\n  await clearReauthFlag(userId, type);\n}\n","/**\n * Usage Limits Enforcement Middleware\n *\n * Enforces subscription-based limits for BaseSync features:\n * - Starter: 1 sync, 1,000 records, 15-min interval\n * - Pro: 3 syncs, 5,000 records, 5-min interval\n * - Business: 10 syncs, unlimited records, 5-min interval\n *\n * Trial Period:\n * - 14-day free trial on signup (no credit card required)\n * - Trial users get full Pro tier features\n * - After trial expires, syncs pause but data remains\n */\n\nimport type { User } from 'wasp/entities';\nimport { PaymentPlanId } from '../../payment/plans';\n\n// ============================================================================\n// Trial Configuration\n// ============================================================================\n\n/** Trial duration in days */\nexport const TRIAL_DURATION_DAYS = 14;\n\n/** Calculate trial end date from start date */\nexport function calculateTrialEndDate(trialStartDate: Date): Date {\n  const endDate = new Date(trialStartDate);\n  endDate.setDate(endDate.getDate() + TRIAL_DURATION_DAYS);\n  return endDate;\n}\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface PlanLimits {\n  maxSyncConfigs: number;\n  maxRecordsPerSync: number;\n  syncIntervalMinutes: number;\n  name: string;\n}\n\nexport interface UsageLimitError {\n  exceeded: true;\n  limit: number;\n  current: number;\n  requiredPlan: PaymentPlanId;\n  message: string;\n}\n\nexport type UsageLimitCheckResult =\n  | { exceeded: false }\n  | UsageLimitError;\n\n/** Trial status for a user */\nexport type TrialStatus =\n  | { isOnTrial: true; daysRemaining: number; trialEndsAt: Date }\n  | { isOnTrial: false; trialExpired: boolean };\n\n/** User subscription state */\nexport type UserSubscriptionState =\n  | { type: 'trial_active'; daysRemaining: number; trialEndsAt: Date }\n  | { type: 'trial_expired' }\n  | { type: 'subscribed'; plan: PaymentPlanId; status: string }\n  | { type: 'subscription_inactive'; plan: PaymentPlanId; status: string };\n\n// ============================================================================\n// Plan Limits Configuration\n// ============================================================================\n\nexport const PLAN_LIMITS: Record<PaymentPlanId, PlanLimits> = {\n  [PaymentPlanId.Starter]: {\n    maxSyncConfigs: 1,\n    maxRecordsPerSync: 1000,\n    syncIntervalMinutes: 15,\n    name: 'Starter',\n  },\n  [PaymentPlanId.Pro]: {\n    maxSyncConfigs: 3,\n    maxRecordsPerSync: 5000,\n    syncIntervalMinutes: 5,\n    name: 'Pro',\n  },\n  [PaymentPlanId.Business]: {\n    maxSyncConfigs: 10,\n    maxRecordsPerSync: Number.MAX_SAFE_INTEGER, // Unlimited\n    syncIntervalMinutes: 5,\n    name: 'Business',\n  },\n  // Annual plans have the same limits as monthly plans\n  [PaymentPlanId.StarterAnnual]: {\n    maxSyncConfigs: 1,\n    maxRecordsPerSync: 1000,\n    syncIntervalMinutes: 15,\n    name: 'Starter',\n  },\n  [PaymentPlanId.ProAnnual]: {\n    maxSyncConfigs: 3,\n    maxRecordsPerSync: 5000,\n    syncIntervalMinutes: 5,\n    name: 'Pro',\n  },\n  [PaymentPlanId.BusinessAnnual]: {\n    maxSyncConfigs: 10,\n    maxRecordsPerSync: Number.MAX_SAFE_INTEGER, // Unlimited\n    syncIntervalMinutes: 5,\n    name: 'Business',\n  },\n};\n\n// Default limits for users without a subscription (trial or free tier)\nexport const DEFAULT_LIMITS: PlanLimits = PLAN_LIMITS[PaymentPlanId.Pro]; // Trial gets Pro features\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get the user's trial status\n */\nexport function getTrialStatus(user: User): TrialStatus {\n  // If user has a subscription, they're not on trial\n  if (user.subscriptionPlan && user.subscriptionStatus) {\n    return { isOnTrial: false, trialExpired: false };\n  }\n\n  // Calculate trial end date\n  const trialStartDate = user.trialStartedAt || user.createdAt;\n  const trialEndsAt = user.trialEndsAt || calculateTrialEndDate(trialStartDate);\n  const now = new Date();\n\n  if (now < trialEndsAt) {\n    const daysRemaining = Math.ceil((trialEndsAt.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\n    return { isOnTrial: true, daysRemaining, trialEndsAt };\n  }\n\n  // Trial has expired\n  return { isOnTrial: false, trialExpired: true };\n}\n\n/**\n * Get the complete subscription state for a user\n */\nexport function getUserSubscriptionState(user: User): UserSubscriptionState {\n  // Check if user has an active subscription\n  if (user.subscriptionPlan && user.subscriptionStatus) {\n    const plan = getUserPlan(user);\n    const isActive = user.subscriptionStatus === 'active' ||\n                     user.subscriptionStatus === 'cancel_at_period_end';\n\n    if (isActive) {\n      return { type: 'subscribed', plan, status: user.subscriptionStatus };\n    } else {\n      return { type: 'subscription_inactive', plan, status: user.subscriptionStatus };\n    }\n  }\n\n  // No subscription - check trial status\n  const trialStatus = getTrialStatus(user);\n\n  if (trialStatus.isOnTrial) {\n    return {\n      type: 'trial_active',\n      daysRemaining: trialStatus.daysRemaining,\n      trialEndsAt: trialStatus.trialEndsAt,\n    };\n  }\n\n  return { type: 'trial_expired' };\n}\n\n/**\n * Check if user's trial has expired (and they don't have a subscription)\n */\nexport function isTrialExpired(user: User): boolean {\n  const state = getUserSubscriptionState(user);\n  return state.type === 'trial_expired';\n}\n\n/**\n * Check if user is on active trial\n */\nexport function isOnActiveTrial(user: User): boolean {\n  const state = getUserSubscriptionState(user);\n  return state.type === 'trial_active';\n}\n\n/**\n * Get the user's current subscription plan\n */\nfunction getUserPlan(user: User): PaymentPlanId {\n  // If user has no subscription plan, they're on trial (gets Pro features)\n  if (!user.subscriptionPlan) {\n    return PaymentPlanId.Pro; // Trial users get Pro tier\n  }\n\n  // Map the subscription plan string to PaymentPlanId\n  const planMap: Record<string, PaymentPlanId> = {\n    'starter': PaymentPlanId.Starter,\n    'pro': PaymentPlanId.Pro,\n    'business': PaymentPlanId.Business,\n    'starter-annual': PaymentPlanId.StarterAnnual,\n    'pro-annual': PaymentPlanId.ProAnnual,\n    'business-annual': PaymentPlanId.BusinessAnnual,\n  };\n\n  return planMap[user.subscriptionPlan.toLowerCase()] || PaymentPlanId.Starter;\n}\n\n/**\n * Check if user's subscription is active (includes active trial)\n */\nfunction isSubscriptionActive(user: User): boolean {\n  const state = getUserSubscriptionState(user);\n\n  switch (state.type) {\n    case 'trial_active':\n      return true;\n    case 'subscribed':\n      return true;\n    case 'trial_expired':\n      return false; // Trial expired, syncs should pause\n    case 'subscription_inactive':\n      return false;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get the next higher plan that would allow the operation\n */\nfunction getRequiredPlan(requiredLimit: number, limitType: 'syncs' | 'records'): PaymentPlanId {\n  if (limitType === 'syncs') {\n    if (requiredLimit <= PLAN_LIMITS[PaymentPlanId.Starter].maxSyncConfigs) {\n      return PaymentPlanId.Starter;\n    } else if (requiredLimit <= PLAN_LIMITS[PaymentPlanId.Pro].maxSyncConfigs) {\n      return PaymentPlanId.Pro;\n    } else {\n      return PaymentPlanId.Business;\n    }\n  } else {\n    // records\n    if (requiredLimit <= PLAN_LIMITS[PaymentPlanId.Starter].maxRecordsPerSync) {\n      return PaymentPlanId.Starter;\n    } else if (requiredLimit <= PLAN_LIMITS[PaymentPlanId.Pro].maxRecordsPerSync) {\n      return PaymentPlanId.Pro;\n    } else {\n      return PaymentPlanId.Business;\n    }\n  }\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Get the plan limits for a user based on their subscription\n */\nexport function getUserPlanLimits(user: User): PlanLimits {\n  if (!isSubscriptionActive(user)) {\n    // Inactive subscription - return most restrictive limits\n    return PLAN_LIMITS[PaymentPlanId.Starter];\n  }\n\n  const plan = getUserPlan(user);\n  return PLAN_LIMITS[plan];\n}\n\n/**\n * Check if user can create another sync configuration\n *\n * @param user - The authenticated user\n * @param currentSyncCount - Current number of sync configs user has\n * @returns UsageLimitCheckResult indicating if limit is exceeded\n */\nexport function checkSyncConfigLimit(\n  user: User,\n  currentSyncCount: number\n): UsageLimitCheckResult {\n  const limits = getUserPlanLimits(user);\n\n  if (currentSyncCount >= limits.maxSyncConfigs) {\n    const plan = getUserPlan(user);\n    const requiredPlan = getRequiredPlan(currentSyncCount + 1, 'syncs');\n\n    return {\n      exceeded: true,\n      limit: limits.maxSyncConfigs,\n      current: currentSyncCount,\n      requiredPlan,\n      message: `You've reached your limit of ${limits.maxSyncConfigs} sync configuration${limits.maxSyncConfigs === 1 ? '' : 's'} on the ${limits.name} plan. Upgrade to ${PLAN_LIMITS[requiredPlan].name} to create more syncs.`,\n    };\n  }\n\n  return { exceeded: false };\n}\n\n/**\n * Check if a sync operation is within record limits\n *\n * @param user - The authenticated user\n * @param recordCount - Number of records being synced\n * @returns UsageLimitCheckResult indicating if limit is exceeded\n */\nexport function checkRecordLimit(\n  user: User,\n  recordCount: number\n): UsageLimitCheckResult {\n  const limits = getUserPlanLimits(user);\n\n  if (recordCount > limits.maxRecordsPerSync) {\n    const plan = getUserPlan(user);\n    const requiredPlan = getRequiredPlan(recordCount, 'records');\n\n    return {\n      exceeded: true,\n      limit: limits.maxRecordsPerSync,\n      current: recordCount,\n      requiredPlan,\n      message: `This sync contains ${recordCount.toLocaleString()} records, which exceeds your ${limits.name} plan limit of ${limits.maxRecordsPerSync.toLocaleString()} records. Upgrade to ${PLAN_LIMITS[requiredPlan].name} to sync more records.`,\n    };\n  }\n\n  return { exceeded: false };\n}\n\n/**\n * Get the sync frequency (interval in minutes) for the user's plan\n *\n * @param user - The authenticated user\n * @returns Sync interval in minutes\n */\nexport function getSyncFrequency(user: User): number {\n  const limits = getUserPlanLimits(user);\n  return limits.syncIntervalMinutes;\n}\n\n/**\n * Check if user is approaching their sync config limit (at 80% or more)\n *\n * @param user - The authenticated user\n * @param currentSyncCount - Current number of sync configs\n * @returns true if at or above 80% of limit\n */\nexport function isApproachingSyncLimit(user: User, currentSyncCount: number): boolean {\n  const limits = getUserPlanLimits(user);\n  return currentSyncCount >= (limits.maxSyncConfigs * 0.8);\n}\n\n/**\n * Check if user is approaching their record limit (at 80% or more)\n *\n * @param user - The authenticated user\n * @param recordCount - Number of records being synced\n * @returns true if at or above 80% of limit\n */\nexport function isApproachingRecordLimit(user: User, recordCount: number): boolean {\n  const limits = getUserPlanLimits(user);\n\n  // Business plan has unlimited records\n  if (limits.maxRecordsPerSync === Number.MAX_SAFE_INTEGER) {\n    return false;\n  }\n\n  return recordCount >= (limits.maxRecordsPerSync * 0.8);\n}\n\n/**\n * Get a user-friendly description of their current plan and limits\n *\n * @param user - The authenticated user\n * @returns Human-readable plan summary\n */\nexport function getPlanSummary(user: User): string {\n  const state = getUserSubscriptionState(user);\n  const limits = getUserPlanLimits(user);\n  const recordLimit = limits.maxRecordsPerSync === Number.MAX_SAFE_INTEGER\n    ? 'Unlimited'\n    : limits.maxRecordsPerSync.toLocaleString();\n\n  const baseInfo = `${limits.maxSyncConfigs} sync${limits.maxSyncConfigs === 1 ? '' : 's'}, ${recordLimit} records per sync, ${limits.syncIntervalMinutes}-minute sync interval`;\n\n  switch (state.type) {\n    case 'trial_active':\n      return `Free Trial (${state.daysRemaining} days left): ${baseInfo}`;\n    case 'trial_expired':\n      return `Trial Expired - Syncs Paused. Upgrade to continue syncing.`;\n    case 'subscribed':\n      return `${limits.name} Plan: ${baseInfo}`;\n    case 'subscription_inactive':\n      return `${limits.name} Plan (Inactive): ${baseInfo}`;\n    default:\n      return `${limits.name} Plan: ${baseInfo}`;\n  }\n}\n\n/**\n * Check if syncs should be paused for this user\n * Syncs are paused when:\n * - Trial has expired and no subscription\n * - Subscription is past_due or deleted\n *\n * @param user - The authenticated user\n * @returns true if syncs should be paused\n */\nexport function shouldPauseSyncs(user: User): boolean {\n  const state = getUserSubscriptionState(user);\n  return state.type === 'trial_expired' || state.type === 'subscription_inactive';\n}\n\n/**\n * Get the reason why syncs are paused (if they are)\n *\n * @param user - The authenticated user\n * @returns Reason string or null if syncs are not paused\n */\nexport function getSyncPauseReason(user: User): string | null {\n  const state = getUserSubscriptionState(user);\n\n  switch (state.type) {\n    case 'trial_expired':\n      return 'Your 14-day free trial has ended. Upgrade to a paid plan to resume syncing.';\n    case 'subscription_inactive':\n      if (state.status === 'past_due') {\n        return 'Your subscription payment is past due. Please update your payment method to resume syncing.';\n      }\n      return 'Your subscription has been cancelled. Resubscribe to resume syncing.';\n    default:\n      return null;\n  }\n}\n","/**\n * Resend HTTP API Email Sender\n *\n * Replaces Wasp's default email sender with Resend's HTTP API\n * No SMTP - pure HTTP API (Railway-friendly)\n */\n\nimport { Resend } from 'resend';\n\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport interface EmailSender {\n  send(email: {\n    to: string;\n    subject: string;\n    text: string;\n    html: string;\n    from?: { name?: string; email: string };\n  }): Promise<void>;\n}\n\nclass ResendEmailSender implements EmailSender {\n  async send(email: {\n    to: string;\n    subject: string;\n    text: string;\n    html: string;\n    from?: { name?: string; email: string };\n  }): Promise<void> {\n    const fromEmail = email.from?.email || 'noreply@basesync.app';\n    const fromName = email.from?.name || 'BaseSync';\n    const from = `${fromName} <${fromEmail}>`;\n\n    try {\n      console.log(`[Resend HTTP API] Sending email to ${email.to}: ${email.subject}`);\n\n      const { data, error } = await resend.emails.send({\n        from,\n        to: email.to,\n        subject: email.subject,\n        text: email.text,\n        html: email.html,\n      });\n\n      if (error) {\n        console.error('[Resend HTTP API] Error:', error);\n        throw new Error(`Resend API error: ${error.message}`);\n      }\n\n      console.log(`[Resend HTTP API] âœ“ Email sent successfully:`, data?.id);\n    } catch (error: any) {\n      console.error('[Resend HTTP API] Failed to send email:', error);\n      throw new Error(`Failed to send email: ${error.message}`);\n    }\n  }\n}\n\n// Create singleton instance\nexport const resendEmailSender = new ResendEmailSender();\n\n// Export for Wasp compatibility\nexport default resendEmailSender;\n","/**\n * BaseSync Notification Email Templates\n *\n * Email templates for usage limits, trial expiration, and other notifications.\n * These templates are used with the Wasp emailSender to notify users.\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface EmailContent {\n  subject: string;\n  text: string;\n  html: string;\n}\n\n// ============================================================================\n// Usage Limit Emails\n// ============================================================================\n\n/**\n * Email sent when user reaches 80% of their usage limit\n */\nexport function getApproachingLimitEmailContent({\n  userName,\n  limitType,\n  currentUsage,\n  limit,\n  planName,\n  upgradePlanName,\n  upgradeUrl,\n}: {\n  userName: string;\n  limitType: 'records' | 'syncs';\n  currentUsage: number;\n  limit: number;\n  planName: string;\n  upgradePlanName: string;\n  upgradeUrl: string;\n}): EmailContent {\n  const percentage = Math.round((currentUsage / limit) * 100);\n  const limitTypeText = limitType === 'records' ? 'records per sync' : 'sync configurations';\n\n  return {\n    subject: \"You're approaching your BaseSync limit\",\n    text: `Hi ${userName},\n\nYou've used ${percentage}% of your ${planName} plan limit.\n\nCurrent usage: ${currentUsage.toLocaleString()} ${limitTypeText}\nPlan limit: ${limit.toLocaleString()} ${limitTypeText}\n\nTo avoid any interruption to your syncs, consider upgrading to ${upgradePlanName}.\n\nUpgrade now: ${upgradeUrl}\n\nThanks,\nThe BaseSync Team`,\n    html: `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n<body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;\">\n  <div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;\">\n    <h1 style=\"color: white; margin: 0; font-size: 24px;\">BaseSync</h1>\n  </div>\n\n  <div style=\"background: #fff; padding: 30px; border: 1px solid #e0e0e0; border-top: none; border-radius: 0 0 10px 10px;\">\n    <h2 style=\"color: #f59e0b; margin-top: 0;\">Heads up! You're approaching your limit</h2>\n\n    <p>Hi ${userName},</p>\n\n    <p>You've used <strong>${percentage}%</strong> of your ${planName} plan limit.</p>\n\n    <div style=\"background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 20px 0; border-radius: 4px;\">\n      <p style=\"margin: 0;\"><strong>Current usage:</strong> ${currentUsage.toLocaleString()} ${limitTypeText}</p>\n      <p style=\"margin: 10px 0 0 0;\"><strong>Plan limit:</strong> ${limit.toLocaleString()} ${limitTypeText}</p>\n    </div>\n\n    <p>To avoid any interruption to your syncs, consider upgrading to <strong>${upgradePlanName}</strong>.</p>\n\n    <div style=\"text-align: center; margin: 30px 0;\">\n      <a href=\"${upgradeUrl}\" style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 30px; text-decoration: none; border-radius: 6px; font-weight: 600; display: inline-block;\">Upgrade Now</a>\n    </div>\n\n    <p style=\"color: #666; font-size: 14px;\">Your data is safe and your current syncs will continue working until you reach 100% of your limit.</p>\n  </div>\n\n  <div style=\"text-align: center; padding: 20px; color: #888; font-size: 12px;\">\n    <p>Thanks,<br>The BaseSync Team</p>\n  </div>\n</body>\n</html>`,\n  };\n}\n\n/**\n * Email sent when user reaches 100% of their usage limit\n */\nexport function getLimitReachedEmailContent({\n  userName,\n  limitType,\n  currentUsage,\n  limit,\n  planName,\n  upgradePlanName,\n  upgradeUrl,\n}: {\n  userName: string;\n  limitType: 'records' | 'syncs';\n  currentUsage: number;\n  limit: number;\n  planName: string;\n  upgradePlanName: string;\n  upgradeUrl: string;\n}): EmailContent {\n  const limitTypeText = limitType === 'records' ? 'records per sync' : 'sync configurations';\n\n  return {\n    subject: \"Your BaseSync sync has paused\",\n    text: `Hi ${userName},\n\nYour sync has been paused because you've reached your ${planName} plan limit of ${limit.toLocaleString()} ${limitTypeText}.\n\nDon't worry - your data is completely safe. Your existing syncs and all your data remain intact.\n\nTo resume syncing, upgrade to ${upgradePlanName}: ${upgradeUrl}\n\nWhat happens now:\n- Your data remains safe and unchanged\n- You can still access your dashboard and view sync history\n- Syncs will automatically resume once you upgrade\n\nThanks,\nThe BaseSync Team`,\n    html: `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n<body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;\">\n  <div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;\">\n    <h1 style=\"color: white; margin: 0; font-size: 24px;\">BaseSync</h1>\n  </div>\n\n  <div style=\"background: #fff; padding: 30px; border: 1px solid #e0e0e0; border-top: none; border-radius: 0 0 10px 10px;\">\n    <h2 style=\"color: #ef4444; margin-top: 0;\">Your sync has been paused</h2>\n\n    <p>Hi ${userName},</p>\n\n    <p>Your sync has been paused because you've reached your <strong>${planName}</strong> plan limit of <strong>${limit.toLocaleString()} ${limitTypeText}</strong>.</p>\n\n    <div style=\"background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin: 20px 0; border-radius: 4px;\">\n      <p style=\"margin: 0; font-weight: 600;\">Don't worry - your data is completely safe.</p>\n      <p style=\"margin: 10px 0 0 0;\">Your existing syncs and all your data remain intact.</p>\n    </div>\n\n    <p>To resume syncing, upgrade to <strong>${upgradePlanName}</strong>:</p>\n\n    <div style=\"text-align: center; margin: 30px 0;\">\n      <a href=\"${upgradeUrl}\" style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 30px; text-decoration: none; border-radius: 6px; font-weight: 600; display: inline-block;\">Upgrade to Resume</a>\n    </div>\n\n    <h3 style=\"color: #333; margin-top: 30px;\">What happens now:</h3>\n    <ul style=\"color: #666;\">\n      <li>Your data remains safe and unchanged</li>\n      <li>You can still access your dashboard and view sync history</li>\n      <li>Syncs will automatically resume once you upgrade</li>\n    </ul>\n  </div>\n\n  <div style=\"text-align: center; padding: 20px; color: #888; font-size: 12px;\">\n    <p>Thanks,<br>The BaseSync Team</p>\n  </div>\n</body>\n</html>`,\n  };\n}\n\n// ============================================================================\n// Trial Emails\n// ============================================================================\n\n/**\n * Email sent 3 days before trial expires\n */\nexport function getTrialEndingSoonEmailContent({\n  userName,\n  daysRemaining,\n  recordsSynced,\n  syncConfigsCount,\n  pricingUrl,\n}: {\n  userName: string;\n  daysRemaining: number;\n  recordsSynced: number;\n  syncConfigsCount: number;\n  pricingUrl: string;\n}): EmailContent {\n  return {\n    subject: `Your BaseSync trial ends in ${daysRemaining} days`,\n    text: `Hi ${userName},\n\nYour free trial ends in ${daysRemaining} days.\n\nDuring your trial, you've:\n- Synced ${recordsSynced.toLocaleString()} records\n- Created ${syncConfigsCount} sync configuration${syncConfigsCount === 1 ? '' : 's'}\n\nTo keep your syncs running without interruption, choose a plan that fits your needs:\n\nStarter ($9/mo): 1 sync, 1,000 records\nPro ($19/mo): 3 syncs, 5,000 records - MOST POPULAR\nBusiness ($39/mo): 10 syncs, unlimited records\n\nView pricing and upgrade: ${pricingUrl}\n\nAfter your trial:\n- Syncs will pause (no data is lost)\n- You can upgrade anytime to resume\n\nThanks for trying BaseSync!\nThe BaseSync Team`,\n    html: `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n<body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;\">\n  <div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;\">\n    <h1 style=\"color: white; margin: 0; font-size: 24px;\">BaseSync</h1>\n  </div>\n\n  <div style=\"background: #fff; padding: 30px; border: 1px solid #e0e0e0; border-top: none; border-radius: 0 0 10px 10px;\">\n    <h2 style=\"color: #667eea; margin-top: 0;\">Your trial ends in ${daysRemaining} days</h2>\n\n    <p>Hi ${userName},</p>\n\n    <p>Your free trial is coming to an end. Here's what you've accomplished:</p>\n\n    <div style=\"background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;\">\n      <div style=\"display: flex; justify-content: space-around; text-align: center;\">\n        <div>\n          <div style=\"font-size: 28px; font-weight: bold; color: #667eea;\">${recordsSynced.toLocaleString()}</div>\n          <div style=\"color: #666; font-size: 14px;\">Records Synced</div>\n        </div>\n        <div>\n          <div style=\"font-size: 28px; font-weight: bold; color: #667eea;\">${syncConfigsCount}</div>\n          <div style=\"color: #666; font-size: 14px;\">Sync${syncConfigsCount === 1 ? '' : 's'} Created</div>\n        </div>\n      </div>\n    </div>\n\n    <p>To keep your syncs running without interruption, choose a plan that fits your needs:</p>\n\n    <div style=\"margin: 25px 0;\">\n      <div style=\"background: #f9fafb; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 1px solid #e5e7eb;\">\n        <strong>Starter</strong> - $9/mo\n        <span style=\"color: #666; float: right;\">1 sync, 1,000 records</span>\n      </div>\n      <div style=\"background: #eff6ff; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 2px solid #667eea;\">\n        <strong>Pro</strong> - $19/mo\n        <span style=\"background: #667eea; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 10px;\">MOST POPULAR</span>\n        <span style=\"color: #666; float: right;\">3 syncs, 5,000 records</span>\n      </div>\n      <div style=\"background: #f9fafb; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb;\">\n        <strong>Business</strong> - $39/mo\n        <span style=\"color: #666; float: right;\">10 syncs, unlimited records</span>\n      </div>\n    </div>\n\n    <div style=\"text-align: center; margin: 30px 0;\">\n      <a href=\"${pricingUrl}\" style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 30px; text-decoration: none; border-radius: 6px; font-weight: 600; display: inline-block;\">Choose Your Plan</a>\n    </div>\n\n    <div style=\"background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; margin: 20px 0; border-radius: 4px;\">\n      <p style=\"margin: 0;\"><strong>After your trial:</strong> Syncs will pause but no data is lost. You can upgrade anytime to resume.</p>\n    </div>\n  </div>\n\n  <div style=\"text-align: center; padding: 20px; color: #888; font-size: 12px;\">\n    <p>Thanks for trying BaseSync!<br>The BaseSync Team</p>\n  </div>\n</body>\n</html>`,\n  };\n}\n\n// ============================================================================\n// Sync Failure Emails\n// ============================================================================\n\n/**\n * Email sent when a sync fails\n */\nexport function getSyncFailedEmailContent({\n  userName,\n  syncName,\n  errorMessage,\n  dashboardUrl,\n}: {\n  userName: string;\n  syncName: string;\n  errorMessage: string;\n  dashboardUrl: string;\n}): EmailContent {\n  return {\n    subject: `BaseSync: \"${syncName}\" sync failed`,\n    text: `Hi ${userName},\n\nYour sync \"${syncName}\" has failed.\n\nError: ${errorMessage}\n\nPlease check your dashboard for more details and to retry the sync: ${dashboardUrl}\n\nCommon causes:\n- OAuth token expired - try reconnecting your Airtable or Google Sheets account\n- Rate limit exceeded - the sync will automatically retry\n- Field mapping issue - check if any fields have been renamed or deleted\n\nThanks,\nThe BaseSync Team`,\n    html: `\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n</head>\n<body style=\"font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;\">\n  <div style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 30px; border-radius: 10px 10px 0 0;\">\n    <h1 style=\"color: white; margin: 0; font-size: 24px;\">BaseSync</h1>\n  </div>\n\n  <div style=\"background: #fff; padding: 30px; border: 1px solid #e0e0e0; border-top: none; border-radius: 0 0 10px 10px;\">\n    <h2 style=\"color: #ef4444; margin-top: 0;\">Sync Failed</h2>\n\n    <p>Hi ${userName},</p>\n\n    <p>Your sync <strong>\"${syncName}\"</strong> has failed.</p>\n\n    <div style=\"background: #fef2f2; border-left: 4px solid #ef4444; padding: 15px; margin: 20px 0; border-radius: 4px;\">\n      <p style=\"margin: 0;\"><strong>Error:</strong></p>\n      <p style=\"margin: 10px 0 0 0; font-family: monospace; font-size: 14px; color: #666;\">${errorMessage}</p>\n    </div>\n\n    <div style=\"text-align: center; margin: 30px 0;\">\n      <a href=\"${dashboardUrl}\" style=\"background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 14px 30px; text-decoration: none; border-radius: 6px; font-weight: 600; display: inline-block;\">View Dashboard</a>\n    </div>\n\n    <h3 style=\"color: #333; margin-top: 30px;\">Common causes:</h3>\n    <ul style=\"color: #666;\">\n      <li><strong>OAuth token expired</strong> - try reconnecting your Airtable or Google Sheets account</li>\n      <li><strong>Rate limit exceeded</strong> - the sync will automatically retry</li>\n      <li><strong>Field mapping issue</strong> - check if any fields have been renamed or deleted</li>\n    </ul>\n  </div>\n\n  <div style=\"text-align: center; padding: 20px; color: #888; font-size: 12px;\">\n    <p>Thanks,<br>The BaseSync Team</p>\n  </div>\n</body>\n</html>`,\n  };\n}\n","/**\n * Notification Email Sender\n *\n * Utility functions to send BaseSync notification emails.\n * Uses Wasp's emailSender for delivery and integrates with usage tracking.\n */\n\n// Using Resend HTTP API instead of Wasp's SMTP emailSender (Railway blocks SMTP)\nimport { resendEmailSender as emailSender } from '../email/resendEmailSender';\nimport type { User } from 'wasp/entities';\nimport { prisma } from 'wasp/server';\nimport {\n  getApproachingLimitEmailContent,\n  getLimitReachedEmailContent,\n  getTrialEndingSoonEmailContent,\n  getSyncFailedEmailContent,\n} from './baseSyncEmails';\nimport { PLAN_LIMITS, getUserPlanLimits, getTrialStatus } from '../middleware/usageLimits';\nimport { getTotalRecordsSynced } from '../utils/usageTracker';\nimport { PaymentPlanId } from '../../payment/plans';\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\nconst APP_URL = process.env.WASP_WEB_CLIENT_URL || 'https://basesync.app';\nconst PRICING_URL = `${APP_URL}/pricing`;\nconst DASHBOARD_URL = `${APP_URL}/dashboard`;\n\n// Email tracking to prevent duplicate sends within a time window\nconst EMAIL_COOLDOWN_HOURS = 24;\n\n// ============================================================================\n// Types\n// ============================================================================\n\ninterface EmailTrackingRecord {\n  userId: string;\n  emailType: string;\n  sentAt: Date;\n}\n\n// In-memory cache for email tracking (in production, consider using database)\nconst emailTrackingCache: Map<string, EmailTrackingRecord> = new Map();\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Generate a cache key for email tracking\n */\nfunction getEmailTrackingKey(userId: string, emailType: string): string {\n  return `${userId}:${emailType}`;\n}\n\n/**\n * Check if an email was recently sent to avoid duplicates\n */\nfunction wasEmailRecentlySent(userId: string, emailType: string): boolean {\n  const key = getEmailTrackingKey(userId, emailType);\n  const record = emailTrackingCache.get(key);\n\n  if (!record) {\n    return false;\n  }\n\n  const hoursSinceSent = (Date.now() - record.sentAt.getTime()) / (1000 * 60 * 60);\n  return hoursSinceSent < EMAIL_COOLDOWN_HOURS;\n}\n\n/**\n * Mark an email as sent for tracking\n */\nfunction markEmailSent(userId: string, emailType: string): void {\n  const key = getEmailTrackingKey(userId, emailType);\n  emailTrackingCache.set(key, {\n    userId,\n    emailType,\n    sentAt: new Date(),\n  });\n}\n\n/**\n * Get user's display name (falls back to email)\n */\nfunction getUserName(user: User): string {\n  // OpenSaaS User model may have different name fields\n  // Adjust based on your actual User model\n  return (user as any).name || (user as any).username || user.email?.split('@')[0] || 'there';\n}\n\n/**\n * Get the upgrade plan based on current plan\n */\nfunction getUpgradePlan(currentPlan: PaymentPlanId): { id: PaymentPlanId; name: string } {\n  switch (currentPlan) {\n    case PaymentPlanId.Starter:\n      return { id: PaymentPlanId.Pro, name: 'Pro' };\n    case PaymentPlanId.Pro:\n      return { id: PaymentPlanId.Business, name: 'Business' };\n    case PaymentPlanId.Business:\n      return { id: PaymentPlanId.Business, name: 'Business' }; // Already highest\n    default:\n      return { id: PaymentPlanId.Pro, name: 'Pro' };\n  }\n}\n\n/**\n * Get user's current plan ID\n */\nfunction getUserPlanId(user: User): PaymentPlanId {\n  if (!user.subscriptionPlan) {\n    return PaymentPlanId.Pro; // Trial users get Pro tier\n  }\n\n  const planMap: Record<string, PaymentPlanId> = {\n    starter: PaymentPlanId.Starter,\n    pro: PaymentPlanId.Pro,\n    business: PaymentPlanId.Business,\n  };\n\n  return planMap[user.subscriptionPlan.toLowerCase()] || PaymentPlanId.Starter;\n}\n\n// ============================================================================\n// Public API - Email Sending Functions\n// ============================================================================\n\n/**\n * Send \"approaching limit\" email when user hits 80% of their limit\n *\n * @param user - The user to notify\n * @param limitType - Type of limit being approached ('records' or 'syncs')\n * @param currentUsage - Current usage amount\n */\nexport async function sendApproachingLimitEmail(\n  user: User,\n  limitType: 'records' | 'syncs',\n  currentUsage: number\n): Promise<void> {\n  const emailType = `approaching_${limitType}_limit`;\n\n  // Check if we recently sent this email\n  if (wasEmailRecentlySent(user.id, emailType)) {\n    console.log(`Skipping ${emailType} email for user ${user.id} - recently sent`);\n    return;\n  }\n\n  if (!user.email) {\n    console.log(`Cannot send email to user ${user.id} - no email address`);\n    return;\n  }\n\n  const planId = getUserPlanId(user);\n  const limits = getUserPlanLimits(user);\n  const upgradePlan = getUpgradePlan(planId);\n  const limit = limitType === 'records' ? limits.maxRecordsPerSync : limits.maxSyncConfigs;\n\n  const emailContent = getApproachingLimitEmailContent({\n    userName: getUserName(user),\n    limitType,\n    currentUsage,\n    limit,\n    planName: limits.name,\n    upgradePlanName: upgradePlan.name,\n    upgradeUrl: PRICING_URL,\n  });\n\n  try {\n    await emailSender.send({\n      to: user.email,\n      ...emailContent,\n    });\n\n    markEmailSent(user.id, emailType);\n    console.log(`Sent approaching limit email to user ${user.id} for ${limitType}`);\n  } catch (error) {\n    console.error(`Failed to send approaching limit email to user ${user.id}:`, error);\n  }\n}\n\n/**\n * Send \"limit reached\" email when user hits 100% of their limit\n *\n * @param user - The user to notify\n * @param limitType - Type of limit reached ('records' or 'syncs')\n * @param currentUsage - Current usage amount\n */\nexport async function sendLimitReachedEmail(\n  user: User,\n  limitType: 'records' | 'syncs',\n  currentUsage: number\n): Promise<void> {\n  const emailType = `reached_${limitType}_limit`;\n\n  // Check if we recently sent this email\n  if (wasEmailRecentlySent(user.id, emailType)) {\n    console.log(`Skipping ${emailType} email for user ${user.id} - recently sent`);\n    return;\n  }\n\n  if (!user.email) {\n    console.log(`Cannot send email to user ${user.id} - no email address`);\n    return;\n  }\n\n  const planId = getUserPlanId(user);\n  const limits = getUserPlanLimits(user);\n  const upgradePlan = getUpgradePlan(planId);\n  const limit = limitType === 'records' ? limits.maxRecordsPerSync : limits.maxSyncConfigs;\n\n  const emailContent = getLimitReachedEmailContent({\n    userName: getUserName(user),\n    limitType,\n    currentUsage,\n    limit,\n    planName: limits.name,\n    upgradePlanName: upgradePlan.name,\n    upgradeUrl: PRICING_URL,\n  });\n\n  try {\n    await emailSender.send({\n      to: user.email,\n      ...emailContent,\n    });\n\n    markEmailSent(user.id, emailType);\n    console.log(`Sent limit reached email to user ${user.id} for ${limitType}`);\n  } catch (error) {\n    console.error(`Failed to send limit reached email to user ${user.id}:`, error);\n  }\n}\n\n/**\n * Send \"trial ending soon\" email (typically sent 3 days before expiry)\n *\n * @param user - The user to notify\n */\nexport async function sendTrialEndingSoonEmail(user: User): Promise<void> {\n  const emailType = 'trial_ending_soon';\n\n  // Check if we recently sent this email\n  if (wasEmailRecentlySent(user.id, emailType)) {\n    console.log(`Skipping ${emailType} email for user ${user.id} - recently sent`);\n    return;\n  }\n\n  if (!user.email) {\n    console.log(`Cannot send email to user ${user.id} - no email address`);\n    return;\n  }\n\n  const trialStatus = getTrialStatus(user);\n\n  if (!trialStatus.isOnTrial) {\n    console.log(`User ${user.id} is not on trial, skipping email`);\n    return;\n  }\n\n  // Get usage stats for the email\n  const recordsSynced = await getTotalRecordsSynced(user.id);\n  const syncConfigsCount = await prisma.syncConfig.count({\n    where: { userId: user.id },\n  });\n\n  const emailContent = getTrialEndingSoonEmailContent({\n    userName: getUserName(user),\n    daysRemaining: trialStatus.daysRemaining,\n    recordsSynced,\n    syncConfigsCount,\n    pricingUrl: PRICING_URL,\n  });\n\n  try {\n    await emailSender.send({\n      to: user.email,\n      ...emailContent,\n    });\n\n    markEmailSent(user.id, emailType);\n    console.log(`Sent trial ending soon email to user ${user.id} (${trialStatus.daysRemaining} days left)`);\n  } catch (error) {\n    console.error(`Failed to send trial ending soon email to user ${user.id}:`, error);\n  }\n}\n\n/**\n * Send \"sync failed\" email notification\n *\n * @param user - The user to notify\n * @param syncName - Name of the sync that failed\n * @param errorMessage - Error message describing the failure\n */\nexport async function sendSyncFailedEmail(\n  user: User,\n  syncName: string,\n  errorMessage: string\n): Promise<void> {\n  const emailType = `sync_failed_${syncName}`;\n\n  // Check if we recently sent this email for this specific sync\n  if (wasEmailRecentlySent(user.id, emailType)) {\n    console.log(`Skipping ${emailType} email for user ${user.id} - recently sent`);\n    return;\n  }\n\n  if (!user.email) {\n    console.log(`Cannot send email to user ${user.id} - no email address`);\n    return;\n  }\n\n  const emailContent = getSyncFailedEmailContent({\n    userName: getUserName(user),\n    syncName,\n    errorMessage,\n    dashboardUrl: DASHBOARD_URL,\n  });\n\n  try {\n    await emailSender.send({\n      to: user.email,\n      ...emailContent,\n    });\n\n    markEmailSent(user.id, emailType);\n    console.log(`Sent sync failed email to user ${user.id} for sync \"${syncName}\"`);\n  } catch (error) {\n    console.error(`Failed to send sync failed email to user ${user.id}:`, error);\n  }\n}\n\n// ============================================================================\n// Batch/Scheduled Email Functions\n// ============================================================================\n\n/**\n * Check all trial users and send \"trial ending soon\" emails\n * This should be called daily via a background job\n */\nexport async function checkAndSendTrialExpiringEmails(): Promise<void> {\n  console.log('Checking for trial users needing expiration emails...');\n\n  // Find users who are on trial and haven't subscribed\n  const users = await prisma.user.findMany({\n    where: {\n      subscriptionPlan: null,\n      subscriptionStatus: null,\n    },\n  });\n\n  let emailsSent = 0;\n\n  for (const user of users) {\n    const trialStatus = getTrialStatus(user);\n\n    // Send email if trial ends in 3 days or less\n    if (trialStatus.isOnTrial && trialStatus.daysRemaining <= 3) {\n      await sendTrialEndingSoonEmail(user);\n      emailsSent++;\n    }\n  }\n\n  console.log(`Sent ${emailsSent} trial expiring emails`);\n}\n\n/**\n * Check a specific user's usage and send limit emails if needed\n * Called during sync operations\n *\n * @param user - User to check\n * @param recordCount - Number of records being synced\n * @param currentSyncCount - Current number of sync configs\n */\nexport async function checkAndSendUsageEmails(\n  user: User,\n  recordCount?: number,\n  currentSyncCount?: number\n): Promise<void> {\n  const limits = getUserPlanLimits(user);\n\n  // Check record limits\n  if (recordCount !== undefined && limits.maxRecordsPerSync !== Number.MAX_SAFE_INTEGER) {\n    const recordPercentage = (recordCount / limits.maxRecordsPerSync) * 100;\n\n    if (recordPercentage >= 100) {\n      await sendLimitReachedEmail(user, 'records', recordCount);\n    } else if (recordPercentage >= 80) {\n      await sendApproachingLimitEmail(user, 'records', recordCount);\n    }\n  }\n\n  // Check sync config limits\n  if (currentSyncCount !== undefined) {\n    const syncPercentage = (currentSyncCount / limits.maxSyncConfigs) * 100;\n\n    if (syncPercentage >= 100) {\n      await sendLimitReachedEmail(user, 'syncs', currentSyncCount);\n    } else if (syncPercentage >= 80) {\n      await sendApproachingLimitEmail(user, 'syncs', currentSyncCount);\n    }\n  }\n}\n","/**\n * Usage Tracking Utilities\n *\n * Tracks monthly usage metrics for billing and limit enforcement:\n * - Records synced\n * - Sync configurations created\n */\n\nimport type { User, UsageStats, SyncConfig } from 'wasp/entities';\nimport { prisma } from 'wasp/server';\nimport { checkAndSendUsageEmails } from '../emails/notificationSender';\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get the first day of the current month (for usage tracking consistency)\n */\nfunction getMonthStart(date: Date = new Date()): Date {\n  return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n}\n\n/**\n * Get or create usage stats record for the current month\n */\nasync function getOrCreateMonthlyUsage(userId: string): Promise<UsageStats> {\n  const monthStart = getMonthStart();\n\n  // Try to find existing usage record for this month\n  let usage = await prisma.usageStats.findUnique({\n    where: {\n      userId_month: {\n        userId,\n        month: monthStart,\n      },\n    },\n  });\n\n  // Create if doesn't exist\n  if (!usage) {\n    usage = await prisma.usageStats.create({\n      data: {\n        userId,\n        month: monthStart,\n        recordsSynced: 0,\n        syncConfigsCreated: 0,\n      },\n    });\n  }\n\n  return usage;\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Track records synced for a user\n *\n * Increments the monthly recordsSynced counter\n *\n * @param userId - User ID\n * @param count - Number of records synced\n */\nexport async function trackRecordsSynced(\n  userId: string,\n  count: number\n): Promise<void> {\n  if (count <= 0) return;\n\n  const monthStart = getMonthStart();\n\n  await prisma.usageStats.upsert({\n    where: {\n      userId_month: {\n        userId,\n        month: monthStart,\n      },\n    },\n    update: {\n      recordsSynced: {\n        increment: count,\n      },\n      lastUpdatedAt: new Date(),\n    },\n    create: {\n      userId,\n      month: monthStart,\n      recordsSynced: count,\n      syncConfigsCreated: 0,\n    },\n  });\n}\n\n/**\n * Track sync configuration creation\n *\n * Increments the monthly syncConfigsCreated counter\n *\n * @param userId - User ID\n */\nexport async function trackSyncConfigCreated(userId: string): Promise<void> {\n  const monthStart = getMonthStart();\n\n  await prisma.usageStats.upsert({\n    where: {\n      userId_month: {\n        userId,\n        month: monthStart,\n      },\n    },\n    update: {\n      syncConfigsCreated: {\n        increment: 1,\n      },\n      lastUpdatedAt: new Date(),\n    },\n    create: {\n      userId,\n      month: monthStart,\n      recordsSynced: 0,\n      syncConfigsCreated: 1,\n    },\n  });\n}\n\n/**\n * Get current month's usage statistics for a user\n *\n * @param userId - User ID\n * @returns Current month's usage stats\n */\nexport async function getMonthlyUsage(userId: string): Promise<{\n  recordsSynced: number;\n  syncConfigsCreated: number;\n  month: Date;\n}> {\n  const usage = await getOrCreateMonthlyUsage(userId);\n\n  return {\n    recordsSynced: usage.recordsSynced,\n    syncConfigsCreated: usage.syncConfigsCreated,\n    month: usage.month,\n  };\n}\n\n/**\n * Get usage statistics for a specific month\n *\n * @param userId - User ID\n * @param month - Month to query (defaults to current month)\n * @returns Usage stats for the specified month, or null if doesn't exist\n */\nexport async function getUsageForMonth(\n  userId: string,\n  month: Date = new Date()\n): Promise<{\n  recordsSynced: number;\n  syncConfigsCreated: number;\n  month: Date;\n} | null> {\n  const monthStart = getMonthStart(month);\n\n  const usage = await prisma.usageStats.findUnique({\n    where: {\n      userId_month: {\n        userId,\n        month: monthStart,\n      },\n    },\n  });\n\n  if (!usage) {\n    return null;\n  }\n\n  return {\n    recordsSynced: usage.recordsSynced,\n    syncConfigsCreated: usage.syncConfigsCreated,\n    month: usage.month,\n  };\n}\n\n/**\n * Get usage history for a user (last N months)\n *\n * @param userId - User ID\n * @param months - Number of months to retrieve (default: 6)\n * @returns Array of usage stats, newest first\n */\nexport async function getUsageHistory(\n  userId: string,\n  months: number = 6\n): Promise<Array<{\n  recordsSynced: number;\n  syncConfigsCreated: number;\n  month: Date;\n}>> {\n  const usageRecords = await prisma.usageStats.findMany({\n    where: {\n      userId,\n    },\n    orderBy: {\n      month: 'desc',\n    },\n    take: months,\n  });\n\n  return usageRecords.map((record) => ({\n    recordsSynced: record.recordsSynced,\n    syncConfigsCreated: record.syncConfigsCreated,\n    month: record.month,\n  }));\n}\n\n/**\n * Reset monthly usage counters\n *\n * This should be called automatically on the 1st of each month via a cron job.\n * Creates a new usage record for the new month.\n *\n * Note: We don't delete old records - they're kept for historical reporting.\n *\n * @param userId - User ID (optional - if not provided, creates records for all active users)\n */\nexport async function resetMonthlyUsage(userId?: string): Promise<void> {\n  // This function is primarily for documentation purposes.\n  // In practice, the upsert pattern in trackRecordsSynced and trackSyncConfigCreated\n  // automatically creates new monthly records when the month changes.\n\n  // If a specific userId is provided, ensure they have a record for the current month\n  if (userId) {\n    await getOrCreateMonthlyUsage(userId);\n  } else {\n    // For all users, the next time they sync, a new monthly record will be created automatically\n    // We don't need to proactively create records for all users\n    console.log('Monthly usage will be tracked automatically when users perform actions');\n  }\n}\n\n/**\n * Get total records synced across all time for a user\n *\n * @param userId - User ID\n * @returns Total records synced (all time)\n */\nexport async function getTotalRecordsSynced(userId: string): Promise<number> {\n  const result = await prisma.usageStats.aggregate({\n    where: {\n      userId,\n    },\n    _sum: {\n      recordsSynced: true,\n    },\n  });\n\n  return result._sum.recordsSynced || 0;\n}\n\n/**\n * Get total sync configurations created across all time for a user\n *\n * @param userId - User ID\n * @returns Total sync configs created (all time)\n */\nexport async function getTotalSyncConfigsCreated(userId: string): Promise<number> {\n  const result = await prisma.usageStats.aggregate({\n    where: {\n      userId,\n    },\n    _sum: {\n      syncConfigsCreated: true,\n    },\n  });\n\n  return result._sum.syncConfigsCreated || 0;\n}\n\n// ============================================================================\n// Usage Tracking with Email Notifications\n// ============================================================================\n\n/**\n * Track records synced and check for limit warnings\n *\n * This extended version also checks if the user is approaching or has reached\n * their limits and triggers appropriate email notifications.\n *\n * @param user - The user entity (with email for notifications)\n * @param count - Number of records synced\n */\nexport async function trackRecordsSyncedWithNotifications(\n  user: User,\n  count: number\n): Promise<void> {\n  if (count <= 0) return;\n\n  // Track the usage\n  await trackRecordsSynced(user.id, count);\n\n  // Check limits and send notifications if needed\n  try {\n    await checkAndSendUsageEmails(user, count);\n  } catch (error) {\n    console.error('Error checking usage notifications:', error);\n  }\n}\n\n/**\n * Track sync config creation and check for limit warnings\n *\n * This extended version also checks if the user is approaching or has reached\n * their sync config limits and triggers appropriate email notifications.\n *\n * @param user - The user entity (with email for notifications)\n */\nexport async function trackSyncConfigCreatedWithNotifications(\n  user: User\n): Promise<void> {\n  // Track the usage\n  await trackSyncConfigCreated(user.id);\n\n  // Get current sync config count\n  const syncConfigCount = await prisma.syncConfig.count({\n    where: { userId: user.id },\n  });\n\n  // Check limits and send notifications if needed\n  try {\n    await checkAndSendUsageEmails(user, undefined, syncConfigCount);\n  } catch (error) {\n    console.error('Error checking usage notifications:', error);\n  }\n}\n","/**\n * Manual Sync Actions\n * Provides on-demand sync triggers for user-initiated syncs\n */\n\nimport { HttpError } from 'wasp/server';\nimport { syncAirtableToSheets } from '../sync/airtableToSheets';\nimport { syncSheetsToAirtable } from '../sync/sheetsToAirtable';\nimport { syncBidirectional } from '../sync/bidirectionalSync';\nimport { getValidAirtableToken, getValidGoogleToken } from '../utils/tokenManager';\nimport type { ConflictResolutionStrategy } from '../sync/conflictDetector';\nimport { checkRecordLimit, isApproachingRecordLimit, shouldPauseSyncs, getSyncPauseReason } from '../middleware/usageLimits';\nimport { trackRecordsSynced } from '../utils/usageTracker';\nimport type { User } from 'wasp/entities';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ninterface TriggerManualSyncArgs {\n  /** The sync configuration ID to execute */\n  syncConfigId: string;\n}\n\ninterface RunInitialSyncArgs {\n  /** The sync configuration ID to execute initial sync for */\n  syncConfigId: string;\n  /** Whether to perform a dry run (report changes without applying) */\n  dryRun?: boolean;\n}\n\ninterface ManualSyncResult {\n  /** Sync execution status */\n  status: 'SUCCESS' | 'PARTIAL' | 'FAILED';\n  /** User-friendly message */\n  message: string;\n  /** Detailed sync statistics */\n  details: {\n    /** Records added */\n    added: number;\n    /** Records updated */\n    updated: number;\n    /** Records deleted */\n    deleted: number;\n    /** Total records processed */\n    total: number;\n    /** Number of errors */\n    errorCount: number;\n    /** Sync duration in milliseconds */\n    duration: number;\n    /** Sync direction used */\n    direction: string;\n    /** Timestamp when sync started */\n    startedAt: string;\n    /** Timestamp when sync completed */\n    completedAt: string;\n    [key: string]: any;\n  };\n  /** List of errors if any occurred */\n  errors?: Array<{\n    message: string;\n    type?: string;\n    recordId?: string;\n    [key: string]: any;\n  }>;\n  /** Warnings (non-critical issues) */\n  warnings?: string[];\n  /** Conflict resolution details (for bidirectional sync) */\n  conflicts?: {\n    total: number;\n    airtableWins: number;\n    sheetsWins: number;\n    deleted: number;\n    skipped: number;\n    [key: string]: any;\n  };\n  [key: string]: any;\n}\n\n// ============================================================================\n// Manual Sync Action\n// ============================================================================\n\n/**\n * Triggers an immediate manual sync for a specific sync configuration\n *\n * Edge cases handled:\n * - User doesn't own the sync config (403 Forbidden)\n * - Sync config doesn't exist (404 Not Found)\n * - Sync config is inactive (400 Bad Request)\n * - Missing Airtable/Google connection (400 Bad Request)\n * - Token decryption failures (500 Internal Server Error)\n * - Expired tokens (automatic refresh attempted)\n * - Invalid field mappings (400 Bad Request)\n * - Rate limiting from external APIs (retries with exponential backoff)\n * - Network failures during sync (partial results captured)\n * - Invalid sync direction (500 Internal Server Error)\n * - Concurrent sync execution (409 Conflict)\n */\nexport const triggerManualSync = async (\n  args: TriggerManualSyncArgs,\n  context: any\n): Promise<ManualSyncResult> => {\n  const startTime = Date.now();\n  const startedAt = new Date();\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('[ManualSync] Manual sync triggered');\n  console.log('[ManualSync] Config ID:', args.syncConfigId);\n  console.log('[ManualSync] User:', context.user.email || context.user.username);\n  console.log('[ManualSync] Time:', startedAt.toISOString());\n  console.log('='.repeat(80) + '\\n');\n\n  // ==========================================================================\n  // STEP 1: Validate input\n  // ==========================================================================\n  if (!args.syncConfigId) {\n    throw new HttpError(400, 'syncConfigId is required');\n  }\n\n  if (typeof args.syncConfigId !== 'string') {\n    throw new HttpError(400, 'syncConfigId must be a string');\n  }\n\n  // Helper function to log errors to SyncLog even when early validation fails\n  // Note: syncConfig may not be available yet, so we use optional chaining\n  let syncConfigForLogging: any = null; // Will be set after we fetch it\n\n  const logSyncError = async (errorMessage: string, errorType: string = 'VALIDATION_ERROR') => {\n    try {\n      await context.entities.SyncLog.create({\n        data: {\n          syncConfigId: args.syncConfigId,\n          status: 'FAILED',\n          recordsSynced: 0,\n          recordsFailed: 1,\n          errors: JSON.stringify([{ message: errorMessage, type: errorType }]),\n          startedAt,\n          completedAt: new Date(),\n          triggeredBy: 'manual',\n          direction: syncConfigForLogging?.syncDirection || 'UNKNOWN',\n        },\n      });\n      console.log('[ManualSync] Error logged to SyncLog:', errorMessage);\n    } catch (logError) {\n      console.error('[ManualSync] Failed to log error to SyncLog:', logError);\n    }\n  };\n\n  // ==========================================================================\n  // STEP 2: Fetch and validate sync config\n  // ==========================================================================\n  console.log('[ManualSync] Fetching sync configuration...');\n\n  const syncConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: args.syncConfigId },\n    include: {\n      user: {\n        include: {\n          airtableConnections: true,\n          googleSheetsConnections: true,\n        },\n      },\n    },\n  });\n\n  // Edge case: Sync config doesn't exist\n  if (!syncConfig) {\n    console.error('[ManualSync] Sync config not found');\n    throw new HttpError(404, 'Sync configuration not found');\n  }\n\n  // Edge case: User doesn't own this sync config\n  if (syncConfig.userId !== context.user.id) {\n    console.error('[ManualSync] Unauthorized access attempt');\n    throw new HttpError(403, 'You do not have permission to access this sync configuration');\n  }\n\n  console.log('[ManualSync] Config found:', syncConfig.name);\n  console.log('[ManualSync] Direction:', syncConfig.syncDirection);\n  console.log('[ManualSync] Is active:', syncConfig.isActive);\n\n  // Store for error logging\n  syncConfigForLogging = syncConfig;\n\n  // ==========================================================================\n  // STEP 2.5: Check subscription/trial status\n  // ==========================================================================\n  // CRITICAL: Prevent syncs if trial expired or subscription inactive\n  if (shouldPauseSyncs(syncConfig.user as User)) {\n    const pauseReason = getSyncPauseReason(syncConfig.user as User);\n    console.warn('[ManualSync] Syncs paused for user:', pauseReason);\n    const errorMsg = pauseReason || 'Your trial has expired or subscription is inactive. Please upgrade to continue syncing.';\n    await logSyncError(errorMsg, 'SUBSCRIPTION_REQUIRED');\n    throw new HttpError(402, errorMsg); // 402 Payment Required\n  }\n\n  // Edge case: Sync config is inactive\n  if (!syncConfig.isActive) {\n    console.warn('[ManualSync] Sync config is inactive');\n    const errorMsg = 'This sync configuration is inactive. Please activate it before running a manual sync.';\n    await logSyncError(errorMsg, 'INACTIVE_CONFIG');\n    throw new HttpError(400, errorMsg);\n  }\n\n  // ==========================================================================\n  // STEP 3: Check for concurrent execution\n  // ==========================================================================\n  // Edge case: Prevent concurrent syncs for the same config\n  const recentSync = await context.entities.SyncLog.findFirst({\n    where: {\n      syncConfigId: args.syncConfigId,\n      startedAt: {\n        gte: new Date(Date.now() - 5 * 60 * 1000), // Within last 5 minutes\n      },\n      completedAt: null, // Still running\n    },\n    orderBy: { startedAt: 'desc' },\n  });\n\n  if (recentSync) {\n    console.warn('[ManualSync] Concurrent sync detected');\n    throw new HttpError(\n      409,\n      'A sync is already in progress for this configuration. Please wait for it to complete.'\n    );\n  }\n\n  // ==========================================================================\n  // STEP 4: Validate connections exist\n  // ==========================================================================\n  console.log('[ManualSync] Validating connections...');\n\n  const airtableConnection = syncConfig.user.airtableConnections?.[0];\n  const googleConnection = syncConfig.user.googleSheetsConnections?.[0];\n\n  // Edge case: Missing Airtable connection\n  if (!airtableConnection) {\n    console.error('[ManualSync] No Airtable connection found');\n    const errorMsg = 'Airtable connection not found. Please connect your Airtable account first.';\n    await logSyncError(errorMsg, 'MISSING_CONNECTION');\n    throw new HttpError(400, errorMsg);\n  }\n\n  // Edge case: Missing Google Sheets connection\n  if (!googleConnection) {\n    console.error('[ManualSync] No Google Sheets connection found');\n    const errorMsg = 'Google Sheets connection not found. Please connect your Google account first.';\n    await logSyncError(errorMsg, 'MISSING_CONNECTION');\n    throw new HttpError(400, errorMsg);\n  }\n\n  console.log('[ManualSync] Connections validated');\n\n  // ==========================================================================\n  // STEP 5: Get valid access tokens (auto-refreshes if needed)\n  // ==========================================================================\n  console.log('[ManualSync] Getting valid access tokens...');\n\n  let airtableAccessToken: string;\n  let sheetsAccessToken: string;\n\n  try {\n    // This automatically checks expiry and refreshes tokens if needed\n    airtableAccessToken = await getValidAirtableToken(context.user.id);\n    console.log('[ManualSync] âœ“ Got valid Airtable token');\n  } catch (error) {\n    // Edge case: Token refresh failure or needs reauth\n    console.error('[ManualSync] Failed to get valid Airtable token:', error);\n    const errorMsg = error instanceof Error ? error.message : 'Failed to get Airtable access token. Please reconnect your Airtable account.';\n    await logSyncError(errorMsg, 'AIRTABLE_TOKEN_ERROR');\n    throw new HttpError(401, errorMsg);\n  }\n\n  try {\n    // This automatically checks expiry and refreshes tokens if needed\n    sheetsAccessToken = await getValidGoogleToken(context.user.id);\n    console.log('[ManualSync] âœ“ Got valid Google Sheets token');\n  } catch (error) {\n    // Edge case: Token refresh failure or needs reauth\n    console.error('[ManualSync] Failed to get valid Google Sheets token:', error);\n    const errorMsg = error instanceof Error ? error.message : 'Failed to get Google Sheets access token. Please reconnect your Google account.';\n    await logSyncError(errorMsg, 'GOOGLE_TOKEN_ERROR');\n    throw new HttpError(401, errorMsg);\n  }\n\n  // ==========================================================================\n  // STEP 6: Parse and validate field mappings\n  // ==========================================================================\n  let fieldMappings: Record<string, number> | undefined;\n\n  if (syncConfig.fieldMappings) {\n    try {\n      fieldMappings = JSON.parse(syncConfig.fieldMappings);\n\n      // Edge case: Invalid field mappings format\n      if (typeof fieldMappings !== 'object' || fieldMappings === null) {\n        throw new Error('Field mappings must be an object');\n      }\n\n      // Validate each mapping is a number\n      for (const [key, value] of Object.entries(fieldMappings)) {\n        if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\n          throw new Error(`Invalid column index for field \"${key}\": ${value}`);\n        }\n      }\n    } catch (error) {\n      // Edge case: Invalid JSON or format\n      console.error('[ManualSync] Invalid field mappings:', error);\n      const errorMsg = `Invalid field mappings configuration: ${error instanceof Error ? error.message : 'Unknown error'}`;\n      await logSyncError(errorMsg, 'FIELD_MAPPINGS_ERROR');\n      throw new HttpError(400, errorMsg);\n    }\n  }\n\n  // ==========================================================================\n  // STEP 7: Execute sync based on direction\n  // ==========================================================================\n  console.log('[ManualSync] Executing sync...');\n\n  let syncResult: any;\n  let syncStatus: 'SUCCESS' | 'PARTIAL' | 'FAILED' = 'SUCCESS';\n  let errors: any[] = [];\n  let warnings: string[] = [];\n  let caughtError: Error | null = null; // Track error to rethrow after logging\n\n  try {\n    switch (syncConfig.syncDirection) {\n      // ----------------------------------------------------------------------\n      // Airtable â†’ Google Sheets\n      // ----------------------------------------------------------------------\n      case 'AIRTABLE_TO_SHEETS': {\n        console.log('[ManualSync] Running Airtable â†’ Sheets sync...');\n\n        syncResult = await syncAirtableToSheets({\n          airtableAccessToken,\n          sheetsAccessToken,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          viewId: syncConfig.airtableViewId, // Use view for exact order\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          fieldMappings,\n          includeHeader: true,\n          resolveLinkedRecords: true,\n          idColumnIndex: 0,\n          maxRetries: 3,\n          batchSize: 100,\n        });\n\n        errors = syncResult.errors || [];\n        warnings = syncResult.warnings || [];\n\n        syncStatus =\n          errors.length === 0\n            ? 'SUCCESS'\n            : syncResult.added + syncResult.updated > 0\n              ? 'PARTIAL'\n              : 'FAILED';\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Google Sheets â†’ Airtable\n      // ----------------------------------------------------------------------\n      case 'SHEETS_TO_AIRTABLE': {\n        console.log('[ManualSync] Running Sheets â†’ Airtable sync...');\n\n        syncResult = await syncSheetsToAirtable({\n          sheetsAccessToken,\n          airtableAccessToken,\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          fieldMappings,\n          idColumnIndex: 0,\n          skipHeaderRow: true,\n          deleteExtraRecords: false,\n          resolveLinkedRecords: true,\n          createMissingLinkedRecords: false,\n          maxRetries: 3,\n          batchSize: 10,\n          validationMode: 'lenient',\n        });\n\n        errors = syncResult.errors || [];\n        warnings = syncResult.warnings || [];\n\n        syncStatus =\n          errors.length === 0\n            ? 'SUCCESS'\n            : syncResult.added + syncResult.updated > 0\n              ? 'PARTIAL'\n              : 'FAILED';\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Bidirectional\n      // ----------------------------------------------------------------------\n      case 'BIDIRECTIONAL': {\n        console.log('[ManualSync] Running bidirectional sync...');\n\n        syncResult = await syncBidirectional({\n          syncConfigId: syncConfig.id,\n          airtableAccessToken,\n          sheetsAccessToken,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          viewId: syncConfig.airtableViewId,\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          conflictResolution: syncConfig.conflictResolution as ConflictResolutionStrategy,\n          fieldMappings,\n          idColumnIndex: 0,\n          includeHeader: true,\n          resolveLinkedRecords: true,\n          createMissingLinkedRecords: false,\n          maxRetries: 3,\n          batchSize: 10,\n          dryRun: false,\n        });\n\n        errors = syncResult.errors || [];\n        warnings = syncResult.warnings || [];\n\n        syncStatus = syncResult.status;\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Unknown direction (should never happen)\n      // ----------------------------------------------------------------------\n      default: {\n        // Edge case: Invalid sync direction in database\n        console.error('[ManualSync] Unknown sync direction:', syncConfig.syncDirection);\n        throw new HttpError(\n          500,\n          `Invalid sync direction: ${syncConfig.syncDirection}. Please contact support.`\n        );\n      }\n    }\n\n    console.log('[ManualSync] Sync execution completed');\n    console.log('[ManualSync] Status:', syncStatus);\n  } catch (error) {\n    // Edge case: Sync execution failed catastrophically\n    console.error('[ManualSync] Sync execution failed:', error);\n    console.error('[ManualSync] Error stack:', error instanceof Error ? error.stack : 'No stack');\n\n    syncStatus = 'FAILED';\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    errors = [\n      {\n        message: errorMessage,\n        type: error instanceof HttpError ? 'HTTP_ERROR' : 'EXECUTION_ERROR',\n      },\n    ];\n\n    // Initialize syncResult with error info so it gets logged\n    syncResult = {\n      added: 0,\n      updated: 0,\n      deleted: 0,\n      total: 0,\n      errors: errors,\n      warnings: [],\n      duration: Date.now() - startTime,\n      startedAt,\n      completedAt: new Date(),\n    };\n\n    // Store error to rethrow after logging (if it's an HttpError that should surface to user)\n    if (error instanceof HttpError) {\n      caughtError = error;\n    }\n  }\n\n  // ==========================================================================\n  // STEP 8: Update sync metadata\n  // ==========================================================================\n  console.log('[ManualSync] Updating sync metadata...');\n\n  const completedAt = new Date();\n  const duration = Date.now() - startTime;\n\n  try {\n    // Update SyncConfig\n    await context.entities.SyncConfig.update({\n      where: { id: syncConfig.id },\n      data: {\n        lastSyncAt: completedAt,\n        lastSyncStatus: syncStatus.toLowerCase(),\n      },\n    });\n\n    // Create SyncLog entry\n    await context.entities.SyncLog.create({\n      data: {\n        syncConfigId: syncConfig.id,\n        status:\n          syncStatus === 'SUCCESS'\n            ? 'SUCCESS'\n            : syncStatus === 'PARTIAL'\n              ? 'PARTIAL'\n              : 'FAILED',\n        recordsSynced:\n          syncConfig.syncDirection === 'BIDIRECTIONAL'\n            ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n              (syncResult?.summary?.airtableToSheets?.updated || 0) +\n              (syncResult?.summary?.sheetsToAirtable?.added || 0) +\n              (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n            : (syncResult?.added || 0) + (syncResult?.updated || 0),\n        recordsFailed: errors.length,\n        errors:\n          errors.length > 0\n            ? JSON.stringify(\n                errors.slice(0, 10).map((e) => ({\n                  message: e.message,\n                  recordId: e.recordId,\n                  type: e.type,\n                }))\n              )\n            : null,\n        startedAt,\n        completedAt,\n        triggeredBy: 'manual',\n        direction: syncConfig.syncDirection,\n      },\n    });\n\n    console.log('[ManualSync] Sync metadata updated');\n\n    // Track usage for billing and limits (only successful syncs)\n    if (syncStatus === 'SUCCESS' || syncStatus === 'PARTIAL') {\n      const recordsCount = syncConfig.syncDirection === 'BIDIRECTIONAL'\n        ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n          (syncResult?.summary?.airtableToSheets?.updated || 0) +\n          (syncResult?.summary?.sheetsToAirtable?.added || 0) +\n          (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n        : (syncResult?.added || 0) + (syncResult?.updated || 0);\n\n      await trackRecordsSynced(context.user!.id, recordsCount);\n\n      // Add warning if approaching record limit\n      if (isApproachingRecordLimit(context.user!, recordsCount)) {\n        warnings.push('You are approaching your monthly record limit for your plan. Consider upgrading to avoid sync interruptions.');\n      }\n    }\n  } catch (error) {\n    // Edge case: Failed to update metadata (non-fatal)\n    console.error('[ManualSync] Failed to update metadata:', error);\n    warnings.push('Failed to update sync metadata in database');\n  }\n\n  // ==========================================================================\n  // STEP 9: Build and return result\n  // ==========================================================================\n  console.log('[ManualSync] Building result...');\n\n  let message: string;\n  if (syncStatus === 'SUCCESS') {\n    message = 'Sync completed successfully';\n  } else if (syncStatus === 'PARTIAL') {\n    message = `Sync completed with ${errors.length} error(s)`;\n  } else {\n    message = 'Sync failed';\n  }\n\n  const result: ManualSyncResult = {\n    status: syncStatus,\n    message,\n    details: {\n      added:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.added || 0)\n          : syncResult?.added || 0,\n      updated:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.updated || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n          : syncResult?.updated || 0,\n      deleted:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.deleted || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.deleted || 0)\n          : syncResult?.deleted || 0,\n      total: syncResult?.total || 0,\n      errorCount: errors.length,\n      duration,\n      direction: syncConfig.syncDirection,\n      startedAt: startedAt.toISOString(),\n      completedAt: completedAt.toISOString(),\n    },\n    errors:\n      errors.length > 0\n        ? errors.slice(0, 20).map((e) => ({\n            message: e.message,\n            type: e.type,\n            recordId: e.recordId,\n          }))\n        : undefined,\n    warnings: warnings.length > 0 ? warnings : undefined,\n    conflicts:\n      syncConfig.syncDirection === 'BIDIRECTIONAL'\n        ? syncResult?.summary?.conflicts\n        : undefined,\n  };\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('[ManualSync] Manual sync completed');\n  console.log('[ManualSync] Status:', syncStatus);\n  console.log('[ManualSync] Duration:', duration, 'ms');\n  console.log('[ManualSync] Records: +', result.details.added, 'â†»', result.details.updated, '-', result.details.deleted);\n  if (errors.length > 0) {\n    console.log('[ManualSync] Errors:', errors.length);\n  }\n  if (warnings.length > 0) {\n    console.log('[ManualSync] Warnings:', warnings.length);\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  // If we caught an HttpError earlier, rethrow it now that we've logged everything\n  if (caughtError) {\n    throw caughtError;\n  }\n\n  return result;\n};\n\n// ============================================================================\n// Initial Sync Action\n// ============================================================================\n\n/**\n * Runs an initial bulk sync for first-time setup or resync\n *\n * This is designed for syncing existing data when:\n * - Setting up a new sync configuration\n * - Re-syncing after data corruption\n * - Performing a full refresh\n *\n * Edge cases handled:\n * - All the same edge cases as triggerManualSync\n * - Large datasets (chunked processing)\n * - Dry run mode for preview\n * - First-time sync with no prior state\n * - Existing data conflicts (uses conflict resolution strategy)\n */\nexport const runInitialSync = async (\n  args: RunInitialSyncArgs,\n  context: any\n): Promise<ManualSyncResult> => {\n  const startTime = Date.now();\n  const startedAt = new Date();\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('[InitialSync] Initial sync triggered');\n  console.log('[InitialSync] Config ID:', args.syncConfigId);\n  console.log('[InitialSync] Dry run:', args.dryRun || false);\n  console.log('[InitialSync] User:', context.user.email || context.user.username);\n  console.log('[InitialSync] Time:', startedAt.toISOString());\n  console.log('='.repeat(80) + '\\n');\n\n  // ==========================================================================\n  // STEP 1: Validate input\n  // ==========================================================================\n  if (!args.syncConfigId) {\n    throw new HttpError(400, 'syncConfigId is required');\n  }\n\n  if (typeof args.syncConfigId !== 'string') {\n    throw new HttpError(400, 'syncConfigId must be a string');\n  }\n\n  if (args.dryRun !== undefined && typeof args.dryRun !== 'boolean') {\n    throw new HttpError(400, 'dryRun must be a boolean');\n  }\n\n  // ==========================================================================\n  // STEP 2: Fetch and validate sync config\n  // ==========================================================================\n  console.log('[InitialSync] Fetching sync configuration...');\n\n  const syncConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: args.syncConfigId },\n    include: {\n      user: {\n        include: {\n          airtableConnections: true,\n          googleSheetsConnections: true,\n        },\n      },\n      syncLogs: {\n        orderBy: { startedAt: 'desc' },\n        take: 1,\n      },\n    },\n  });\n\n  // Edge case: Sync config doesn't exist\n  if (!syncConfig) {\n    console.error('[InitialSync] Sync config not found');\n    throw new HttpError(404, 'Sync configuration not found');\n  }\n\n  // Edge case: User doesn't own this sync config\n  if (syncConfig.userId !== context.user.id) {\n    console.error('[InitialSync] Unauthorized access attempt');\n    throw new HttpError(\n      403,\n      'You do not have permission to access this sync configuration'\n    );\n  }\n\n  console.log('[InitialSync] Config found:', syncConfig.name);\n  console.log('[InitialSync] Direction:', syncConfig.syncDirection);\n  console.log('[InitialSync] Previous syncs:', syncConfig.syncLogs.length);\n\n  // ==========================================================================\n  // STEP 2.5: Check subscription/trial status\n  // ==========================================================================\n  // CRITICAL: Prevent syncs if trial expired or subscription inactive\n  if (shouldPauseSyncs(syncConfig.user as User)) {\n    const pauseReason = getSyncPauseReason(syncConfig.user as User);\n    console.warn('[InitialSync] Syncs paused for user:', pauseReason);\n    const errorMsg = pauseReason || 'Your trial has expired or subscription is inactive. Please upgrade to continue syncing.';\n    throw new HttpError(402, errorMsg); // 402 Payment Required\n  }\n\n  // ==========================================================================\n  // STEP 3: Warn if this is not truly an initial sync\n  // ==========================================================================\n  const warnings: string[] = [];\n\n  if (syncConfig.lastSyncAt) {\n    const daysSinceLastSync = Math.floor(\n      (Date.now() - syncConfig.lastSyncAt.getTime()) / (1000 * 60 * 60 * 24)\n    );\n    console.warn(\n      `[InitialSync] This sync config was last synced ${daysSinceLastSync} day(s) ago`\n    );\n    warnings.push(\n      `This is not a first-time sync. Last sync was ${daysSinceLastSync} day(s) ago.`\n    );\n  }\n\n  // Edge case: Sync config is inactive\n  if (!syncConfig.isActive) {\n    console.warn('[InitialSync] Sync config is inactive - will activate it');\n    warnings.push('Sync configuration was inactive and has been activated.');\n\n    // Activate the config for initial sync\n    await context.entities.SyncConfig.update({\n      where: { id: args.syncConfigId },\n      data: { isActive: true },\n    });\n  }\n\n  // ==========================================================================\n  // STEP 4: Validate connections exist\n  // ==========================================================================\n  console.log('[InitialSync] Validating connections...');\n\n  const airtableConnection = syncConfig.user.airtableConnections?.[0];\n  const googleConnection = syncConfig.user.googleSheetsConnections?.[0];\n\n  // Edge case: Missing Airtable connection\n  if (!airtableConnection) {\n    console.error('[InitialSync] No Airtable connection found');\n    throw new HttpError(\n      400,\n      'Airtable connection not found. Please connect your Airtable account first.'\n    );\n  }\n\n  // Edge case: Missing Google Sheets connection\n  if (!googleConnection) {\n    console.error('[InitialSync] No Google Sheets connection found');\n    throw new HttpError(\n      400,\n      'Google Sheets connection not found. Please connect your Google account first.'\n    );\n  }\n\n  console.log('[InitialSync] Connections validated');\n\n  // ==========================================================================\n  // STEP 5: Get valid access tokens (auto-refreshes if needed)\n  // ==========================================================================\n  console.log('[InitialSync] Getting valid access tokens...');\n\n  let airtableAccessToken: string;\n  let sheetsAccessToken: string;\n\n  try {\n    // This automatically checks expiry and refreshes tokens if needed\n    airtableAccessToken = await getValidAirtableToken(syncConfig.userId);\n    console.log('[InitialSync] âœ“ Got valid Airtable token');\n  } catch (error) {\n    // Edge case: Token refresh failure or needs reauth\n    console.error('[InitialSync] Failed to get valid Airtable token:', error);\n    const errorMsg = error instanceof Error ? error.message : 'Failed to get Airtable access token. Please reconnect your Airtable account.';\n    throw new HttpError(401, errorMsg);\n  }\n\n  try {\n    // This automatically checks expiry and refreshes tokens if needed\n    sheetsAccessToken = await getValidGoogleToken(syncConfig.userId);\n    console.log('[InitialSync] âœ“ Got valid Google Sheets token');\n  } catch (error) {\n    // Edge case: Token refresh failure or needs reauth\n    console.error('[InitialSync] Failed to get valid Google Sheets token:', error);\n    const errorMsg = error instanceof Error ? error.message : 'Failed to get Google Sheets access token. Please reconnect your Google account.';\n    throw new HttpError(401, errorMsg);\n  }\n\n  // ==========================================================================\n  // STEP 6: Parse and validate field mappings\n  // ==========================================================================\n  let fieldMappings: Record<string, number> | undefined;\n\n  if (syncConfig.fieldMappings) {\n    try {\n      fieldMappings = JSON.parse(syncConfig.fieldMappings);\n\n      // Edge case: Invalid field mappings format\n      if (typeof fieldMappings !== 'object' || fieldMappings === null) {\n        throw new Error('Field mappings must be an object');\n      }\n\n      // Validate each mapping\n      for (const [key, value] of Object.entries(fieldMappings)) {\n        if (typeof value !== 'number' || !Number.isInteger(value) || value < 0) {\n          throw new Error(`Invalid column index for field \"${key}\": ${value}`);\n        }\n      }\n    } catch (error) {\n      // Edge case: Invalid JSON or format\n      console.error('[InitialSync] Invalid field mappings:', error);\n      throw new HttpError(\n        400,\n        `Invalid field mappings configuration: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  // ==========================================================================\n  // STEP 7: Execute initial sync based on direction\n  // ==========================================================================\n  console.log('[InitialSync] Executing initial sync...');\n  console.log('[InitialSync] Dry run:', args.dryRun || false);\n\n  let syncResult: any;\n  let syncStatus: 'SUCCESS' | 'PARTIAL' | 'FAILED' = 'SUCCESS';\n  let errors: any[] = [];\n\n  try {\n    switch (syncConfig.syncDirection) {\n      // ----------------------------------------------------------------------\n      // Airtable â†’ Google Sheets\n      // ----------------------------------------------------------------------\n      case 'AIRTABLE_TO_SHEETS': {\n        console.log('[InitialSync] Running Airtable â†’ Sheets initial sync...');\n\n        syncResult = await syncAirtableToSheets({\n          airtableAccessToken,\n          sheetsAccessToken,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          viewId: syncConfig.airtableViewId, // Use view for exact order\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          fieldMappings,\n          includeHeader: true,\n          resolveLinkedRecords: true,\n          idColumnIndex: 0,\n          maxRetries: 5, // More retries for large initial sync\n          batchSize: 100,\n        });\n\n        errors = syncResult.errors || [];\n        warnings.push(...(syncResult.warnings || []));\n\n        syncStatus =\n          errors.length === 0\n            ? 'SUCCESS'\n            : syncResult.added + syncResult.updated > 0\n              ? 'PARTIAL'\n              : 'FAILED';\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Google Sheets â†’ Airtable\n      // ----------------------------------------------------------------------\n      case 'SHEETS_TO_AIRTABLE': {\n        console.log('[InitialSync] Running Sheets â†’ Airtable initial sync...');\n\n        syncResult = await syncSheetsToAirtable({\n          sheetsAccessToken,\n          airtableAccessToken,\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          fieldMappings,\n          idColumnIndex: 0,\n          skipHeaderRow: true,\n          deleteExtraRecords: true, // For initial sync, clean up extra records\n          resolveLinkedRecords: true,\n          createMissingLinkedRecords: true, // Create linked records during initial sync\n          maxRetries: 5, // More retries for large initial sync\n          batchSize: 10,\n          validationMode: 'strict', // Stricter validation for initial sync\n        });\n\n        errors = syncResult.errors || [];\n        warnings.push(...(syncResult.warnings || []));\n\n        syncStatus =\n          errors.length === 0\n            ? 'SUCCESS'\n            : syncResult.added + syncResult.updated > 0\n              ? 'PARTIAL'\n              : 'FAILED';\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Bidirectional\n      // ----------------------------------------------------------------------\n      case 'BIDIRECTIONAL': {\n        console.log('[InitialSync] Running bidirectional initial sync...');\n\n        syncResult = await syncBidirectional({\n          syncConfigId: syncConfig.id,\n          airtableAccessToken,\n          sheetsAccessToken,\n          baseId: syncConfig.airtableBaseId,\n          tableId: syncConfig.airtableTableId,\n          viewId: syncConfig.airtableViewId,\n          spreadsheetId: syncConfig.googleSpreadsheetId,\n          sheetId: syncConfig.googleSheetId,\n          conflictResolution: syncConfig.conflictResolution as ConflictResolutionStrategy,\n          fieldMappings,\n          idColumnIndex: 0,\n          includeHeader: true,\n          resolveLinkedRecords: true,\n          createMissingLinkedRecords: true, // Create linked records during initial sync\n          maxRetries: 5, // More retries for large initial sync\n          batchSize: 10,\n          dryRun: args.dryRun || false,\n        });\n\n        errors = syncResult.errors || [];\n        warnings.push(...(syncResult.warnings || []));\n\n        syncStatus = syncResult.status;\n\n        if (args.dryRun) {\n          warnings.push(\n            'This was a dry run. No actual changes were made. Run without dryRun flag to apply changes.'\n          );\n        }\n        break;\n      }\n\n      // ----------------------------------------------------------------------\n      // Unknown direction\n      // ----------------------------------------------------------------------\n      default: {\n        // Edge case: Invalid sync direction in database\n        console.error('[InitialSync] Unknown sync direction:', syncConfig.syncDirection);\n        throw new HttpError(\n          500,\n          `Invalid sync direction: ${syncConfig.syncDirection}. Please contact support.`\n        );\n      }\n    }\n\n    console.log('[InitialSync] Sync execution completed');\n    console.log('[InitialSync] Status:', syncStatus);\n  } catch (error) {\n    // Edge case: Sync execution failed catastrophically\n    console.error('[InitialSync] Sync execution failed:', error);\n\n    syncStatus = 'FAILED';\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    errors = [\n      {\n        message: errorMessage,\n        type: 'EXECUTION_ERROR',\n      },\n    ];\n\n    // If it's an HTTP error, rethrow it\n    if (error instanceof HttpError) {\n      throw error;\n    }\n\n    // Otherwise wrap in a generic error\n    syncResult = {\n      added: 0,\n      updated: 0,\n      deleted: 0,\n      total: 0,\n      errors: errors,\n      warnings: warnings,\n      duration: Date.now() - startTime,\n      startedAt,\n      completedAt: new Date(),\n    };\n  }\n\n  // ==========================================================================\n  // STEP 8: Update sync metadata (skip if dry run)\n  // ==========================================================================\n  const completedAt = new Date();\n  const duration = Date.now() - startTime;\n\n  if (!args.dryRun) {\n    console.log('[InitialSync] Updating sync metadata...');\n\n    try {\n      // Update SyncConfig\n      await context.entities.SyncConfig.update({\n        where: { id: syncConfig.id },\n        data: {\n          lastSyncAt: completedAt,\n          lastSyncStatus: syncStatus.toLowerCase(),\n        },\n      });\n\n      // Create SyncLog entry\n      await context.entities.SyncLog.create({\n        data: {\n          syncConfigId: syncConfig.id,\n          status:\n            syncStatus === 'SUCCESS'\n              ? 'SUCCESS'\n              : syncStatus === 'PARTIAL'\n                ? 'PARTIAL'\n                : 'FAILED',\n          recordsSynced:\n            syncConfig.syncDirection === 'BIDIRECTIONAL'\n              ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n                (syncResult?.summary?.airtableToSheets?.updated || 0) +\n                (syncResult?.summary?.sheetsToAirtable?.added || 0) +\n                (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n              : (syncResult?.added || 0) + (syncResult?.updated || 0),\n          recordsFailed: errors.length,\n          errors:\n            errors.length > 0\n              ? JSON.stringify(\n                  errors.slice(0, 10).map((e) => ({\n                    message: e.message,\n                    recordId: e.recordId,\n                    type: e.type,\n                  }))\n                )\n              : null,\n          startedAt,\n          completedAt,\n          triggeredBy: 'initial',\n          direction: syncConfig.syncDirection,\n        },\n      });\n\n      console.log('[InitialSync] Sync metadata updated');\n    } catch (error) {\n      // Edge case: Failed to update metadata (non-fatal)\n      console.error('[InitialSync] Failed to update metadata:', error);\n      warnings.push('Failed to update sync metadata in database');\n    }\n  } else {\n    console.log('[InitialSync] Skipping metadata update (dry run)');\n  }\n\n  // ==========================================================================\n  // STEP 9: Build and return result\n  // ==========================================================================\n  console.log('[InitialSync] Building result...');\n\n  let message: string;\n  if (args.dryRun) {\n    message = syncStatus === 'SUCCESS'\n      ? 'Dry run completed successfully. No changes were made.'\n      : syncStatus === 'PARTIAL'\n        ? `Dry run completed with ${errors.length} potential error(s). No changes were made.`\n        : 'Dry run failed. No changes were made.';\n  } else {\n    message = syncStatus === 'SUCCESS'\n      ? 'Initial sync completed successfully'\n      : syncStatus === 'PARTIAL'\n        ? `Initial sync completed with ${errors.length} error(s)`\n        : 'Initial sync failed';\n  }\n\n  const result: ManualSyncResult = {\n    status: syncStatus,\n    message,\n    details: {\n      added:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.added || 0)\n          : syncResult?.added || 0,\n      updated:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.updated || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n          : syncResult?.updated || 0,\n      deleted:\n        syncConfig.syncDirection === 'BIDIRECTIONAL'\n          ? (syncResult?.summary?.airtableToSheets?.deleted || 0) +\n            (syncResult?.summary?.sheetsToAirtable?.deleted || 0)\n          : syncResult?.deleted || 0,\n      total: syncResult?.total || 0,\n      errorCount: errors.length,\n      duration,\n      direction: syncConfig.syncDirection,\n      startedAt: startedAt.toISOString(),\n      completedAt: completedAt.toISOString(),\n    },\n    errors:\n      errors.length > 0\n        ? errors.slice(0, 20).map((e) => ({\n            message: e.message,\n            type: e.type,\n            recordId: e.recordId,\n          }))\n        : undefined,\n    warnings: warnings.length > 0 ? warnings : undefined,\n    conflicts:\n      syncConfig.syncDirection === 'BIDIRECTIONAL'\n        ? syncResult?.summary?.conflicts\n        : undefined,\n  };\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('[InitialSync] Initial sync completed');\n  console.log('[InitialSync] Dry run:', args.dryRun || false);\n  console.log('[InitialSync] Status:', syncStatus);\n  console.log('[InitialSync] Duration:', duration, 'ms');\n  console.log('[InitialSync] Records: +', result.details.added, 'â†»', result.details.updated, '-', result.details.deleted);\n  if (errors.length > 0) {\n    console.log('[InitialSync] Errors:', errors.length);\n  }\n  if (warnings.length > 0) {\n    console.log('[InitialSync] Warnings:', warnings.length);\n  }\n  console.log('='.repeat(80) + '\\n');\n\n  return result;\n};\n","import { prisma } from 'wasp/server'\n\nimport { triggerManualSync } from '../../../../../src/server/actions/sync'\n\n\nexport default async function (args, context) {\n  return (triggerManualSync as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport triggerManualSync from '../../actions/triggerManualSync.js'\n\nexport default createAction(triggerManualSync)\n","import { prisma } from 'wasp/server'\n\nimport { runInitialSync } from '../../../../../src/server/actions/sync'\n\n\nexport default async function (args, context) {\n  return (runInitialSync as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport runInitialSync from '../../actions/runInitialSync.js'\n\nexport default createAction(runInitialSync)\n","/**\n * Wasp actions for managing sync configurations\n */\n\n// @ts-nocheck\n// Type checking disabled temporarily until Wasp regenerates types\nimport type { User, SyncConfig } from 'wasp/entities';\nimport type {\n  CreateSyncConfig,\n  UpdateSyncConfig,\n  DeleteSyncConfig,\n  ToggleSyncActive,\n} from 'wasp/server/operations';\nimport { checkSyncConfigLimit } from '../middleware/usageLimits';\nimport { trackSyncConfigCreated } from '../utils/usageTracker';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype CreateSyncConfigInput = {\n  name: string;\n  airtableBaseId: string;\n  airtableBaseName?: string;\n  airtableTableId: string;\n  airtableTableName?: string;\n  airtableViewId?: string; // Optional: for exact row order matching\n  googleSpreadsheetId: string;\n  googleSpreadsheetName?: string;\n  googleSheetId: string;\n  googleSheetName?: string;\n  fieldMappings: Record<string, number>; // { airtableFieldId: sheetsColumnIndex }\n  syncDirection: 'AIRTABLE_TO_SHEETS' | 'SHEETS_TO_AIRTABLE' | 'BIDIRECTIONAL';\n  conflictResolution?: 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS';\n};\n\ntype CreateSyncConfigOutput = {\n  id: string;\n  name: string;\n  isActive: boolean;\n};\n\ntype UpdateSyncConfigInput = {\n  syncConfigId: string;\n  name?: string;\n  fieldMappings?: Record<string, number>;\n  syncDirection?: 'AIRTABLE_TO_SHEETS' | 'SHEETS_TO_AIRTABLE' | 'BIDIRECTIONAL';\n  conflictResolution?: 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS';\n};\n\ntype UpdateSyncConfigOutput = {\n  id: string;\n  name: string;\n  isActive: boolean;\n};\n\ntype DeleteSyncConfigInput = {\n  syncConfigId: string;\n};\n\ntype DeleteSyncConfigOutput = {\n  success: boolean;\n};\n\ntype ToggleSyncActiveInput = {\n  syncConfigId: string;\n  isActive: boolean;\n};\n\ntype ToggleSyncActiveOutput = {\n  id: string;\n  isActive: boolean;\n};\n\n// ============================================================================\n// Action: Create Sync Configuration\n// ============================================================================\n\n/**\n * Creates a new sync configuration\n * Validates inputs and ensures user has necessary OAuth connections\n */\nexport const createSyncConfig: CreateSyncConfig<\n  CreateSyncConfigInput,\n  CreateSyncConfigOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  // Validate required fields\n  if (!args.name || args.name.trim().length === 0) {\n    throw new Error('Sync name is required');\n  }\n\n  if (!args.airtableBaseId || !args.airtableTableId) {\n    throw new Error('Airtable base and table are required');\n  }\n\n  if (!args.googleSpreadsheetId || !args.googleSheetId) {\n    throw new Error('Google Spreadsheet and Sheet are required');\n  }\n\n  if (!args.fieldMappings || Object.keys(args.fieldMappings).length === 0) {\n    throw new Error('At least one field mapping is required');\n  }\n\n  if (!args.syncDirection) {\n    throw new Error('Sync direction is required');\n  }\n\n  // Validate conflict resolution for bidirectional syncs\n  if (args.syncDirection === 'BIDIRECTIONAL' && !args.conflictResolution) {\n    throw new Error('Conflict resolution is required for bidirectional syncs');\n  }\n\n  // Check if user has Airtable connection\n  const airtableConnection = await context.entities.AirtableConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!airtableConnection) {\n    throw new Error(\n      'Airtable account not connected. Please connect your Airtable account first.'\n    );\n  }\n\n  // Check if user has Google Sheets connection\n  const googleConnection = await context.entities.GoogleSheetsConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!googleConnection) {\n    throw new Error(\n      'Google account not connected. Please connect your Google account first.'\n    );\n  }\n\n  // Check usage limits - count existing sync configs\n  const currentSyncCount = await context.entities.SyncConfig.count({\n    where: { userId: context.user.id },\n  });\n\n  const limitCheck = checkSyncConfigLimit(context.user, currentSyncCount);\n  if (limitCheck.exceeded) {\n    throw new Error(limitCheck.message);\n  }\n\n  try {\n    // Create the sync configuration\n    const syncConfig = await context.entities.SyncConfig.create({\n      data: {\n        userId: context.user.id,\n        name: args.name.trim(),\n        airtableBaseId: args.airtableBaseId,\n        airtableTableId: args.airtableTableId,\n        airtableTableName: args.airtableTableName,\n        airtableViewId: args.airtableViewId, // Store view ID for exact ordering\n        googleSpreadsheetId: args.googleSpreadsheetId,\n        googleSheetId: args.googleSheetId,\n        googleSheetName: args.googleSheetName,\n        fieldMappings: JSON.stringify(args.fieldMappings),\n        syncDirection: args.syncDirection,\n        conflictResolution: args.conflictResolution || 'NEWEST_WINS',\n        isActive: true,\n      },\n    });\n\n    console.log(`Created sync config: ${syncConfig.id} (${syncConfig.name})`);\n\n    // Track usage for billing/limits\n    await trackSyncConfigCreated(context.user.id);\n\n    return {\n      id: syncConfig.id,\n      name: syncConfig.name,\n      isActive: syncConfig.isActive,\n    };\n  } catch (error) {\n    console.error('Failed to create sync configuration:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to create sync configuration: ${error.message}`);\n    }\n\n    throw new Error('Failed to create sync configuration. Please try again.');\n  }\n};\n\n// ============================================================================\n// Action: Update Sync Configuration\n// ============================================================================\n\n/**\n * Updates an existing sync configuration\n * User must own the sync configuration to update it\n */\nexport const updateSyncConfig: UpdateSyncConfig<\n  UpdateSyncConfigInput,\n  UpdateSyncConfigOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { syncConfigId, ...updates } = args;\n\n  if (!syncConfigId) {\n    throw new Error('Sync configuration ID is required');\n  }\n\n  // Check if sync config exists and user owns it\n  const existingConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: syncConfigId },\n  });\n\n  if (!existingConfig) {\n    throw new Error('Sync configuration not found');\n  }\n\n  if (existingConfig.userId !== context.user.id) {\n    throw new Error('You do not have permission to update this sync configuration');\n  }\n\n  // Validate conflict resolution for bidirectional syncs\n  const finalSyncDirection = updates.syncDirection || existingConfig.syncDirection;\n  if (finalSyncDirection === 'BIDIRECTIONAL') {\n    const finalConflictResolution =\n      updates.conflictResolution ||\n      (existingConfig.conflictResolution as 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS');\n    if (!finalConflictResolution) {\n      throw new Error('Conflict resolution is required for bidirectional syncs');\n    }\n  }\n\n  try {\n    // Prepare update data\n    const updateData: any = {};\n\n    if (updates.name !== undefined) {\n      updateData.name = updates.name.trim();\n    }\n\n    if (updates.fieldMappings !== undefined) {\n      if (Object.keys(updates.fieldMappings).length === 0) {\n        throw new Error('At least one field mapping is required');\n      }\n      updateData.fieldMappings = JSON.stringify(updates.fieldMappings);\n    }\n\n    if (updates.syncDirection !== undefined) {\n      updateData.syncDirection = updates.syncDirection;\n    }\n\n    if (updates.conflictResolution !== undefined) {\n      updateData.conflictResolution = updates.conflictResolution;\n    }\n\n    // Update the sync configuration\n    const updatedConfig = await context.entities.SyncConfig.update({\n      where: { id: syncConfigId },\n      data: updateData,\n    });\n\n    console.log(`Updated sync config: ${updatedConfig.id} (${updatedConfig.name})`);\n\n    return {\n      id: updatedConfig.id,\n      name: updatedConfig.name,\n      isActive: updatedConfig.isActive,\n    };\n  } catch (error) {\n    console.error('Failed to update sync configuration:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to update sync configuration: ${error.message}`);\n    }\n\n    throw new Error('Failed to update sync configuration. Please try again.');\n  }\n};\n\n// ============================================================================\n// Action: Delete Sync Configuration\n// ============================================================================\n\n/**\n * Deletes a sync configuration and all associated sync logs\n * User must own the sync configuration to delete it\n */\nexport const deleteSyncConfig: DeleteSyncConfig<\n  DeleteSyncConfigInput,\n  DeleteSyncConfigOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { syncConfigId } = args;\n\n  if (!syncConfigId) {\n    throw new Error('Sync configuration ID is required');\n  }\n\n  // Check if sync config exists and user owns it\n  const existingConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: syncConfigId },\n  });\n\n  if (!existingConfig) {\n    throw new Error('Sync configuration not found');\n  }\n\n  if (existingConfig.userId !== context.user.id) {\n    throw new Error('You do not have permission to delete this sync configuration');\n  }\n\n  try {\n    // Delete the sync configuration (sync logs will be cascade deleted due to schema)\n    await context.entities.SyncConfig.delete({\n      where: { id: syncConfigId },\n    });\n\n    console.log(`Deleted sync config: ${syncConfigId} (${existingConfig.name})`);\n\n    return {\n      success: true,\n    };\n  } catch (error) {\n    console.error('Failed to delete sync configuration:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to delete sync configuration: ${error.message}`);\n    }\n\n    throw new Error('Failed to delete sync configuration. Please try again.');\n  }\n};\n\n// ============================================================================\n// Action: Toggle Sync Active Status\n// ============================================================================\n\n/**\n * Pauses or resumes a sync configuration\n * User must own the sync configuration to toggle it\n */\nexport const toggleSyncActive: ToggleSyncActive<\n  ToggleSyncActiveInput,\n  ToggleSyncActiveOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { syncConfigId, isActive } = args;\n\n  if (!syncConfigId) {\n    throw new Error('Sync configuration ID is required');\n  }\n\n  if (typeof isActive !== 'boolean') {\n    throw new Error('isActive must be a boolean value');\n  }\n\n  // Check if sync config exists and user owns it\n  const existingConfig = await context.entities.SyncConfig.findUnique({\n    where: { id: syncConfigId },\n  });\n\n  if (!existingConfig) {\n    throw new Error('Sync configuration not found');\n  }\n\n  if (existingConfig.userId !== context.user.id) {\n    throw new Error('You do not have permission to modify this sync configuration');\n  }\n\n  try {\n    // Update the active status\n    const updatedConfig = await context.entities.SyncConfig.update({\n      where: { id: syncConfigId },\n      data: { isActive },\n    });\n\n    const statusText = isActive ? 'resumed' : 'paused';\n    console.log(`Sync config ${statusText}: ${updatedConfig.id} (${updatedConfig.name})`);\n\n    return {\n      id: updatedConfig.id,\n      isActive: updatedConfig.isActive,\n    };\n  } catch (error) {\n    console.error('Failed to toggle sync configuration status:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to toggle sync configuration: ${error.message}`);\n    }\n\n    throw new Error('Failed to toggle sync configuration. Please try again.');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { createSyncConfig } from '../../../../../src/server/actions/syncConfig'\n\n\nexport default async function (args, context) {\n  return (createSyncConfig as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport createSyncConfig from '../../actions/createSyncConfig.js'\n\nexport default createAction(createSyncConfig)\n","import { prisma } from 'wasp/server'\n\nimport { updateSyncConfig } from '../../../../../src/server/actions/syncConfig'\n\n\nexport default async function (args, context) {\n  return (updateSyncConfig as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport updateSyncConfig from '../../actions/updateSyncConfig.js'\n\nexport default createAction(updateSyncConfig)\n","import { prisma } from 'wasp/server'\n\nimport { deleteSyncConfig } from '../../../../../src/server/actions/syncConfig'\n\n\nexport default async function (args, context) {\n  return (deleteSyncConfig as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport deleteSyncConfig from '../../actions/deleteSyncConfig.js'\n\nexport default createAction(deleteSyncConfig)\n","import { prisma } from 'wasp/server'\n\nimport { toggleSyncActive } from '../../../../../src/server/actions/syncConfig'\n\n\nexport default async function (args, context) {\n  return (toggleSyncActive as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport toggleSyncActive from '../../actions/toggleSyncActive.js'\n\nexport default createAction(toggleSyncActive)\n","/**\n * Diagnostic Actions for Troubleshooting Sync Issues\n */\n\nimport { HttpError } from 'wasp/server';\nimport { getConnectionHealth } from '../utils/tokenManager';\nimport { decrypt } from '../airtable/encryption';\n\nexport interface DiagnosticResult {\n  airtable: {\n    connected: boolean;\n    needsReauth: boolean;\n    tokenExpiry: string | null;\n    lastRefreshError: string | null;\n    canDecryptTokens: boolean;\n  };\n  google: {\n    connected: boolean;\n    needsReauth: boolean;\n    tokenExpiry: string | null;\n    lastRefreshError: string | null;\n    canDecryptTokens: boolean;\n  };\n  recommendations: string[];\n  [key: string]: any;\n}\n\n/**\n * Run diagnostics on user's OAuth connections\n */\nexport const runConnectionDiagnostics = async (\n  _args: unknown,\n  context: any\n): Promise<DiagnosticResult> => {\n  const userId = context.user.id;\n  const recommendations: string[] = [];\n\n  console.log('[Diagnostics] Running connection diagnostics for user:', userId);\n\n  // Fetch connection data directly\n  const airtableConnection = await context.entities.AirtableConnection.findUnique({\n    where: { userId },\n  });\n\n  const googleConnection = await context.entities.GoogleSheetsConnection.findUnique({\n    where: { userId },\n  });\n\n  // Check Airtable connection\n  let airtableCanDecrypt = false;\n  if (airtableConnection) {\n    try {\n      decrypt(airtableConnection.accessToken);\n      decrypt(airtableConnection.refreshToken);\n      airtableCanDecrypt = true;\n    } catch (error) {\n      console.error('[Diagnostics] Failed to decrypt Airtable tokens:', error);\n      recommendations.push('Airtable tokens cannot be decrypted. Please reconnect your Airtable account.');\n    }\n\n    if (airtableConnection.needsReauth) {\n      recommendations.push('Airtable connection is marked as needing reauth. Please reconnect.');\n    }\n\n    if (airtableConnection.tokenExpiry && new Date(airtableConnection.tokenExpiry) < new Date()) {\n      recommendations.push('Airtable token is expired. It should auto-refresh on next sync.');\n    }\n  } else {\n    recommendations.push('No Airtable connection found. Please connect your Airtable account.');\n  }\n\n  // Check Google connection\n  let googleCanDecrypt = false;\n  if (googleConnection) {\n    try {\n      decrypt(googleConnection.accessToken);\n      decrypt(googleConnection.refreshToken);\n      googleCanDecrypt = true;\n    } catch (error) {\n      console.error('[Diagnostics] Failed to decrypt Google tokens:', error);\n      recommendations.push('Google Sheets tokens cannot be decrypted. Please reconnect your Google account.');\n    }\n\n    if (googleConnection.needsReauth) {\n      recommendations.push('Google Sheets connection is marked as needing reauth. Please reconnect.');\n    }\n\n    if (googleConnection.tokenExpiry && new Date(googleConnection.tokenExpiry) < new Date()) {\n      recommendations.push('Google Sheets token is expired. It should auto-refresh on next sync.');\n    }\n  } else {\n    recommendations.push('No Google Sheets connection found. Please connect your Google account.');\n  }\n\n  return {\n    airtable: {\n      connected: !!airtableConnection,\n      needsReauth: airtableConnection?.needsReauth || false,\n      tokenExpiry: airtableConnection?.tokenExpiry?.toISOString() || null,\n      lastRefreshError: airtableConnection?.lastRefreshError || null,\n      canDecryptTokens: airtableCanDecrypt,\n    },\n    google: {\n      connected: !!googleConnection,\n      needsReauth: googleConnection?.needsReauth || false,\n      tokenExpiry: googleConnection?.tokenExpiry?.toISOString() || null,\n      lastRefreshError: googleConnection?.lastRefreshError || null,\n      canDecryptTokens: googleCanDecrypt,\n    },\n    recommendations,\n  };\n};\n\n/**\n * Force clear the needsReauth flag (use after manual reconnection)\n */\nexport const clearReauthFlags = async (\n  _args: unknown,\n  context: any\n): Promise<{ success: boolean; message: string }> => {\n  const userId = context.user.id;\n\n  console.log('[Diagnostics] Clearing reauth flags for user:', userId);\n\n  try {\n    // Clear Airtable reauth flag\n    const airtableConnection = await context.entities.AirtableConnection.findUnique({\n      where: { userId },\n    });\n\n    if (airtableConnection) {\n      await context.entities.AirtableConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: false,\n          lastRefreshError: null,\n        },\n      });\n      console.log('[Diagnostics] Cleared Airtable reauth flag');\n    }\n\n    // Clear Google reauth flag\n    const googleConnection = await context.entities.GoogleSheetsConnection.findUnique({\n      where: { userId },\n    });\n\n    if (googleConnection) {\n      await context.entities.GoogleSheetsConnection.update({\n        where: { userId },\n        data: {\n          needsReauth: false,\n          lastRefreshError: null,\n        },\n      });\n      console.log('[Diagnostics] Cleared Google Sheets reauth flag');\n    }\n\n    return {\n      success: true,\n      message: 'Cleared reauth flags for both connections. Try running a sync now.',\n    };\n  } catch (error) {\n    console.error('[Diagnostics] Failed to clear reauth flags:', error);\n    throw new HttpError(500, 'Failed to clear reauth flags');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { runConnectionDiagnostics } from '../../../../../src/server/actions/diagnostics'\n\n\nexport default async function (args, context) {\n  return (runConnectionDiagnostics as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport runConnectionDiagnostics from '../../actions/runConnectionDiagnostics.js'\n\nexport default createAction(runConnectionDiagnostics)\n","import { prisma } from 'wasp/server'\n\nimport { clearReauthFlags } from '../../../../../src/server/actions/diagnostics'\n\n\nexport default async function (args, context) {\n  return (clearReauthFlags as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport clearReauthFlags from '../../actions/clearReauthFlags.js'\n\nexport default createAction(clearReauthFlags)\n","import {\n  type GetPasswordResetEmailContentFn,\n  type GetVerificationEmailContentFn,\n} from \"wasp/server/auth\";\n\nexport const getVerificationEmailContent: GetVerificationEmailContentFn = ({\n  verificationLink,\n}) => ({\n  subject: \"Verify your email\",\n  text: `Click the link below to verify your email: ${verificationLink}`,\n  html: `\n        <p>Click the link below to verify your email</p>\n        <a href=\"${verificationLink}\">Verify email</a>\n    `,\n});\n\nexport const getPasswordResetEmailContent: GetPasswordResetEmailContentFn = ({\n  passwordResetLink,\n}) => ({\n  subject: \"Password reset\",\n  text: `Click the link below to reset your password: ${passwordResetLink}`,\n  html: `\n        <p>Click the link below to reset your password</p>\n        <a href=\"${passwordResetLink}\">Reset password</a>\n    `,\n});\n","import { HttpError } from \"wasp/server\";\nimport { emailSender } from \"wasp/server/email\";\nimport {\n  getApproachingLimitEmailContent,\n  getLimitReachedEmailContent,\n  getTrialEndingSoonEmailContent,\n  getSyncFailedEmailContent,\n} from \"./baseSyncEmails\";\nimport {\n  getPasswordResetEmailContent,\n  getVerificationEmailContent,\n} from \"../../auth/email-and-pass/emails\";\n\ntype SendTestEmailsArgs = {\n  to: string;\n};\n\nexport const sendTestEmails = async (\n  args: SendTestEmailsArgs,\n  context: any\n): Promise<{ sent: number }> => {\n  if (!context.user) {\n    throw new HttpError(401, \"User must be authenticated\");\n  }\n  if (!context.user.isAdmin) {\n    throw new HttpError(403, \"Admin access required\");\n  }\n  if (!args?.to) {\n    throw new HttpError(400, \"Missing destination email\");\n  }\n\n  const appUrl = process.env.WASP_WEB_CLIENT_URL || \"https://basesync.app\";\n\n  const emails = [\n    getVerificationEmailContent({\n      verificationLink: `${appUrl}/email-verification?token=test-token`,\n    }),\n    getPasswordResetEmailContent({\n      passwordResetLink: `${appUrl}/password-reset?token=test-token`,\n    }),\n    getApproachingLimitEmailContent({\n      userName: \"Test User\",\n      limitType: \"records\",\n      currentUsage: 800,\n      limit: 1000,\n      planName: \"Starter\",\n      upgradePlanName: \"Pro\",\n      upgradeUrl: `${appUrl}/pricing`,\n    }),\n    getLimitReachedEmailContent({\n      userName: \"Test User\",\n      limitType: \"syncs\",\n      currentUsage: 3,\n      limit: 3,\n      planName: \"Pro\",\n      upgradePlanName: \"Business\",\n      upgradeUrl: `${appUrl}/pricing`,\n    }),\n    getTrialEndingSoonEmailContent({\n      userName: \"Test User\",\n      daysRemaining: 3,\n      recordsSynced: 12450,\n      syncConfigsCount: 2,\n      pricingUrl: `${appUrl}/pricing`,\n    }),\n    getSyncFailedEmailContent({\n      userName: \"Test User\",\n      syncName: \"Customer Sync\",\n      errorMessage: \"Airtable token expired (simulated)\",\n      dashboardUrl: `${appUrl}/dashboard`,\n    }),\n  ];\n\n  for (const content of emails) {\n    await emailSender.send({\n      to: args.to,\n      ...content,\n    });\n  }\n\n  return { sent: emails.length };\n};\n","import { prisma } from 'wasp/server'\n\nimport { sendTestEmails } from '../../../../../src/server/emails/testSender'\n\n\nexport default async function (args, context) {\n  return (sendTestEmails as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createAction } from '../../middleware/operations.js'\nimport sendTestEmails from '../../actions/sendTestEmails.js'\n\nexport default createAction(sendTestEmails)\n","import { prisma } from 'wasp/server'\n\nimport { getPaginatedUsers } from '../../../../../src/user/operations'\n\n\nexport default async function (args, context) {\n  return (getPaginatedUsers as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getPaginatedUsers from '../../queries/getPaginatedUsers.js'\n\nexport default createQuery(getPaginatedUsers)\n","import { prisma } from 'wasp/server'\n\nimport { exportUserData } from '../../../../../src/user/dangerZone'\n\n\nexport default async function (args, context) {\n  return (exportUserData as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport exportUserData from '../../queries/exportUserData.js'\n\nexport default createQuery(exportUserData)\n","import { prisma } from 'wasp/server'\n\nimport { getCustomerPortalUrl } from '../../../../../src/payment/operations'\n\n\nexport default async function (args, context) {\n  return (getCustomerPortalUrl as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getCustomerPortalUrl from '../../queries/getCustomerPortalUrl.js'\n\nexport default createQuery(getCustomerPortalUrl)\n","import { type DailyStats, type PageViewSource } from \"wasp/entities\";\nimport { HttpError, prisma } from \"wasp/server\";\nimport { type GetDailyStats } from \"wasp/server/operations\";\n\ntype DailyStatsWithSources = DailyStats & {\n  sources: PageViewSource[];\n};\n\ntype DailyStatsValues = {\n  dailyStats: DailyStatsWithSources;\n  weeklyStats: DailyStatsWithSources[];\n};\n\nexport const getDailyStats: GetDailyStats<\n  void,\n  DailyStatsValues | undefined\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new HttpError(\n      401,\n      \"Only authenticated users are allowed to perform this operation\",\n    );\n  }\n\n  if (!context.user.isAdmin) {\n    throw new HttpError(\n      403,\n      \"Only admins are allowed to perform this operation\",\n    );\n  }\n\n  const statsQuery = {\n    orderBy: {\n      date: \"desc\",\n    },\n    include: {\n      sources: true,\n    },\n  } as const;\n\n  const [dailyStats, weeklyStats] = await prisma.$transaction([\n    context.entities.DailyStats.findFirst(statsQuery),\n    context.entities.DailyStats.findMany({ ...statsQuery, take: 7 }),\n  ]);\n\n  if (!dailyStats) {\n    console.log(\n      \"\\x1b[34mNote: No daily stats have been generated by the dailyStatsJob yet. \\x1b[0m\",\n    );\n    return undefined;\n  }\n\n  return { dailyStats, weeklyStats };\n};\n","import { prisma } from 'wasp/server'\n\nimport { getDailyStats } from '../../../../../src/analytics/operations'\n\n\nexport default async function (args, context) {\n  return (getDailyStats as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      DailyStats: prisma.dailyStats,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getDailyStats from '../../queries/getDailyStats.js'\n\nexport default createQuery(getDailyStats)\n","import { prisma } from 'wasp/server'\n\nimport { getAdminOverviewStats } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getAdminOverviewStats as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncLog: prisma.syncLog,\n      SyncConfig: prisma.syncConfig,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getAdminOverviewStats from '../../queries/getAdminOverviewStats.js'\n\nexport default createQuery(getAdminOverviewStats)\n","import { prisma } from 'wasp/server'\n\nimport { getRecentActivity } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getRecentActivity as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncLog: prisma.syncLog,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getRecentActivity from '../../queries/getRecentActivity.js'\n\nexport default createQuery(getRecentActivity)\n","import { prisma } from 'wasp/server'\n\nimport { searchUsers } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (searchUsers as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport searchUsers from '../../queries/searchUsers.js'\n\nexport default createQuery(searchUsers)\n","import { prisma } from 'wasp/server'\n\nimport { getOnlineUsers } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getOnlineUsers as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getOnlineUsers from '../../queries/getOnlineUsers.js'\n\nexport default createQuery(getOnlineUsers)\n","import { prisma } from 'wasp/server'\n\nimport { getUserDetail } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getUserDetail as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getUserDetail from '../../queries/getUserDetail.js'\n\nexport default createQuery(getUserDetail)\n","import { prisma } from 'wasp/server'\n\nimport { getActiveSyncs } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getActiveSyncs as any)(args, {\n    ...context,\n    entities: {\n      SyncLog: prisma.syncLog,\n      SyncConfig: prisma.syncConfig,\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getActiveSyncs from '../../queries/getActiveSyncs.js'\n\nexport default createQuery(getActiveSyncs)\n","import { prisma } from 'wasp/server'\n\nimport { getFailedSyncs } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getFailedSyncs as any)(args, {\n    ...context,\n    entities: {\n      SyncLog: prisma.syncLog,\n      SyncConfig: prisma.syncConfig,\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getFailedSyncs from '../../queries/getFailedSyncs.js'\n\nexport default createQuery(getFailedSyncs)\n","import { prisma } from 'wasp/server'\n\nimport { getSyncMonitor } from '../../../../../src/server/admin/operations'\n\n\nexport default async function (args, context) {\n  return (getSyncMonitor as any)(args, {\n    ...context,\n    entities: {\n      SyncLog: prisma.syncLog,\n      SyncConfig: prisma.syncConfig,\n      User: prisma.user,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getSyncMonitor from '../../queries/getSyncMonitor.js'\n\nexport default createQuery(getSyncMonitor)\n","import { prisma } from 'wasp/server'\n\nimport { getAirtableConnectionStatus } from '../../../../../src/server/airtable/operations'\n\n\nexport default async function (args, context) {\n  return (getAirtableConnectionStatus as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getAirtableConnectionStatus from '../../queries/getAirtableConnectionStatus.js'\n\nexport default createQuery(getAirtableConnectionStatus)\n","/**\n * Wasp queries for Airtable data access\n * These functions fetch data from Airtable on behalf of authenticated users\n */\n\nimport type { User, AirtableConnection } from 'wasp/entities';\nimport type {\n  ListUserAirtableBases,\n  GetAirtableTableSchema,\n  GetAirtableBaseTables,\n} from 'wasp/server/operations';\nimport { getAirtableAccessToken } from './auth';\nimport * as airtableClient from './client';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype ListUserAirtableBasesInput = void;\ntype ListUserAirtableBasesOutput = Array<{\n  id: string;\n  name: string;\n  permissionLevel: string;\n}>;\n\ntype GetAirtableTableSchemaInput = {\n  baseId: string;\n  tableId: string;\n};\ntype GetAirtableTableSchemaOutput = {\n  id: string;\n  name: string;\n  description?: string;\n  primaryFieldId: string;\n  fields: Array<{\n    id: string;\n    name: string;\n    type: string;\n    description?: string;\n    options?: Record<string, any>;\n  }>;\n};\n\ntype GetAirtableBaseTablesInput = {\n  baseId: string;\n};\ntype GetAirtableBaseTablesOutput = Array<{\n  id: string;\n  name: string;\n  description?: string;\n  primaryFieldId: string;\n}>;\n\n// ============================================================================\n// Query: List User's Airtable Bases\n// ============================================================================\n\n/**\n * Lists all Airtable bases accessible to the authenticated user\n * Automatically refreshes token if expired\n */\nexport const listUserAirtableBases: ListUserAirtableBases<\n  ListUserAirtableBasesInput,\n  ListUserAirtableBasesOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  // Check if user has Airtable connection\n  const connection = await context.entities.AirtableConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Airtable account not connected. Please connect your Airtable account first.'\n    );\n  }\n\n  try {\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getAirtableAccessToken(\n      context.user.id,\n      context.entities.AirtableConnection as any\n    );\n\n    // Fetch bases from Airtable\n    const bases = await airtableClient.listBases(accessToken);\n\n    // Return simplified base data\n    return bases.map((base) => ({\n      id: base.id,\n      name: base.name,\n      permissionLevel: base.permissionLevel,\n    }));\n  } catch (error) {\n    console.error('Failed to list Airtable bases:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof Error) {\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Airtable connection has expired. Please reconnect your Airtable account.'\n        );\n      }\n      if (error.message.includes('AIRTABLE_CLIENT_ID')) {\n        throw new Error('Airtable integration is not configured. Please contact support.');\n      }\n      throw new Error(`Failed to fetch Airtable bases: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch Airtable bases. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Airtable Table Schema\n// ============================================================================\n\n/**\n * Gets the schema (fields) for a specific Airtable table\n * Automatically refreshes token if expired\n */\nexport const getAirtableTableSchema: GetAirtableTableSchema<\n  GetAirtableTableSchemaInput,\n  GetAirtableTableSchemaOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { baseId, tableId } = args;\n\n  if (!baseId || !tableId) {\n    throw new Error('Base ID and Table ID are required');\n  }\n\n  // Check if user has Airtable connection\n  const connection = await context.entities.AirtableConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Airtable account not connected. Please connect your Airtable account first.'\n    );\n  }\n\n  try {\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getAirtableAccessToken(\n      context.user.id,\n      context.entities.AirtableConnection as any\n    );\n\n    // Fetch base schema from Airtable\n    const baseSchema = await airtableClient.getBaseSchema(accessToken, baseId);\n\n    // Find the specific table\n    const table = baseSchema.tables.find((t) => t.id === tableId);\n\n    if (!table) {\n      throw new Error(`Table with ID \"${tableId}\" not found in base \"${baseId}\"`);\n    }\n\n    // Return the table schema\n    return {\n      id: table.id,\n      name: table.name,\n      description: table.description,\n      primaryFieldId: table.primaryFieldId,\n      fields: table.fields.map((field) => ({\n        id: field.id,\n        name: field.name,\n        type: field.type,\n        description: field.description,\n        options: field.options,\n      })),\n    };\n  } catch (error) {\n    console.error('Failed to get Airtable table schema:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof Error) {\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Airtable connection has expired. Please reconnect your Airtable account.'\n        );\n      }\n      if (error.message.includes('not found')) {\n        throw error; // Re-throw \"not found\" errors as-is\n      }\n      if (error.message.includes('AIRTABLE_CLIENT_ID')) {\n        throw new Error('Airtable integration is not configured. Please contact support.');\n      }\n      throw new Error(`Failed to fetch table schema: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch table schema. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Airtable Base Tables\n// ============================================================================\n\n/**\n * Gets the list of tables in a specific Airtable base\n * Automatically refreshes token if expired\n */\nexport const getAirtableBaseTables: GetAirtableBaseTables<\n  GetAirtableBaseTablesInput,\n  GetAirtableBaseTablesOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { baseId } = args;\n\n  if (!baseId) {\n    throw new Error('Base ID is required');\n  }\n\n  // Check if user has Airtable connection\n  const connection = await context.entities.AirtableConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Airtable account not connected. Please connect your Airtable account first.'\n    );\n  }\n\n  try {\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getAirtableAccessToken(\n      context.user.id,\n      context.entities.AirtableConnection as any\n    );\n\n    // Fetch base schema from Airtable\n    const baseSchema = await airtableClient.getBaseSchema(accessToken, baseId);\n\n    // Return simplified table data (without full field details)\n    return baseSchema.tables.map((table) => ({\n      id: table.id,\n      name: table.name,\n      description: table.description,\n      primaryFieldId: table.primaryFieldId,\n    }));\n  } catch (error) {\n    console.error('Failed to get Airtable base tables:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof Error) {\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Airtable connection has expired. Please reconnect your Airtable account.'\n        );\n      }\n      if (error.message.includes('AIRTABLE_CLIENT_ID')) {\n        throw new Error('Airtable integration is not configured. Please contact support.');\n      }\n      throw new Error(`Failed to fetch base tables: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch base tables. Please try again.');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { listUserAirtableBases } from '../../../../../src/server/airtable/queries'\n\n\nexport default async function (args, context) {\n  return (listUserAirtableBases as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport listUserAirtableBases from '../../queries/listUserAirtableBases.js'\n\nexport default createQuery(listUserAirtableBases)\n","import { prisma } from 'wasp/server'\n\nimport { getAirtableTableSchema } from '../../../../../src/server/airtable/queries'\n\n\nexport default async function (args, context) {\n  return (getAirtableTableSchema as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getAirtableTableSchema from '../../queries/getAirtableTableSchema.js'\n\nexport default createQuery(getAirtableTableSchema)\n","import { prisma } from 'wasp/server'\n\nimport { getAirtableBaseTables } from '../../../../../src/server/airtable/queries'\n\n\nexport default async function (args, context) {\n  return (getAirtableBaseTables as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      AirtableConnection: prisma.airtableConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getAirtableBaseTables from '../../queries/getAirtableBaseTables.js'\n\nexport default createQuery(getAirtableBaseTables)\n","import { prisma } from 'wasp/server'\n\nimport { getGoogleConnectionStatus } from '../../../../../src/server/google/operations'\n\n\nexport default async function (args, context) {\n  return (getGoogleConnectionStatus as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getGoogleConnectionStatus from '../../queries/getGoogleConnectionStatus.js'\n\nexport default createQuery(getGoogleConnectionStatus)\n","/**\n * Google Sheets URL Parser\n * Extracts spreadsheet ID and optional sheet ID from various Google Sheets URL formats\n */\n\n// Minimum length for valid Google Sheets spreadsheet IDs\nconst MIN_SPREADSHEET_ID_LENGTH = 20;\n\nexport interface ParsedGoogleSheetUrl {\n  spreadsheetId: string;\n  sheetId?: number;\n}\n\n/**\n * Parses a Google Sheets URL and extracts the spreadsheet ID and optional sheet ID (gid)\n *\n * Supported formats:\n * - https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/edit\n * - https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/edit#gid=SHEET_ID\n * - https://docs.google.com/spreadsheets/d/SPREADSHEET_ID/edit?usp=sharing#gid=SHEET_ID\n * - https://docs.google.com/spreadsheets/d/SPREADSHEET_ID\n * - https://docs.google.com/spreadsheets/d/SPREADSHEET_ID#gid=SHEET_ID\n * - docs.google.com/spreadsheets/d/SPREADSHEET_ID (without protocol)\n * - Or just the spreadsheet ID itself: SPREADSHEET_ID\n *\n * @param url - The Google Sheets URL or spreadsheet ID\n * @returns Object containing spreadsheetId and optional sheetId (gid)\n * @throws Error if the URL is invalid or doesn't match expected formats\n */\nexport function parseGoogleSheetUrl(url: string): ParsedGoogleSheetUrl {\n  if (!url || typeof url !== 'string') {\n    throw new Error('Invalid URL: URL must be a non-empty string');\n  }\n\n  // Trim whitespace\n  const trimmedUrl = url.trim();\n\n  if (!trimmedUrl) {\n    throw new Error('Invalid URL: URL cannot be empty');\n  }\n\n  // Pattern to match Google Sheets spreadsheet ID (alphanumeric, hyphens, underscores, typically 44 chars)\n  const spreadsheetIdPattern = new RegExp(`[a-zA-Z0-9_-]{${MIN_SPREADSHEET_ID_LENGTH},}`);\n\n  // Try to extract spreadsheet ID from full URL first\n  // Pattern: /d/{SPREADSHEET_ID}/ or /d/{SPREADSHEET_ID}#gid= or /d/{SPREADSHEET_ID}?\n  const fullUrlMatch = trimmedUrl.match(\n    new RegExp(`\\\\/spreadsheets\\\\/d\\\\/([a-zA-Z0-9_-]{${MIN_SPREADSHEET_ID_LENGTH},})(?:\\\\/|#|\\\\?|$)`, 'i')\n  );\n\n  let spreadsheetId: string;\n\n  if (fullUrlMatch && fullUrlMatch[1]) {\n    // Extracted from full URL\n    spreadsheetId = fullUrlMatch[1];\n  } else if (spreadsheetIdPattern.test(trimmedUrl) && !trimmedUrl.includes('/')) {\n    // Input is just the spreadsheet ID itself (no slashes, looks like an ID)\n    spreadsheetId = trimmedUrl;\n  } else {\n    // No lenient fallback - be strict about URL format\n    throw new Error(\n      'Invalid Google Sheets URL: Could not extract spreadsheet ID. ' +\n        'Please provide a valid Google Sheets URL (e.g., https://docs.google.com/spreadsheets/d/SPREADSHEET_ID) ' +\n        'or just the spreadsheet ID itself.'\n    );\n  }\n\n  // Validate spreadsheet ID format (should be alphanumeric with hyphens/underscores, typically 44 chars)\n  if (spreadsheetId.length < MIN_SPREADSHEET_ID_LENGTH) {\n    throw new Error(\n      'Invalid spreadsheet ID: ID appears too short. ' +\n        'Please check that you copied the full URL or spreadsheet ID.'\n    );\n  }\n\n  // Extract sheet ID (gid) if present\n  let sheetId: number | undefined;\n\n  // Look for #gid=NUMBER or &gid=NUMBER (case-sensitive - Google Sheets always uses lowercase)\n  const gidMatch = trimmedUrl.match(/[#&]gid=(\\d+)/);\n  if (gidMatch && gidMatch[1]) {\n    const parsedGid = parseInt(gidMatch[1], 10);\n    if (!isNaN(parsedGid)) {\n      sheetId = parsedGid;\n    }\n  }\n\n  return {\n    spreadsheetId,\n    ...(sheetId !== undefined && { sheetId }),\n  };\n}\n\n/**\n * Validates if a string is a valid Google Sheets URL or spreadsheet ID\n * Returns true if valid, false otherwise (no throw)\n *\n * @param url - The URL or spreadsheet ID to validate\n * @returns true if valid, false otherwise\n */\nexport function isValidGoogleSheetUrl(url: string): boolean {\n  try {\n    parseGoogleSheetUrl(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Constructs a Google Sheets URL from a spreadsheet ID and optional sheet ID\n *\n * @param spreadsheetId - The spreadsheet ID\n * @param sheetId - Optional sheet ID (gid)\n * @returns Fully formed Google Sheets URL\n */\nexport function constructGoogleSheetUrl(\n  spreadsheetId: string,\n  sheetId?: number\n): string {\n  // Validate spreadsheet ID\n  if (!spreadsheetId || spreadsheetId.length < MIN_SPREADSHEET_ID_LENGTH) {\n    throw new Error('Invalid spreadsheetId: must be at least 20 characters');\n  }\n\n  // URL-encode the spreadsheet ID to prevent potential XSS/URL issues\n  const encodedId = encodeURIComponent(spreadsheetId);\n  let url = `https://docs.google.com/spreadsheets/d/${encodedId}/edit`;\n\n  if (sheetId !== undefined) {\n    url += `#gid=${sheetId}`;\n  }\n\n  return url;\n}\n\n/**\n * Extracts just the spreadsheet ID from any valid input format\n * Convenience function that wraps parseGoogleSheetUrl\n *\n * @param url - The Google Sheets URL or spreadsheet ID\n * @returns Just the spreadsheet ID string\n * @throws Error if the URL is invalid\n */\nexport function extractSpreadsheetId(url: string): string {\n  const parsed = parseGoogleSheetUrl(url);\n  return parsed.spreadsheetId;\n}\n","/**\n * Wasp queries for Google Sheets data access\n * These functions fetch data from Google Sheets on behalf of authenticated users\n *\n * NOTE: Drive API query (listUserSpreadsheets) removed to avoid CASA assessment.\n * Users will paste spreadsheet URLs directly.\n */\n\nimport type { User, GoogleSheetsConnection } from 'wasp/entities';\nimport type {\n  GetSpreadsheetSheets,\n  GetSheetColumnHeaders,\n  ValidateSpreadsheetUrl,\n} from 'wasp/server/operations';\nimport { getGoogleSheetsAccessToken } from './auth';\nimport * as googleClient from './client';\nimport { parseGoogleSheetUrl } from './urlParser';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype ValidateSpreadsheetUrlInput = {\n  url: string;\n};\ntype ValidateSpreadsheetUrlOutput = {\n  spreadsheetId: string;\n  spreadsheetTitle: string;\n  sheets: Array<{\n    sheetId: number;\n    title: string;\n  }>;\n};\n\ntype GetSpreadsheetSheetsInput = {\n  spreadsheetId: string;\n};\ntype GetSpreadsheetSheetsOutput = {\n  spreadsheetId: string;\n  title: string;\n  spreadsheetUrl: string;\n  sheets: Array<{\n    sheetId: number;\n    title: string;\n    index: number;\n    rowCount: number;\n    columnCount: number;\n    hidden?: boolean;\n  }>;\n};\n\ntype GetSheetColumnHeadersInput = {\n  spreadsheetId: string;\n  sheetId: string | number; // Accept both sheet name and numeric gid\n};\ntype GetSheetColumnHeadersOutput = {\n  headers: string[];\n  columnCount: number;\n};\n\n// ============================================================================\n// Query: Validate Spreadsheet URL\n// ============================================================================\n\n/**\n * Validates a Google Sheets URL by parsing it and checking user has access\n * Replaces the need to browse Drive - user pastes URL directly\n */\nexport const validateSpreadsheetUrl: ValidateSpreadsheetUrl<\n  ValidateSpreadsheetUrlInput,\n  ValidateSpreadsheetUrlOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { url } = args;\n\n  if (!url || typeof url !== 'string' || !url.trim()) {\n    throw new Error('Please provide a valid Google Sheets URL');\n  }\n\n  // Check if user has Google Sheets connection\n  const connection = await context.entities.GoogleSheetsConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Google account not connected. Please connect your Google account first.'\n    );\n  }\n\n  try {\n    // Parse the URL to extract spreadsheet ID\n    const parsed = parseGoogleSheetUrl(url.trim());\n\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getGoogleSheetsAccessToken(\n      context.user.id,\n      context.entities.GoogleSheetsConnection as any\n    );\n\n    // Validate spreadsheet exists and user has access\n    const spreadsheet = await googleClient.validateAndGetSpreadsheet(\n      accessToken,\n      parsed.spreadsheetId\n    );\n\n    return {\n      spreadsheetId: spreadsheet.id,\n      spreadsheetTitle: spreadsheet.title,\n      sheets: spreadsheet.sheets,\n    };\n  } catch (error) {\n    console.error('Failed to validate Google Sheets URL:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof googleClient.GoogleSheetsError) {\n      // Already has a user-friendly message from validateAndGetSpreadsheet\n      throw error;\n    }\n\n    if (error instanceof Error) {\n      // Wrap URL parsing errors in user-friendly messages\n      if (error.message.includes('Invalid') || error.message.includes('spreadsheet')) {\n        throw new Error(\n          'Invalid Google Sheets URL. Please check the URL and try again.'\n        );\n      }\n\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Google connection has expired. Please reconnect your Google account.'\n        );\n      }\n\n      // Generic error - don't expose implementation details\n      throw new Error('Failed to validate spreadsheet. Please check the URL and try again.');\n    }\n\n    throw new Error('Failed to validate spreadsheet. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Spreadsheet Sheets\n// ============================================================================\n\n/**\n * Gets all sheets (tabs) within a specific Google Spreadsheet\n * Automatically refreshes token if expired\n */\nexport const getSpreadsheetSheets: GetSpreadsheetSheets<\n  GetSpreadsheetSheetsInput,\n  GetSpreadsheetSheetsOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { spreadsheetId } = args;\n\n  if (!spreadsheetId) {\n    throw new Error('Spreadsheet ID is required');\n  }\n\n  // Check if user has Google Sheets connection\n  const connection = await context.entities.GoogleSheetsConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Google account not connected. Please connect your Google account first.'\n    );\n  }\n\n  try {\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getGoogleSheetsAccessToken(\n      context.user.id,\n      context.entities.GoogleSheetsConnection as any\n    );\n\n    // Fetch spreadsheet metadata from Google Sheets API\n    const metadata = await googleClient.getSpreadsheet(accessToken, spreadsheetId);\n\n    // Return simplified sheet data\n    return {\n      spreadsheetId: metadata.spreadsheetId,\n      title: metadata.properties.title,\n      spreadsheetUrl: metadata.spreadsheetUrl,\n      sheets: metadata.sheets.map((sheet) => ({\n        sheetId: sheet.properties.sheetId,\n        title: sheet.properties.title,\n        index: sheet.properties.index,\n        rowCount: sheet.properties.gridProperties?.rowCount || 0,\n        columnCount: sheet.properties.gridProperties?.columnCount || 0,\n        hidden: sheet.properties.hidden,\n      })),\n    };\n  } catch (error) {\n    console.error('Failed to get spreadsheet sheets:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof googleClient.GoogleSheetsError) {\n      if (error.isAuthError) {\n        throw new Error(\n          'Your Google connection has expired or lacks permissions. Please reconnect your Google account.'\n        );\n      }\n      if (error.isQuotaError) {\n        throw new Error(\n          'Google API quota exceeded. Please try again later or contact support.'\n        );\n      }\n      if (error.statusCode === 404) {\n        throw new Error(\n          `Spreadsheet with ID \"${spreadsheetId}\" not found or you don't have access to it.`\n        );\n      }\n      throw new Error(`Failed to fetch spreadsheet: ${error.message}`);\n    }\n\n    if (error instanceof Error) {\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Google connection has expired. Please reconnect your Google account.'\n        );\n      }\n      if (error.message.includes('not found')) {\n        throw error; // Re-throw \"not found\" errors as-is\n      }\n      if (error.message.includes('GOOGLE_SHEETS_CLIENT_ID')) {\n        throw new Error('Google Sheets integration is not configured. Please contact support.');\n      }\n      throw new Error(`Failed to fetch spreadsheet: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch spreadsheet. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Sheet Column Headers\n// ============================================================================\n\n/**\n * Gets the column headers from the first row of a sheet\n * Automatically refreshes token if expired\n */\nexport const getSheetColumnHeaders: GetSheetColumnHeaders<\n  GetSheetColumnHeadersInput,\n  GetSheetColumnHeadersOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { spreadsheetId, sheetId } = args;\n\n  if (!spreadsheetId || sheetId === undefined) {\n    throw new Error('Spreadsheet ID and Sheet ID are required');\n  }\n\n  // Check if user has Google Sheets connection\n  const connection = await context.entities.GoogleSheetsConnection.findUnique({\n    where: { userId: context.user.id },\n  });\n\n  if (!connection) {\n    throw new Error(\n      'Google account not connected. Please connect your Google account first.'\n    );\n  }\n\n  try {\n    // Get access token (automatically refreshes if expired)\n    const accessToken = await getGoogleSheetsAccessToken(\n      context.user.id,\n      context.entities.GoogleSheetsConnection as any\n    );\n\n    // Get the first row of the sheet (headers)\n    const sheetData = await googleClient.getSheetData(\n      accessToken,\n      spreadsheetId,\n      sheetId,\n      'A1:ZZ1' // Get first row, up to column ZZ (702 columns)\n    );\n\n    // Extract headers from the first row\n    const headers = sheetData.values?.[0] || [];\n\n    // Get the total column count from metadata\n    const metadata = await googleClient.getSpreadsheet(accessToken, spreadsheetId);\n\n    // Find sheet by either numeric ID or name\n    const sheet = typeof sheetId === 'number'\n      ? metadata.sheets.find((s) => s.properties.sheetId === sheetId)\n      : metadata.sheets.find((s) => s.properties.title === sheetId);\n\n    const columnCount = sheet?.properties.gridProperties?.columnCount || headers.length;\n\n    // If headers are empty, generate column letters (A, B, C, etc.)\n    const finalHeaders = headers.length > 0\n      ? headers.map((h, i) => h || googleClient.columnNumberToLetter(i + 1))\n      : Array.from({ length: columnCount }, (_, i) => googleClient.columnNumberToLetter(i + 1));\n\n    return {\n      headers: finalHeaders.slice(0, columnCount),\n      columnCount,\n    };\n  } catch (error) {\n    console.error('Failed to get sheet column headers:', error);\n\n    // Provide user-friendly error messages\n    if (error instanceof googleClient.GoogleSheetsError) {\n      if (error.isAuthError) {\n        throw new Error(\n          'Your Google connection has expired or lacks permissions. Please reconnect your Google account.'\n        );\n      }\n      if (error.isQuotaError) {\n        throw new Error(\n          'Google API quota exceeded. Please try again later or contact support.'\n        );\n      }\n      throw new Error(`Failed to fetch column headers: ${error.message}`);\n    }\n\n    if (error instanceof Error) {\n      if (error.message.includes('refresh') || error.message.includes('token')) {\n        throw new Error(\n          'Your Google connection has expired. Please reconnect your Google account.'\n        );\n      }\n      throw new Error(`Failed to fetch column headers: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch column headers. Please try again.');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { validateSpreadsheetUrl } from '../../../../../src/server/google/queries'\n\n\nexport default async function (args, context) {\n  return (validateSpreadsheetUrl as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport validateSpreadsheetUrl from '../../queries/validateSpreadsheetUrl.js'\n\nexport default createQuery(validateSpreadsheetUrl)\n","import { prisma } from 'wasp/server'\n\nimport { getSpreadsheetSheets } from '../../../../../src/server/google/queries'\n\n\nexport default async function (args, context) {\n  return (getSpreadsheetSheets as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getSpreadsheetSheets from '../../queries/getSpreadsheetSheets.js'\n\nexport default createQuery(getSpreadsheetSheets)\n","import { prisma } from 'wasp/server'\n\nimport { getSheetColumnHeaders } from '../../../../../src/server/google/queries'\n\n\nexport default async function (args, context) {\n  return (getSheetColumnHeaders as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      GoogleSheetsConnection: prisma.googleSheetsConnection,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getSheetColumnHeaders from '../../queries/getSheetColumnHeaders.js'\n\nexport default createQuery(getSheetColumnHeaders)\n","/**\n * Wasp queries for fetching sync configurations\n */\n\n// @ts-nocheck\n// Type checking disabled temporarily until Wasp regenerates types\nimport type { User, SyncConfig, SyncLog } from 'wasp/entities';\nimport type { GetUserSyncConfigs, GetSyncConfigById } from 'wasp/server/operations';\n// GetSyncLogs will be available after Wasp regenerates types\ntype GetSyncLogs<Input, Output> = (args: Input, context: any) => Promise<Output>;\n\n// ============================================================================\n// Types\n// ============================================================================\n\ntype GetUserSyncConfigsInput = void;\ntype GetUserSyncConfigsOutput = Array<{\n  id: string;\n  name: string;\n  airtableBaseId: string;\n  airtableTableId: string;\n  airtableTableName: string | null;\n  googleSpreadsheetId: string;\n  googleSheetId: string;\n  googleSheetName: string | null;\n  fieldMappings: Record<string, number>;\n  syncDirection: 'AIRTABLE_TO_SHEETS' | 'SHEETS_TO_AIRTABLE' | 'BIDIRECTIONAL';\n  conflictResolution: 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS';\n  isActive: boolean;\n  lastSyncAt: Date | null;\n  lastSyncStatus: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n}>;\n\ntype GetSyncConfigByIdInput = {\n  syncConfigId: string;\n};\ntype GetSyncConfigByIdOutput = {\n  id: string;\n  name: string;\n  airtableBaseId: string;\n  airtableTableId: string;\n  airtableTableName: string | null;\n  googleSpreadsheetId: string;\n  googleSheetId: string;\n  googleSheetName: string | null;\n  fieldMappings: Record<string, number>;\n  syncDirection: 'AIRTABLE_TO_SHEETS' | 'SHEETS_TO_AIRTABLE' | 'BIDIRECTIONAL';\n  conflictResolution: 'AIRTABLE_WINS' | 'SHEETS_WINS' | 'NEWEST_WINS';\n  isActive: boolean;\n  lastSyncAt: Date | null;\n  lastSyncStatus: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n};\n\n// ============================================================================\n// Query: Get User's Sync Configurations\n// ============================================================================\n\n/**\n * Fetches all sync configurations for the authenticated user\n * Sorted by most recently updated first\n */\nexport const getUserSyncConfigs: GetUserSyncConfigs<\n  GetUserSyncConfigsInput,\n  GetUserSyncConfigsOutput\n> = async (_args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    const syncConfigs = await context.entities.SyncConfig.findMany({\n      where: {\n        userId: context.user.id,\n      },\n      orderBy: {\n        updatedAt: 'desc',\n      },\n    });\n\n    return syncConfigs.map((config) => ({\n      id: config.id,\n      name: config.name,\n      airtableBaseId: config.airtableBaseId,\n      airtableTableId: config.airtableTableId,\n      airtableTableName: config.airtableTableName,\n      googleSpreadsheetId: config.googleSpreadsheetId,\n      googleSheetId: config.googleSheetId,\n      googleSheetName: config.googleSheetName,\n      fieldMappings: JSON.parse(config.fieldMappings),\n      syncDirection: config.syncDirection as\n        | 'AIRTABLE_TO_SHEETS'\n        | 'SHEETS_TO_AIRTABLE'\n        | 'BIDIRECTIONAL',\n      conflictResolution: config.conflictResolution as\n        | 'AIRTABLE_WINS'\n        | 'SHEETS_WINS'\n        | 'NEWEST_WINS',\n      isActive: config.isActive,\n      lastSyncAt: config.lastSyncAt,\n      lastSyncStatus: config.lastSyncStatus,\n      createdAt: config.createdAt,\n      updatedAt: config.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Failed to fetch sync configurations:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch sync configurations: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch sync configurations. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Sync Configuration by ID\n// ============================================================================\n\n/**\n * Fetches a specific sync configuration by ID\n * User must own the sync configuration to view it\n */\nexport const getSyncConfigById: GetSyncConfigById<\n  GetSyncConfigByIdInput,\n  GetSyncConfigByIdOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { syncConfigId } = args;\n\n  if (!syncConfigId) {\n    throw new Error('Sync configuration ID is required');\n  }\n\n  try {\n    const syncConfig = await context.entities.SyncConfig.findUnique({\n      where: {\n        id: syncConfigId,\n      },\n    });\n\n    if (!syncConfig) {\n      throw new Error('Sync configuration not found');\n    }\n\n    // Verify user owns this sync config\n    if (syncConfig.userId !== context.user.id) {\n      throw new Error('You do not have permission to view this sync configuration');\n    }\n\n    return {\n      id: syncConfig.id,\n      name: syncConfig.name,\n      airtableBaseId: syncConfig.airtableBaseId,\n      airtableTableId: syncConfig.airtableTableId,\n      airtableTableName: syncConfig.airtableTableName,\n      googleSpreadsheetId: syncConfig.googleSpreadsheetId,\n      googleSheetId: syncConfig.googleSheetId,\n      googleSheetName: syncConfig.googleSheetName,\n      fieldMappings: JSON.parse(syncConfig.fieldMappings),\n      syncDirection: syncConfig.syncDirection as\n        | 'AIRTABLE_TO_SHEETS'\n        | 'SHEETS_TO_AIRTABLE'\n        | 'BIDIRECTIONAL',\n      conflictResolution: syncConfig.conflictResolution as\n        | 'AIRTABLE_WINS'\n        | 'SHEETS_WINS'\n        | 'NEWEST_WINS',\n      isActive: syncConfig.isActive,\n      lastSyncAt: syncConfig.lastSyncAt,\n      lastSyncStatus: syncConfig.lastSyncStatus,\n      createdAt: syncConfig.createdAt,\n      updatedAt: syncConfig.updatedAt,\n    };\n  } catch (error) {\n    console.error('Failed to fetch sync configuration:', error);\n\n    if (error instanceof Error) {\n      // Re-throw known errors\n      if (\n        error.message.includes('not found') ||\n        error.message.includes('permission')\n      ) {\n        throw error;\n      }\n      throw new Error(`Failed to fetch sync configuration: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch sync configuration. Please try again.');\n  }\n};\n\n// ============================================================================\n// Query: Get Sync Logs for Configuration\n// ============================================================================\n\ntype GetSyncLogsInput = {\n  syncConfigId: string;\n  limit?: number;\n};\n\ntype GetSyncLogsOutput = Array<{\n  id: string;\n  syncConfigId: string;\n  status: string;\n  startedAt: Date;\n  completedAt: Date | null;\n  recordsSynced: number;\n  recordsFailed: number;\n  errors: string | null;\n  triggeredBy: string | null;\n  direction: string | null;\n}>;\n\n/**\n * Fetches sync logs for a specific sync configuration\n * User must own the sync configuration to view its logs\n */\nexport const getSyncLogs: GetSyncLogs<\n  GetSyncLogsInput,\n  GetSyncLogsOutput\n> = async (args, context) => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  const { syncConfigId, limit = 50 } = args;\n\n  if (!syncConfigId) {\n    throw new Error('Sync configuration ID is required');\n  }\n\n  try {\n    // First verify the sync config exists and user owns it\n    const syncConfig = await context.entities.SyncConfig.findUnique({\n      where: { id: syncConfigId },\n    });\n\n    if (!syncConfig) {\n      throw new Error('Sync configuration not found');\n    }\n\n    if (syncConfig.userId !== context.user.id) {\n      throw new Error('You do not have permission to view logs for this sync configuration');\n    }\n\n    // Fetch sync logs, most recent first\n    const logs = await context.entities.SyncLog.findMany({\n      where: {\n        syncConfigId: syncConfigId,\n      },\n      orderBy: {\n        startedAt: 'desc',\n      },\n      take: limit,\n    });\n\n    return logs.map((log) => ({\n      id: log.id,\n      syncConfigId: log.syncConfigId,\n      status: log.status,\n      startedAt: log.startedAt,\n      completedAt: log.completedAt,\n      recordsSynced: log.recordsSynced || 0,\n      recordsFailed: log.recordsFailed || 0,\n      errors: log.errors,\n      triggeredBy: log.triggeredBy,\n      direction: log.direction,\n    }));\n  } catch (error) {\n    console.error('Failed to fetch sync logs:', error);\n\n    if (error instanceof Error) {\n      // Re-throw known errors\n      if (\n        error.message.includes('not found') ||\n        error.message.includes('permission')\n      ) {\n        throw error;\n      }\n      throw new Error(`Failed to fetch sync logs: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch sync logs. Please try again.');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { getUserSyncConfigs } from '../../../../../src/server/queries/syncConfig'\n\n\nexport default async function (args, context) {\n  return (getUserSyncConfigs as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getUserSyncConfigs from '../../queries/getUserSyncConfigs.js'\n\nexport default createQuery(getUserSyncConfigs)\n","import { prisma } from 'wasp/server'\n\nimport { getSyncConfigById } from '../../../../../src/server/queries/syncConfig'\n\n\nexport default async function (args, context) {\n  return (getSyncConfigById as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getSyncConfigById from '../../queries/getSyncConfigById.js'\n\nexport default createQuery(getSyncConfigById)\n","import { prisma } from 'wasp/server'\n\nimport { getSyncLogs } from '../../../../../src/server/queries/syncConfig'\n\n\nexport default async function (args, context) {\n  return (getSyncLogs as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n      SyncLog: prisma.syncLog,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getSyncLogs from '../../queries/getSyncLogs.js'\n\nexport default createQuery(getSyncLogs)\n","/**\n * Usage queries for fetching user usage statistics\n */\n\nimport type { User } from 'wasp/entities';\nimport { getMonthlyUsage } from '../utils/usageTracker';\nimport {\n  getUserPlanLimits,\n  getUserSubscriptionState,\n  shouldPauseSyncs,\n  getSyncPauseReason,\n  TRIAL_DURATION_DAYS,\n} from '../middleware/usageLimits';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Subscription/trial state for frontend display */\ntype SubscriptionState =\n  | { type: 'trial_active'; daysRemaining: number; trialEndsAt: Date }\n  | { type: 'trial_expired' }\n  | { type: 'subscribed'; plan: string; status: string }\n  | { type: 'subscription_inactive'; plan: string; status: string };\n\ntype GetUserUsageOutput = {\n  /** Current sync config count */\n  syncConfigCount: number;\n  /** Maximum allowed sync configs for plan */\n  maxSyncConfigs: number;\n  /** Records synced this month */\n  recordsSyncedThisMonth: number;\n  /** Maximum records per sync for plan */\n  maxRecordsPerSync: number;\n  /** Sync frequency in minutes for plan */\n  syncIntervalMinutes: number;\n  /** Current plan name */\n  planName: string;\n  /** Month being tracked */\n  month: Date;\n  /** User's subscription/trial state */\n  subscriptionState: SubscriptionState;\n  /** Whether syncs are paused */\n  syncsPaused: boolean;\n  /** Reason syncs are paused (if applicable) */\n  syncPauseReason: string | null;\n  /** Trial duration in days (for displaying to user) */\n  trialDurationDays: number;\n};\n\n// ============================================================================\n// Query: Get User Usage Stats\n// ============================================================================\n\n/**\n * Fetches current usage statistics and plan limits for the authenticated user\n */\nexport const getUserUsage = async (\n  _args: void,\n  context: any\n): Promise<GetUserUsageOutput> => {\n  if (!context.user) {\n    throw new Error('User must be authenticated');\n  }\n\n  try {\n    // Get plan limits\n    const limits = getUserPlanLimits(context.user);\n\n    // Get subscription state\n    const subscriptionState = getUserSubscriptionState(context.user);\n\n    // Check if syncs should be paused\n    const syncsPaused = shouldPauseSyncs(context.user);\n    const syncPauseReason = getSyncPauseReason(context.user);\n\n    // Get current sync config count\n    const syncConfigCount = await context.entities.SyncConfig.count({\n      where: {\n        userId: context.user.id,\n      },\n    });\n\n    // Get monthly usage\n    const monthlyUsage = await getMonthlyUsage(context.user.id);\n\n    // Convert subscription state for frontend (serialize plan enum to string)\n    let frontendState: SubscriptionState;\n    switch (subscriptionState.type) {\n      case 'trial_active':\n        frontendState = {\n          type: 'trial_active',\n          daysRemaining: subscriptionState.daysRemaining,\n          trialEndsAt: subscriptionState.trialEndsAt,\n        };\n        break;\n      case 'trial_expired':\n        frontendState = { type: 'trial_expired' };\n        break;\n      case 'subscribed':\n        frontendState = {\n          type: 'subscribed',\n          plan: limits.name,\n          status: subscriptionState.status,\n        };\n        break;\n      case 'subscription_inactive':\n        frontendState = {\n          type: 'subscription_inactive',\n          plan: limits.name,\n          status: subscriptionState.status,\n        };\n        break;\n      default:\n        frontendState = { type: 'trial_expired' };\n    }\n\n    return {\n      syncConfigCount,\n      maxSyncConfigs: limits.maxSyncConfigs,\n      recordsSyncedThisMonth: monthlyUsage.recordsSynced,\n      maxRecordsPerSync: limits.maxRecordsPerSync,\n      syncIntervalMinutes: limits.syncIntervalMinutes,\n      planName: limits.name,\n      month: monthlyUsage.month,\n      subscriptionState: frontendState,\n      syncsPaused,\n      syncPauseReason,\n      trialDurationDays: TRIAL_DURATION_DAYS,\n    };\n  } catch (error) {\n    console.error('Failed to fetch user usage:', error);\n\n    if (error instanceof Error) {\n      throw new Error(`Failed to fetch usage statistics: ${error.message}`);\n    }\n\n    throw new Error('Failed to fetch usage statistics. Please try again.');\n  }\n};\n","import { prisma } from 'wasp/server'\n\nimport { getUserUsage } from '../../../../../src/server/queries/usage'\n\n\nexport default async function (args, context) {\n  return (getUserUsage as any)(args, {\n    ...context,\n    entities: {\n      User: prisma.user,\n      SyncConfig: prisma.syncConfig,\n      UsageStats: prisma.usageStats,\n    },\n  })\n}\n","import { createQuery } from '../../middleware/operations.js'\nimport getUserUsage from '../../queries/getUserUsage.js'\n\nexport default createQuery(getUserUsage)\n","import express from 'express'\n\nimport auth from 'wasp/core/auth'\n\nimport updateIsUserAdminById from './updateIsUserAdminById.js'\nimport updateUsername from './updateUsername.js'\nimport requestEmailChange from './requestEmailChange.js'\nimport confirmEmailChange from './confirmEmailChange.js'\nimport updateNotificationPreferences from './updateNotificationPreferences.js'\nimport changePassword from './changePassword.js'\nimport deleteAccount from './deleteAccount.js'\nimport generateCheckoutSession from './generateCheckoutSession.js'\nimport updateUser from './updateUser.js'\nimport deleteUser from './deleteUser.js'\nimport pauseResumeSync from './pauseResumeSync.js'\nimport triggerManualSyncAdmin from './triggerManualSyncAdmin.js'\nimport forceRefreshUserToken from './forceRefreshUserToken.js'\nimport initiateAirtableAuth from './initiateAirtableAuth.js'\nimport completeAirtableAuth from './completeAirtableAuth.js'\nimport disconnectAirtable from './disconnectAirtable.js'\nimport initiateGoogleAuth from './initiateGoogleAuth.js'\nimport completeGoogleAuth from './completeGoogleAuth.js'\nimport disconnectGoogle from './disconnectGoogle.js'\nimport triggerManualSync from './triggerManualSync.js'\nimport runInitialSync from './runInitialSync.js'\nimport createSyncConfig from './createSyncConfig.js'\nimport updateSyncConfig from './updateSyncConfig.js'\nimport deleteSyncConfig from './deleteSyncConfig.js'\nimport toggleSyncActive from './toggleSyncActive.js'\nimport runConnectionDiagnostics from './runConnectionDiagnostics.js'\nimport clearReauthFlags from './clearReauthFlags.js'\nimport sendTestEmails from './sendTestEmails.js'\nimport getPaginatedUsers from './getPaginatedUsers.js'\nimport exportUserData from './exportUserData.js'\nimport getCustomerPortalUrl from './getCustomerPortalUrl.js'\nimport getDailyStats from './getDailyStats.js'\nimport getAdminOverviewStats from './getAdminOverviewStats.js'\nimport getRecentActivity from './getRecentActivity.js'\nimport searchUsers from './searchUsers.js'\nimport getOnlineUsers from './getOnlineUsers.js'\nimport getUserDetail from './getUserDetail.js'\nimport getActiveSyncs from './getActiveSyncs.js'\nimport getFailedSyncs from './getFailedSyncs.js'\nimport getSyncMonitor from './getSyncMonitor.js'\nimport getAirtableConnectionStatus from './getAirtableConnectionStatus.js'\nimport listUserAirtableBases from './listUserAirtableBases.js'\nimport getAirtableTableSchema from './getAirtableTableSchema.js'\nimport getAirtableBaseTables from './getAirtableBaseTables.js'\nimport getGoogleConnectionStatus from './getGoogleConnectionStatus.js'\nimport validateSpreadsheetUrl from './validateSpreadsheetUrl.js'\nimport getSpreadsheetSheets from './getSpreadsheetSheets.js'\nimport getSheetColumnHeaders from './getSheetColumnHeaders.js'\nimport getUserSyncConfigs from './getUserSyncConfigs.js'\nimport getSyncConfigById from './getSyncConfigById.js'\nimport getSyncLogs from './getSyncLogs.js'\nimport getUserUsage from './getUserUsage.js'\n\nconst router = express.Router()\n\nrouter.post('/update-is-user-admin-by-id', auth, updateIsUserAdminById)\nrouter.post('/update-username', auth, updateUsername)\nrouter.post('/request-email-change', auth, requestEmailChange)\nrouter.post('/confirm-email-change', auth, confirmEmailChange)\nrouter.post('/update-notification-preferences', auth, updateNotificationPreferences)\nrouter.post('/change-password', auth, changePassword)\nrouter.post('/delete-account', auth, deleteAccount)\nrouter.post('/generate-checkout-session', auth, generateCheckoutSession)\nrouter.post('/update-user', auth, updateUser)\nrouter.post('/delete-user', auth, deleteUser)\nrouter.post('/pause-resume-sync', auth, pauseResumeSync)\nrouter.post('/trigger-manual-sync-admin', auth, triggerManualSyncAdmin)\nrouter.post('/force-refresh-user-token', auth, forceRefreshUserToken)\nrouter.post('/initiate-airtable-auth', auth, initiateAirtableAuth)\nrouter.post('/complete-airtable-auth', auth, completeAirtableAuth)\nrouter.post('/disconnect-airtable', auth, disconnectAirtable)\nrouter.post('/initiate-google-auth', auth, initiateGoogleAuth)\nrouter.post('/complete-google-auth', auth, completeGoogleAuth)\nrouter.post('/disconnect-google', auth, disconnectGoogle)\nrouter.post('/trigger-manual-sync', auth, triggerManualSync)\nrouter.post('/run-initial-sync', auth, runInitialSync)\nrouter.post('/create-sync-config', auth, createSyncConfig)\nrouter.post('/update-sync-config', auth, updateSyncConfig)\nrouter.post('/delete-sync-config', auth, deleteSyncConfig)\nrouter.post('/toggle-sync-active', auth, toggleSyncActive)\nrouter.post('/run-connection-diagnostics', auth, runConnectionDiagnostics)\nrouter.post('/clear-reauth-flags', auth, clearReauthFlags)\nrouter.post('/send-test-emails', auth, sendTestEmails)\nrouter.post('/get-paginated-users', auth, getPaginatedUsers)\nrouter.post('/export-user-data', auth, exportUserData)\nrouter.post('/get-customer-portal-url', auth, getCustomerPortalUrl)\nrouter.post('/get-daily-stats', auth, getDailyStats)\nrouter.post('/get-admin-overview-stats', auth, getAdminOverviewStats)\nrouter.post('/get-recent-activity', auth, getRecentActivity)\nrouter.post('/search-users', auth, searchUsers)\nrouter.post('/get-online-users', auth, getOnlineUsers)\nrouter.post('/get-user-detail', auth, getUserDetail)\nrouter.post('/get-active-syncs', auth, getActiveSyncs)\nrouter.post('/get-failed-syncs', auth, getFailedSyncs)\nrouter.post('/get-sync-monitor', auth, getSyncMonitor)\nrouter.post('/get-airtable-connection-status', auth, getAirtableConnectionStatus)\nrouter.post('/list-user-airtable-bases', auth, listUserAirtableBases)\nrouter.post('/get-airtable-table-schema', auth, getAirtableTableSchema)\nrouter.post('/get-airtable-base-tables', auth, getAirtableBaseTables)\nrouter.post('/get-google-connection-status', auth, getGoogleConnectionStatus)\nrouter.post('/validate-spreadsheet-url', auth, validateSpreadsheetUrl)\nrouter.post('/get-spreadsheet-sheets', auth, getSpreadsheetSheets)\nrouter.post('/get-sheet-column-headers', auth, getSheetColumnHeaders)\nrouter.post('/get-user-sync-configs', auth, getUserSyncConfigs)\nrouter.post('/get-sync-config-by-id', auth, getSyncConfigById)\nrouter.post('/get-sync-logs', auth, getSyncLogs)\nrouter.post('/get-user-usage', auth, getUserUsage)\n\nexport default router\n","import express from 'express'\nimport cookieParser from 'cookie-parser'\nimport logger from 'morgan'\nimport cors from 'cors'\nimport helmet from 'helmet'\n\nimport { config } from 'wasp/server'\nimport type { MiddlewareConfig, MiddlewareConfigFn } from 'wasp/server/middleware'\nexport type { MiddlewareConfig, MiddlewareConfigFn } from 'wasp/server/middleware'\n\nconst _waspGlobalMiddlewareConfigFn = (mc: MiddlewareConfig) => mc\n\n// This is the set of middleware Wasp supplies by default.\n// NOTE: Remember to update the docs of these change.\nconst defaultGlobalMiddlewareConfig: MiddlewareConfig = new Map([\n  ['helmet', helmet()],\n  ['cors', cors({ origin: config.allowedCORSOrigins })],\n  ['logger', logger('dev')],\n  ['express.json', express.json()],\n  ['express.urlencoded', express.urlencoded()],\n  ['cookieParser', cookieParser()]\n])\n\n// This is the global middleware that is the result of applying the user's modifications.\n// It will be used as the basis for Operations and APIs (unless they are further customized).\nconst globalMiddlewareConfig: MiddlewareConfig = _waspGlobalMiddlewareConfigFn(defaultGlobalMiddlewareConfig)\n\n// This function returns an array of Express middleware to be used by a router. It optionally\n// accepts a function that can modify the global middleware for specific route customization.\nexport function globalMiddlewareConfigForExpress(middlewareConfigFn?: MiddlewareConfigFn): express.RequestHandler[] {\n  if (!middlewareConfigFn) {\n    return Array.from(globalMiddlewareConfig.values())\n  }\n\n  // Make a clone so they can't mess up the global Map for any other routes calling this.\n  const globalMiddlewareConfigClone = new Map(globalMiddlewareConfig)\n  const modifiedMiddlewareConfig = middlewareConfigFn(globalMiddlewareConfigClone)\n  return Array.from(modifiedMiddlewareConfig.values())\n}\n","import { serialize } from 'wasp/core/serialization'\nimport { defineHandler } from 'wasp/server/utils'\n\nexport default defineHandler(async (req, res) => {\n  if (req.user) {\n    res.json(serialize(req.user))\n  } else {\n    res.json(serialize(null))\n  }\n})\n","import { defineHandler } from 'wasp/server/utils'\nimport { createInvalidCredentialsError } from 'wasp/auth/utils'\nimport { invalidateSession } from 'wasp/auth/session'\n\nexport default defineHandler(async (req, res) => {\n  if (req.sessionId) {\n    await invalidateSession(req.sessionId)\n    res.json({ success: true })\n  } else {\n    throw createInvalidCredentialsError()\n  }\n})\n","import { prisma } from 'wasp/server'\nimport type {\n  OnAfterSignupHook,\n  OnAfterEmailVerifiedHook,\n  OnBeforeOAuthRedirectHook,\n  OnBeforeSignupHook,\n  OnBeforeLoginHook,\n  OnAfterLoginHook,\n  InternalAuthHookParams,\n} from 'wasp/server/auth'\n\n/*\n  These are \"internal hook functions\" based on the user defined hook functions.\n\n  In the server code (e.g. email signup) we import these functions and call them.\n\n  We want to pass extra params to the user defined hook functions, but we don't want to\n  pass them when we call them in the server code.\n*/\n\n/**\n * This is a no-op function since the user didn't define the onBeforeSignup hook.\n */\nexport const onBeforeSignupHook: InternalFunctionForHook<OnBeforeSignupHook> = async (_params) => {}\n\n/**\n * This is a no-op function since the user didn't define the onAfterSignup hook.\n */\nexport const onAfterSignupHook: InternalFunctionForHook<OnAfterSignupHook> = async (_params) => {}\n\n/**\n * This is a no-op function since the user didn't define the onAfterSignup hook.\n */\nexport const onAfterEmailVerifiedHook: InternalFunctionForHook<OnAfterEmailVerifiedHook> = async (_params) => {}\n\n/**\n * This is an identity function since the user didn't define the onBeforeOAuthRedirect hook.\n */\nexport const onBeforeOAuthRedirectHook: InternalFunctionForHook<OnBeforeOAuthRedirectHook> = async (params) => params\n\n\n/**\n * This is a no-op function since the user didn't define the onBeforeLogin hook.\n */\nexport const onBeforeLoginHook: InternalFunctionForHook<OnBeforeLoginHook> = async (_params) => {}\n\n/**\n * This is a no-op function since the user didn't define the onAfterLogin hook.\n */\nexport const onAfterLoginHook: InternalFunctionForHook<OnAfterLoginHook> = async (_params) => {}\n\n/*\n  We pass extra params to the user defined hook functions, but we don't want to\n  pass the extra params (e.g. 'prisma') when we call the hooks in the server code.\n  So, we need to remove the extra params from the params object which is used to define the\n  internal hook functions.\n*/\ntype InternalFunctionForHook<Fn extends (args: never) => unknown | Promise<unknown>> = Fn extends (\n  params: infer P,\n) => infer R\n  ? (args: Omit<P, keyof InternalAuthHookParams>) => R\n  : never\n","import { Request, Response } from 'express';\nimport { createInvalidCredentialsError } from 'wasp/auth/utils'\nimport { verifyPassword } from 'wasp/auth/password'\nimport {\n    createProviderId,\n    findAuthIdentity,\n    findAuthWithUserBy,\n    getProviderDataWithPassword,\n} from 'wasp/auth/utils'\nimport { createSession } from 'wasp/auth/session'\nimport { ensureValidEmail, ensurePasswordIsPresent } from 'wasp/auth/validation'\nimport { onBeforeLoginHook, onAfterLoginHook } from '../../hooks.js';\n\nexport function getLoginRoute() {\n    return async function login(\n        req: Request<{ email: string; password: string; }>,\n        res: Response,\n    ): Promise<void> {\n        const fields = req.body ?? {}\n        ensureValidArgs(fields)\n\n        const providerId = createProviderId(\"email\", fields.email)\n        const authIdentity = await findAuthIdentity(providerId)\n        if (!authIdentity) {\n            throw createInvalidCredentialsError()\n        }\n        const providerData = getProviderDataWithPassword<'email'>(authIdentity.providerData)\n        if (!providerData.isEmailVerified) {\n            throw createInvalidCredentialsError()\n        }\n        try {\n            await verifyPassword(providerData.hashedPassword, fields.password);\n        } catch(e) {\n            throw createInvalidCredentialsError()\n        }\n    \n        const auth = await findAuthWithUserBy({ id: authIdentity.authId })\n\n        if (auth === null) {\n            throw createInvalidCredentialsError()\n        }\n        \n        await onBeforeLoginHook({\n            req,\n            providerId,\n            user: auth.user,\n        })\n        \n        const session = await createSession(auth.id)\n\n        await onAfterLoginHook({\n            req,\n            providerId,\n            user: auth.user,\n        })\n      \n        res.json({\n            sessionId: session.id,\n        })\n    };\n}\n\nfunction ensureValidArgs(args: object): void {\n    ensureValidEmail(args);\n    ensurePasswordIsPresent(args);\n}\n","import * as jwt from 'oslo/jwt';\nimport { config } from 'wasp/server';\nconst JWT_SECRET = new TextEncoder().encode(config.auth.jwtSecret);\nconst JWT_ALGORITHM = 'HS256';\n// PRIVATE API\nexport function createJWT(data, options) {\n    return jwt.createJWT(JWT_ALGORITHM, JWT_SECRET, data, options);\n}\n// PRIVATE API\nexport async function validateJWT(token) {\n    const { payload } = await jwt.validateJWT(JWT_ALGORITHM, JWT_SECRET, token);\n    return payload;\n}\n// PRIVATE API\nexport { TimeSpan } from 'oslo';\n//# sourceMappingURL=jwt.js.map","import { createJWT, TimeSpan } from 'wasp/auth/jwt';\nimport { emailSender } from 'wasp/server/email';\nimport { createProviderId, updateAuthIdentityProviderData, findAuthIdentity, getProviderDataWithPassword, } from 'wasp/auth/utils';\nimport { config as waspServerConfig } from 'wasp/server';\n// PUBLIC API\nexport async function createEmailVerificationLink(email, clientRoute) {\n    const { jwtToken } = await createEmailJWT(email);\n    return `${waspServerConfig.frontendUrl}${clientRoute}?token=${jwtToken}`;\n}\n// PUBLIC API\nexport async function createPasswordResetLink(email, clientRoute) {\n    const { jwtToken } = await createEmailJWT(email);\n    return `${waspServerConfig.frontendUrl}${clientRoute}?token=${jwtToken}`;\n}\nasync function createEmailJWT(email) {\n    const jwtToken = await createJWT({ email }, { expiresIn: new TimeSpan(30, \"m\") });\n    return { jwtToken };\n}\n// PUBLIC API\nexport async function sendPasswordResetEmail(email, content) {\n    return sendEmailAndSaveMetadata(email, content, {\n        passwordResetSentAt: (new Date()).toISOString(),\n    });\n}\n// PUBLIC API\nexport async function sendEmailVerificationEmail(email, content) {\n    return sendEmailAndSaveMetadata(email, content, {\n        emailVerificationSentAt: (new Date()).toISOString(),\n    });\n}\nasync function sendEmailAndSaveMetadata(email, content, metadata) {\n    // Save the metadata (e.g. timestamp) first, and then send the email\n    // so the user can't send multiple requests while the email is being sent.\n    const providerId = createProviderId(\"email\", email);\n    const authIdentity = await findAuthIdentity(providerId);\n    if (!authIdentity) {\n        throw new Error(`User with email: ${email} not found.`);\n    }\n    const providerData = getProviderDataWithPassword(authIdentity.providerData);\n    await updateAuthIdentityProviderData(providerId, providerData, metadata);\n    emailSender.send(content).catch((e) => {\n        console.error('Failed to send email', e);\n    });\n}\n// PUBLIC API\nexport function isEmailResendAllowed(fields, field, resendInterval = 1000 * 60) {\n    const sentAt = fields[field];\n    if (!sentAt) {\n        return {\n            isResendAllowed: true,\n            timeLeft: 0,\n        };\n    }\n    const now = new Date();\n    const diff = now.getTime() - new Date(sentAt).getTime();\n    const isResendAllowed = diff > resendInterval;\n    // Time left in seconds\n    const timeLeft = isResendAllowed ? 0 : Math.round((resendInterval - diff) / 1000);\n    return { isResendAllowed, timeLeft };\n}\n//# sourceMappingURL=utils.js.map","import { Request, Response } from 'express'\nimport type { UserSignupFields } from 'wasp/auth/providers/types'\nimport {\n  createProviderId,\n  createUser,\n  deleteUserByAuthId,\n  doFakeWork,\n  findAuthIdentity,\n  getProviderDataWithPassword,\n  rethrowPossibleAuthError,\n  sanitizeAndSerializeProviderData,\n  validateAndGetUserFields,\n} from 'wasp/auth/utils'\nimport {\n  ensurePasswordIsPresent,\n  ensureValidEmail,\n  ensureValidPassword,\n} from 'wasp/auth/validation'\nimport { HttpError } from 'wasp/server'\nimport { GetVerificationEmailContentFn } from 'wasp/server/auth/email'\nimport {\n  createEmailVerificationLink,\n  isEmailResendAllowed,\n  sendEmailVerificationEmail,\n} from 'wasp/server/auth/email/utils'\nimport { EmailFromField } from 'wasp/server/email/core/types'\nimport { onAfterSignupHook, onBeforeSignupHook } from '../../hooks.js'\n\nexport function getSignupRoute({\n  userSignupFields,\n  fromField,\n  clientRoute,\n  getVerificationEmailContent,\n  isEmailAutoVerified,\n}: {\n  userSignupFields?: UserSignupFields\n  fromField: EmailFromField\n  clientRoute: string\n  getVerificationEmailContent: GetVerificationEmailContentFn\n  isEmailAutoVerified: boolean\n}) {\n  return async function signup(\n    req: Request<{ email: string; password: string }>,\n    res: Response,\n  ): Promise<void> {\n    const fields = req.body\n    ensureValidArgs(fields)\n\n    const providerId = createProviderId('email', fields.email)\n    const existingAuthIdentity = await findAuthIdentity(providerId)\n\n    /**\n     *\n     * There are two cases to consider in the case of an existing user:\n     * - if we allow unverified login\n     * - if the user is already verified\n     *\n     * Let's see what happens when we **don't** allow unverified login:\n     *\n     * We are handling the case of an existing auth identity in two ways:\n     *\n     * 1. If the user already exists and is verified, we don't want\n     *   to leak that piece of info and instead we pretend that the user\n     *   was created successfully.\n     *    - This prevents the attacker from learning which emails already have\n     *        an account created.\n     *\n     * 2. If the user is not verified:\n     *   - We check when we last sent a verification email and if it was less than X seconds ago,\n     *     we don't send another one.\n     *   - If it was more than X seconds ago, we delete the user and create a new one.\n     *   - This prevents the attacker from creating an account with somebody\n     *     else's email address and therefore permanently making that email\n     *     address unavailable for later account creation (by real owner).\n     */\n    if (existingAuthIdentity) {\n      const providerData = getProviderDataWithPassword<'email'>(\n        existingAuthIdentity.providerData,\n      )\n\n      // TOOD: faking work makes sense if the time spent on faking the work matches the time\n      // it would take to send the email. Atm, the fake work takes obviously longer than sending\n      // the email!\n      if (providerData.isEmailVerified) {\n        await doFakeWork()\n        res.json({ success: true })\n        return\n      }\n\n      // TODO: we are still leaking information here since when we are faking work\n      // we are not checking if the email was sent or not!\n      const { isResendAllowed, timeLeft } = isEmailResendAllowed(\n        providerData,\n        'passwordResetSentAt',\n      )\n      if (!isResendAllowed) {\n        throw new HttpError(\n          400,\n          `Please wait ${timeLeft} secs before trying again.`,\n        )\n      }\n\n      try {\n        await deleteUserByAuthId(existingAuthIdentity.authId)\n      } catch (e: unknown) {\n        rethrowPossibleAuthError(e)\n      }\n    }\n\n    const userFields = await validateAndGetUserFields(fields, userSignupFields)\n\n    const newUserProviderData = await sanitizeAndSerializeProviderData<'email'>(\n      {\n        hashedPassword: fields.password,\n        isEmailVerified: isEmailAutoVerified ? true : false,\n        emailVerificationSentAt: null,\n        passwordResetSentAt: null,\n      },\n    )\n\n    try {\n      await onBeforeSignupHook({ req, providerId })\n      const user = await createUser(\n        providerId,\n        newUserProviderData,\n        // Using any here because we want to avoid TypeScript errors and\n        // rely on Prisma to validate the data.\n        userFields as any,\n      )\n      await onAfterSignupHook({ req, providerId, user })\n    } catch (e: unknown) {\n      rethrowPossibleAuthError(e)\n    }\n\n    // Wasp allows for auto-verification of emails in development mode to\n    // make writing e2e tests easier.\n    if (isEmailAutoVerified) {\n      res.json({ success: true })\n      return\n    }\n\n    const verificationLink = await createEmailVerificationLink(\n      fields.email,\n      clientRoute,\n    )\n    try {\n      await sendEmailVerificationEmail(fields.email, {\n        from: fromField,\n        to: fields.email,\n        ...getVerificationEmailContent({ verificationLink }),\n      })\n    } catch (e: unknown) {\n      console.error('Failed to send email verification email:', e)\n      throw new HttpError(500, 'Failed to send email verification email.')\n    }\n\n    res.json({ success: true })\n  }\n}\n\nfunction ensureValidArgs(args: object): void {\n  ensureValidEmail(args)\n  ensurePasswordIsPresent(args)\n  ensureValidPassword(args)\n}\n","import { Request, Response } from 'express';\nimport {\n    createProviderId,\n    findAuthIdentity,\n    doFakeWork,\n    getProviderDataWithPassword,\n} from 'wasp/auth/utils';\nimport {\n    createPasswordResetLink,\n    sendPasswordResetEmail,\n    isEmailResendAllowed,\n} from \"wasp/server/auth/email/utils\";\nimport { ensureValidEmail } from 'wasp/auth/validation';\nimport type { EmailFromField } from 'wasp/server/email/core/types';\nimport { GetPasswordResetEmailContentFn } from 'wasp/server/auth/email';\nimport { HttpError } from 'wasp/server';\n\nexport function getRequestPasswordResetRoute({\n   fromField,\n   clientRoute,\n   getPasswordResetEmailContent,\n}: {\n    fromField: EmailFromField;\n    clientRoute: string;\n    getPasswordResetEmailContent: GetPasswordResetEmailContentFn;\n}) {\n    return async function requestPasswordReset(\n        req: Request<{ email: string; }>,\n        res: Response,\n    ): Promise<void> {\n        const args = req.body ?? {};\n        ensureValidEmail(args);\n\n        const authIdentity = await findAuthIdentity(\n            createProviderId(\"email\", args.email),\n        );\n\n        /**\n         * By doing fake work, we make it harder to enumerate users by measuring\n         * the time it takes to respond. If we would respond immediately, an attacker\n         * could measure the time it takes to respond and figure out if the user exists.\n         */\n\n        if (!authIdentity) {\n            await doFakeWork();\n            res.json({ success: true });\n            return\n        }\n\n        const providerData = getProviderDataWithPassword<'email'>(authIdentity.providerData);\n        const { isResendAllowed, timeLeft } = isEmailResendAllowed(providerData, 'passwordResetSentAt');\n        if (!isResendAllowed) {\n            throw new HttpError(400, `Please wait ${timeLeft} secs before trying again.`);\n        }\n\n        const passwordResetLink = await createPasswordResetLink(args.email, clientRoute);\n        try {\n            const email = authIdentity.providerUserId\n            await sendPasswordResetEmail(\n                email,\n                {\n                    from: fromField,\n                    to: email,\n                    ...getPasswordResetEmailContent({ passwordResetLink }),\n                },\n            );\n        } catch (e: any) {\n            console.error(\"Failed to send password reset email:\", e);\n            throw new HttpError(500, \"Failed to send password reset email.\");\n        }\n    \n        res.json({ success: true });\n    };\n}\n","import { Request, Response } from 'express';\nimport {\n    createProviderId,\n    findAuthIdentity,\n    updateAuthIdentityProviderData,\n    getProviderDataWithPassword,\n} from 'wasp/auth/utils';\nimport { validateJWT } from 'wasp/auth/jwt'\nimport { ensureTokenIsPresent, ensurePasswordIsPresent, ensureValidPassword } from 'wasp/auth/validation';\nimport { HttpError } from 'wasp/server';\n\nexport async function resetPassword(\n    req: Request<{ token: string; password: string; }>,\n    res: Response,\n): Promise<void> {\n    const args = req.body ?? {};\n    ensureValidArgs(args);\n\n    const { token, password } = args;\n    const { email } = await validateJWT<{ email: string }>(token)\n        .catch(() => {\n            throw new HttpError(400, \"Password reset failed, invalid token\");\n        });\n\n    const providerId = createProviderId('email', email);\n    const authIdentity = await findAuthIdentity(providerId);\n    if (!authIdentity) {\n        throw new HttpError(400, \"Password reset failed, invalid token\");\n    }\n\n    const providerData = getProviderDataWithPassword<'email'>(authIdentity.providerData);\n\n    await updateAuthIdentityProviderData(providerId, providerData, {\n        // The act of resetting the password verifies the email\n        isEmailVerified: true,\n        // The password will be hashed when saving the providerData\n        // in the DB\n        hashedPassword: password,\n    });\n\n    res.json({ success: true });\n};\n\nfunction ensureValidArgs(args: object): void {\n    ensureTokenIsPresent(args);\n    ensurePasswordIsPresent(args);\n    ensureValidPassword(args);\n}\n","import { Request, Response } from 'express';\nimport { validateJWT } from 'wasp/auth/jwt';\nimport {\n  createProviderId,\n  findAuthIdentity,\n  findAuthWithUserBy,\n  getProviderDataWithPassword,\n  updateAuthIdentityProviderData,\n} from 'wasp/auth/utils';\nimport { HttpError } from 'wasp/server';\nimport { onAfterEmailVerifiedHook } from '../../hooks.js';\n\n\nexport async function verifyEmail(\n    req: Request<{ token: string }>,\n    res: Response,\n): Promise<void> {\n    const { token } = req.body;\n    const { email } = await validateJWT<{ email: string }>(token)\n        .catch(() => {\n            throw new HttpError(400, \"Email verification failed, invalid token\");\n        });\n\n    const providerId = createProviderId('email', email);\n    const authIdentity = await findAuthIdentity(providerId);\n    if (!authIdentity) {\n        throw new HttpError(400, \"Email verification failed, invalid token\");\n    }\n\n    const providerData = getProviderDataWithPassword<'email'>(authIdentity.providerData);\n\n    await updateAuthIdentityProviderData(providerId, providerData, {\n        isEmailVerified: true,\n    });\n\n    const auth = await findAuthWithUserBy({ id: authIdentity.authId })\n\n    await onAfterEmailVerifiedHook({ req, email, user: auth.user });\n\n    res.json({ success: true });\n};\n\n","// PUBLIC API\nexport function defineUserSignupFields(fields) {\n    return fields;\n}\n//# sourceMappingURL=types.js.map","import { defineUserSignupFields } from \"wasp/auth/providers/types\";\nimport { z } from \"zod\";\nimport { TRIAL_DURATION_DAYS, calculateTrialEndDate } from \"../server/middleware/usageLimits\";\n\nconst adminEmails = process.env.ADMIN_EMAILS?.split(\",\") || [];\n\nconst emailDataSchema = z.object({\n  email: z.string(),\n});\n\nexport const getEmailUserFields = defineUserSignupFields({\n  email: (data) => {\n    const emailData = emailDataSchema.parse(data);\n    return emailData.email;\n  },\n  username: (data) => {\n    const emailData = emailDataSchema.parse(data);\n    return emailData.email;\n  },\n  isAdmin: (data) => {\n    const emailData = emailDataSchema.parse(data);\n    return adminEmails.includes(emailData.email);\n  },\n  // Set trial end date for new signups (14-day free trial)\n  trialEndsAt: () => {\n    return calculateTrialEndDate(new Date());\n  },\n});\n\nconst githubDataSchema = z.object({\n  profile: z.object({\n    emails: z\n      .array(\n        z.object({\n          email: z.string(),\n          verified: z.boolean(),\n        }),\n      )\n      .min(\n        1,\n        \"You need to have an email address associated with your GitHub account to sign up.\",\n      ),\n    login: z.string(),\n  }),\n});\n\nexport const getGitHubUserFields = defineUserSignupFields({\n  email: (data) => {\n    const githubData = githubDataSchema.parse(data);\n    return getGithubEmailInfo(githubData).email;\n  },\n  username: (data) => {\n    const githubData = githubDataSchema.parse(data);\n    return githubData.profile.login;\n  },\n  isAdmin: (data) => {\n    const githubData = githubDataSchema.parse(data);\n    const emailInfo = getGithubEmailInfo(githubData);\n    if (!emailInfo.verified) {\n      return false;\n    }\n    return adminEmails.includes(emailInfo.email);\n  },\n  // Set trial end date for new signups (14-day free trial)\n  trialEndsAt: () => {\n    return calculateTrialEndDate(new Date());\n  },\n});\n\n// We are using the first email from the list of emails returned by GitHub.\n// If you want to use a different email, you can modify this function.\nfunction getGithubEmailInfo(githubData: z.infer<typeof githubDataSchema>) {\n  return githubData.profile.emails[0];\n}\n\n// NOTE: if we don't want to access users' emails, we can use scope [\"user:read\"]\n// instead of [\"user\"] and access args.profile.username instead\nexport function getGitHubAuthConfig() {\n  return {\n    scopes: [\"user\"],\n  };\n}\n\nconst googleDataSchema = z.object({\n  profile: z.object({\n    email: z.string(),\n    email_verified: z.boolean(),\n  }),\n});\n\nexport const getGoogleUserFields = defineUserSignupFields({\n  email: (data) => {\n    const googleData = googleDataSchema.parse(data);\n    return googleData.profile.email;\n  },\n  username: (data) => {\n    const googleData = googleDataSchema.parse(data);\n    return googleData.profile.email;\n  },\n  isAdmin: (data) => {\n    const googleData = googleDataSchema.parse(data);\n    if (!googleData.profile.email_verified) {\n      return false;\n    }\n    return adminEmails.includes(googleData.profile.email);\n  },\n  // Set trial end date for new signups (14-day free trial)\n  trialEndsAt: () => {\n    return calculateTrialEndDate(new Date());\n  },\n});\n\nexport function getGoogleAuthConfig() {\n  return {\n    scopes: [\"profile\", \"email\"], // must include at least 'profile' for Google\n  };\n}\n\nconst discordDataSchema = z.object({\n  profile: z.object({\n    username: z.string(),\n    email: z.string().email().nullable(),\n    verified: z.boolean().nullable(),\n  }),\n});\n\nexport const getDiscordUserFields = defineUserSignupFields({\n  email: (data) => {\n    const discordData = discordDataSchema.parse(data);\n    // Users need to have an email for payment processing.\n    if (!discordData.profile.email) {\n      throw new Error(\n        \"You need to have an email address associated with your Discord account to sign up.\",\n      );\n    }\n    return discordData.profile.email;\n  },\n  username: (data) => {\n    const discordData = discordDataSchema.parse(data);\n    return discordData.profile.username;\n  },\n  isAdmin: (data) => {\n    const discordData = discordDataSchema.parse(data);\n    if (!discordData.profile.email || !discordData.profile.verified) {\n      return false;\n    }\n    return adminEmails.includes(discordData.profile.email);\n  },\n  // Set trial end date for new signups (14-day free trial)\n  trialEndsAt: () => {\n    return calculateTrialEndDate(new Date());\n  },\n});\n\nexport function getDiscordAuthConfig() {\n  return {\n    scopes: [\"identify\", \"email\"],\n  };\n}\n","import { Router } from \"express\";\n\nimport { ProviderConfig } from \"wasp/auth/providers/types\";\nimport type { EmailFromField } from \"wasp/server/email/core/types\";\n\nimport { getLoginRoute } from \"../email/login.js\";\nimport { getSignupRoute } from \"../email/signup.js\";\nimport { getRequestPasswordResetRoute } from \"../email/requestPasswordReset.js\";\nimport { resetPassword } from \"../email/resetPassword.js\";\nimport { verifyEmail } from \"../email/verifyEmail.js\";\nimport { GetVerificationEmailContentFn, GetPasswordResetEmailContentFn } from \"wasp/server/auth/email\";\nimport { defineHandler } from \"wasp/server/utils\";\nimport { env } from \"wasp/server\";\n\nimport { getEmailUserFields } from '../../../../../../../src/auth/userSignupFields'\nconst _waspUserSignupFields = getEmailUserFields\n\nimport { getVerificationEmailContent } from '../../../../../../../src/auth/email-and-pass/emails'\nconst _waspGetVerificationEmailContent: GetVerificationEmailContentFn = getVerificationEmailContent;\nimport { getPasswordResetEmailContent } from '../../../../../../../src/auth/email-and-pass/emails'\nconst _waspGetPasswordResetEmailContent: GetPasswordResetEmailContentFn = getPasswordResetEmailContent;\n\n\nconst fromField: EmailFromField = {\n    name: 'BaseSync',\n    email: 'noreply@basesync.app',\n};\n\nconst config: ProviderConfig = {\n    id: \"email\",\n    displayName: \"Email and password\",\n    createRouter() {\n        const router = Router();\n\n        const loginRoute = defineHandler(getLoginRoute());\n        router.post('/login', loginRoute);\n\n        const signupRoute = defineHandler(getSignupRoute({\n            userSignupFields: _waspUserSignupFields,\n            fromField,\n            clientRoute: '/email-verification',\n            getVerificationEmailContent: _waspGetVerificationEmailContent,\n            isEmailAutoVerified: false,\n        }));\n        router.post('/signup', signupRoute);\n\n        const requestPasswordResetRoute = defineHandler(getRequestPasswordResetRoute({\n            fromField,\n            clientRoute: '/password-reset',\n            getPasswordResetEmailContent: _waspGetPasswordResetEmailContent,\n        }));\n        router.post('/request-password-reset', requestPasswordResetRoute);\n\n        router.post('/reset-password', defineHandler(resetPassword));\n        router.post('/verify-email', defineHandler(verifyEmail));\n\n        return router;\n    },\n}\n\nexport default config;\n","import { Router } from \"express\";\n\nimport email from './config/email.js'\n\nconst providers = [\n  email,\n];\n\nconst router = Router();\n\n\nfor (const provider of providers) {\n  const { createRouter } = provider;\n  const providerRouter = createRouter(provider);\n  router.use(`/${provider.id}`, providerRouter);\n  console.log(`ðŸš€ \"${provider.displayName}\" auth initialized`);\n}\n\nexport default router;\n","import express from 'express'\n\nimport auth from 'wasp/core/auth'\nimport me from './me.js'\nimport logout from './logout.js'\n\nimport providersRouter from '../../auth/providers/index.js'\n\nconst router = express.Router()\n\nrouter.get('/me', auth, me)\nrouter.post('/logout', auth, logout)\nrouter.use('/', providersRouter)\n\nexport default router\n","import { paymentProcessor } from \"./paymentProcessor\";\n\nexport const paymentsWebhook = paymentProcessor.webhook;\nexport const paymentsMiddlewareConfigFn =\n  paymentProcessor.webhookMiddlewareConfigFn;\n","import express from 'express'\nimport { prisma } from 'wasp/server'\nimport { defineHandler } from 'wasp/server/utils'\nimport { MiddlewareConfigFn, globalMiddlewareConfigForExpress } from '../../middleware/index.js'\nimport auth from 'wasp/core/auth'\nimport { type AuthUserData, makeAuthUserIfPossible } from 'wasp/auth/user'\n\n\nimport { paymentsWebhook as _wasppaymentsWebhookfn } from '../../../../../../src/payment/webhook'\nimport { paymentsMiddlewareConfigFn as _wasppaymentsWebhookmiddlewareConfigFn } from '../../../../../../src/payment/webhook'\n\nconst idFn: MiddlewareConfigFn = x => x\n\n\nconst router = express.Router()\n\n\nconst paymentsWebhookMiddleware = globalMiddlewareConfigForExpress(_wasppaymentsWebhookmiddlewareConfigFn)\nrouter.post(\n  '/payments-webhook',\n  [auth, ...paymentsWebhookMiddleware],\n  defineHandler(\n    (\n      req: Parameters<typeof _wasppaymentsWebhookfn>[0] & { user: AuthUserData | null },\n      res: Parameters<typeof _wasppaymentsWebhookfn>[1],\n    ) => {\n      const context = {\n        user: makeAuthUserIfPossible(req.user),\n        entities: {\n          User: prisma.user,\n        },\n      }\n      return _wasppaymentsWebhookfn(req, res, context)\n    }\n  )\n)\n\nexport default router\n","import express from 'express'\nimport operations from './operations/index.js'\nimport { globalMiddlewareConfigForExpress } from '../middleware/index.js'\nimport auth from './auth/index.js'\nimport apis from './apis/index.js'\n\n\nconst router = express.Router()\nconst middleware = globalMiddlewareConfigForExpress()\n\nrouter.get('/', middleware,\n    function (_req, res) {\n      res.status(200).send();\n    }\n)\n\nrouter.use('/auth', middleware, auth)\nrouter.use('/operations', middleware, operations)\n// NOTE: Keep user-defined api routes last so they cannot override our routes.\n// Additionally, do not add middleware to these routes here. Instead, we add\n// it later to allow for middleware customization.\nrouter.use(apis)\n\nexport default router\n","import express from 'express'\n\nimport { HttpError } from 'wasp/server'\nimport indexRouter from './routes/index.js'\n\n// TODO: Consider extracting most of this logic into createApp(routes, path) function so that\n//   it can be used in unit tests to test each route individually.\n\nconst app = express()\n\n// NOTE: Middleware are installed on a per-router or per-route basis.\n\napp.use('/', indexRouter)\n\n// Custom error handler.\napp.use((err, _req, res, next) => {\n  // As by expressjs documentation, when the headers have already\n  // been sent to the client, we must delegate to the default error handler.\n  if (res.headersSent) { return next(err) }\n\n  if (err instanceof HttpError) {\n    return res.status(err.statusCode).json({ message: err.message, data: err.data })\n  }\n\n  // This forwards the error to the default express error handler.\n  // As described by expressjs documentation, the default error handler sets response status\n  // to err.status or err.statusCode if it is 4xx or 5xx, and if not, sets it to 500.\n  // It won't add any more info to it if server is running in production, which is exactly what we want,\n  // we want to share as little info as possible when error happens in production, for security reasons,\n  // so they will get only status code if set, or 500 if not, no extra info.\n  // In development it will also share the error stack though, which is useful.\n  // If the user wants to put more information about the error into the response, they should use HttpError.\n  return next(err)\n})\n\nexport default app\n","/**\n * Server Setup - Executed on server startup\n *\n * Overrides Wasp's default email sender with Resend HTTP API\n */\n\nimport type { ServerSetupFn } from 'wasp/server';\nimport { resendEmailSender } from './email/resendEmailSender';\nimport { emailSender } from 'wasp/server/email';\n\nconst serverSetup: ServerSetupFn = async () => {\n  console.log('[Server Setup] Initializing BaseSync server...');\n\n  // Override Wasp's emailSender module with Resend HTTP API\n  try {\n    if (emailSender) {\n      console.log('[Server Setup] Overriding Wasp emailSender with Resend HTTP API');\n\n      // Replace the send method\n      const originalSend = emailSender.send;\n      emailSender.send = async (args: any) => {\n        console.log('[Email Override] Intercepted email send, using Resend HTTP API');\n        return resendEmailSender.send(args);\n      };\n\n      console.log('[Server Setup] âœ“ Resend HTTP API activated (no SMTP)');\n    } else {\n      console.warn('[Server Setup] emailSender not found in wasp/server/email module');\n    }\n  } catch (error) {\n    console.error('[Server Setup] Failed to override email sender:', error);\n    // Don't throw - let the app start even if override fails\n  }\n\n  console.log('[Server Setup] âœ“ Server initialization complete');\n};\n\nexport default serverSetup;\n","import PgBoss from 'pg-boss';\nimport { config, env } from '../../../index.js';\nconst boss = createPgBoss();\nfunction createPgBoss() {\n    let pgBossNewOptions = {\n        connectionString: config.databaseUrl,\n    };\n    // Add an escape hatch for advanced configuration of pg-boss to overwrite our defaults.\n    if (env.PG_BOSS_NEW_OPTIONS) {\n        try {\n            pgBossNewOptions = JSON.parse(env.PG_BOSS_NEW_OPTIONS);\n        }\n        catch {\n            console.error('Environment variable PG_BOSS_NEW_OPTIONS was not parsable by JSON.parse()!');\n        }\n    }\n    return new PgBoss(pgBossNewOptions);\n}\nlet resolvePgBossStarted;\nlet rejectPgBossStarted;\n// PRIVATE API\n// Code that wants to access pg-boss must wait until it has been started.\nexport const pgBossStarted = new Promise((resolve, reject) => {\n    resolvePgBossStarted = resolve;\n    rejectPgBossStarted = reject;\n});\nvar PgBossStatus;\n(function (PgBossStatus) {\n    PgBossStatus[\"Unstarted\"] = \"Unstarted\";\n    PgBossStatus[\"Starting\"] = \"Starting\";\n    PgBossStatus[\"Started\"] = \"Started\";\n    PgBossStatus[\"Error\"] = \"Error\";\n})(PgBossStatus || (PgBossStatus = {}));\nlet pgBossStatus = PgBossStatus.Unstarted;\n// PRIVATE API\n/**\n * Prepares the target PostgreSQL database and begins job monitoring.\n * If the required database objects do not exist in the specified database,\n * `boss.start()` will automatically create them.\n * Ref: https://github.com/timgit/pg-boss/blob/master/docs/readme.md#start\n *\n * After making this call, we can send pg-boss jobs and they will be persisted and acted upon.\n * This should only be called once during a server's lifetime.\n */\nexport async function startPgBoss() {\n    // Ensure pg-boss can only be started once during a server's lifetime.\n    if (pgBossStatus !== PgBossStatus.Unstarted) {\n        return;\n    }\n    pgBossStatus = PgBossStatus.Starting;\n    console.log('Starting pg-boss...');\n    boss.on('error', (error) => console.error(error));\n    try {\n        await boss.start();\n    }\n    catch (error) {\n        console.error('pg-boss failed to start!');\n        console.error(error);\n        pgBossStatus = PgBossStatus.Error;\n        rejectPgBossStarted(boss);\n        return;\n    }\n    resolvePgBossStarted(boss);\n    console.log('pg-boss started!');\n    pgBossStatus = PgBossStatus.Started;\n}\n//# sourceMappingURL=pgBoss.js.map","/**\n * This is a definition of a job (think draft or invocable computation), not the running instance itself.\n * This can be submitted one or more times to be executed by some job executor via the same instance.\n * Once submitted, you get a SubmittedJob to track it later.\n */\nexport class Job {\n    jobName;\n    executorName;\n    constructor(jobName, executorName) {\n        this.jobName = jobName;\n        this.executorName = executorName;\n    }\n}\n/**\n * This is the result of submitting a Job to some executor.\n * It can be used by callers to track things, or call executor-specific subclass functionality.\n */\nexport class SubmittedJob {\n    job;\n    jobId;\n    constructor(job, jobId) {\n        this.job = job;\n        this.jobId = jobId;\n    }\n}\n//# sourceMappingURL=job.js.map","import { pgBossStarted } from './pgBoss.js';\nimport { Job, SubmittedJob } from '../job.js';\nexport const PG_BOSS_EXECUTOR_NAME = Symbol('PgBoss');\n// PRIVATE API\n/**\n * Creates an instance of PgBossJob which contains all of the necessary\n * information to submit a job to pg-boss.\n */\nexport function createJobDefinition({ jobName, defaultJobOptions, jobSchedule, entities, }) {\n    return new PgBossJob(jobName, defaultJobOptions, entities, jobSchedule);\n}\n// PRIVATE API\n/**\n * Uses the info about a job in PgBossJob to register a user defined job handler with pg-boss.\n * We expect this to be called once per job name. If called multiple times with the same name and different\n * functions, we will override the previous calls.\n */\nexport function registerJob({ job, jobFn }) {\n    // NOTE(shayne): We are not awaiting `pgBossStarted` here since we need to return an instance to the job\n    // template, or else the NodeJS module bootstrapping process will block and fail as it would then depend\n    // on a runtime resolution of the promise in `startServer()`.\n    // Since `pgBossStarted` will resolve in the future, it may appear possible to send pg-boss\n    // a job before we actually have registered the handler via `boss.work()`. However, even if NodeJS does\n    // not execute this callback before any job `submit()` calls, this is not a problem since pg-boss allows you\n    // to submit jobs even if there are no workers registered.\n    // Once they are registered, they will just start on the first job in their queue.\n    pgBossStarted.then(async (boss) => {\n        // As a safety precaution against undefined behavior of registering different\n        // functions for the same job name, remove all registered functions first.\n        await boss.offWork(job.jobName);\n        // This tells pg-boss to run given worker function when job with that name is submitted.\n        // Ref: https://github.com/timgit/pg-boss/blob/master/docs/readme.md#work\n        await boss.work(job.jobName, pgBossCallbackWrapper(jobFn, job.entities));\n        // If a job schedule is provided, we should schedule the recurring job.\n        // If the schedule name already exists, it's updated to the provided cron expression, arguments, and options.\n        // Ref: https://github.com/timgit/pg-boss/blob/master/docs/readme.md#scheduling\n        if (job.jobSchedule) {\n            const options = {\n                ...job.defaultJobOptions,\n                ...job.jobSchedule.options,\n            };\n            await boss.schedule(job.jobName, job.jobSchedule.cron, job.jobSchedule.args, options);\n        }\n    });\n}\n/**\n * This is an interface repesenting a job that can be submitted to pg-boss.\n * It is not yet submitted until the caller invokes `submit()` on an instance.\n * The caller can make as many calls to `submit()` as they wish.\n */\nexport class PgBossJob extends Job {\n    defaultJobOptions;\n    startAfter;\n    entities;\n    jobSchedule;\n    constructor(jobName, defaultJobOptions, entities, jobSchedule, startAfter) {\n        super(jobName, PG_BOSS_EXECUTOR_NAME);\n        this.defaultJobOptions = defaultJobOptions;\n        this.entities = entities;\n        this.jobSchedule = jobSchedule;\n        this.startAfter = startAfter;\n    }\n    delay(startAfter) {\n        return new PgBossJob(this.jobName, this.defaultJobOptions, this.entities, this.jobSchedule, startAfter);\n    }\n    async submit(jobArgs, jobOptions = {}) {\n        const boss = await pgBossStarted;\n        const jobId = await boss.send(this.jobName, jobArgs, {\n            ...this.defaultJobOptions,\n            ...(this.startAfter && { startAfter: this.startAfter }),\n            ...jobOptions,\n        });\n        return new PgBossSubmittedJob(boss, this, jobId);\n    }\n}\n/**\n * A pg-boss specific SubmittedJob that adds additional pg-boss functionality.\n */\nclass PgBossSubmittedJob extends SubmittedJob {\n    pgBoss;\n    constructor(boss, job, jobId) {\n        super(job, jobId);\n        this.pgBoss = {\n            cancel: () => boss.cancel(jobId),\n            resume: () => boss.resume(jobId),\n            // Coarcing here since pg-boss typings are not precise enough.\n            details: () => boss.getJobById(jobId),\n        };\n    }\n}\n/**\n * Wraps the normal pg-boss callback function to inject entities, as well as extract\n * the `data` property so the arguments passed into the job are the exact same as those received.\n */\nfunction pgBossCallbackWrapper(\n// jobFn - The user-defined async job callback function.\njobFn, \n// Entities used by job, passed into callback context.\nentities) {\n    return (args) => {\n        const context = { entities };\n        return jobFn(args.data, context);\n    };\n}\n//# sourceMappingURL=pgBossJob.js.map","const PLAUSIBLE_API_KEY = process.env.PLAUSIBLE_API_KEY!;\nconst PLAUSIBLE_SITE_ID = process.env.PLAUSIBLE_SITE_ID!;\nconst PLAUSIBLE_BASE_URL = process.env.PLAUSIBLE_BASE_URL;\n\nconst headers = {\n  \"Content-Type\": \"application/json\",\n  Authorization: `Bearer ${PLAUSIBLE_API_KEY}`,\n};\n\ntype PageViewsResult = {\n  results: {\n    [key: string]: {\n      value: number;\n    };\n  };\n};\n\ntype PageViewSourcesResult = {\n  results: [\n    {\n      source: string;\n      visitors: number;\n    },\n  ];\n};\n\nexport async function getDailyPageViews() {\n  const totalViews = await getTotalPageViews();\n  const prevDayViewsChangePercent = await getPrevDayViewsChangePercent();\n\n  return {\n    totalViews,\n    prevDayViewsChangePercent,\n  };\n}\n\nasync function getTotalPageViews() {\n  const response = await fetch(\n    `${PLAUSIBLE_BASE_URL}/v1/stats/aggregate?site_id=${PLAUSIBLE_SITE_ID}&metrics=pageviews`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${PLAUSIBLE_API_KEY}`,\n      },\n    },\n  );\n  if (!response.ok) {\n    throw new Error(`HTTP error! Status: ${response.status}`);\n  }\n  const json = (await response.json()) as PageViewsResult;\n\n  return json.results.pageviews.value;\n}\n\nasync function getPrevDayViewsChangePercent() {\n  // Calculate today, yesterday, and the day before yesterday's dates\n  const today = new Date();\n  const yesterday = new Date(today.setDate(today.getDate() - 1))\n    .toISOString()\n    .split(\"T\")[0];\n  const dayBeforeYesterday = new Date(\n    new Date().setDate(new Date().getDate() - 2),\n  )\n    .toISOString()\n    .split(\"T\")[0];\n\n  // Fetch page views for yesterday and the day before yesterday\n  const pageViewsYesterday = await getPageviewsForDate(yesterday);\n  const pageViewsDayBeforeYesterday =\n    await getPageviewsForDate(dayBeforeYesterday);\n\n  console.table({\n    pageViewsYesterday,\n    pageViewsDayBeforeYesterday,\n    typeY: typeof pageViewsYesterday,\n    typeDBY: typeof pageViewsDayBeforeYesterday,\n  });\n\n  let change = 0;\n  if (pageViewsYesterday === 0 || pageViewsDayBeforeYesterday === 0) {\n    return \"0\";\n  } else {\n    change =\n      ((pageViewsYesterday - pageViewsDayBeforeYesterday) /\n        pageViewsDayBeforeYesterday) *\n      100;\n  }\n  return change.toFixed(0);\n}\n\nasync function getPageviewsForDate(date: string) {\n  const url = `${PLAUSIBLE_BASE_URL}/v1/stats/aggregate?site_id=${PLAUSIBLE_SITE_ID}&period=day&date=${date}&metrics=pageviews`;\n  const response = await fetch(url, {\n    method: \"GET\",\n    headers: headers,\n  });\n  if (!response.ok) {\n    throw new Error(`HTTP error! Status: ${response.status}`);\n  }\n  const data = (await response.json()) as PageViewsResult;\n  return data.results.pageviews.value;\n}\n\nexport async function getSources() {\n  const url = `${PLAUSIBLE_BASE_URL}/v1/stats/breakdown?site_id=${PLAUSIBLE_SITE_ID}&property=visit:source&metrics=visitors`;\n  const response = await fetch(url, {\n    method: \"GET\",\n    headers: headers,\n  });\n  if (!response.ok) {\n    throw new Error(`HTTP error! Status: ${response.status}`);\n  }\n  const data = (await response.json()) as PageViewSourcesResult;\n  return data.results;\n}\n","import { Polar } from \"@polar-sh/sdk\";\n\n// Lazy initialization - only create client if Polar env vars are configured\nlet _polarClient: Polar | null = null;\n\nexport function getPolarClient(): Polar {\n  if (_polarClient) {\n    return _polarClient;\n  }\n\n  const accessToken = process.env.POLAR_ORGANIZATION_ACCESS_TOKEN;\n  const sandboxMode = process.env.POLAR_SANDBOX_MODE;\n\n  if (!accessToken || !sandboxMode) {\n    throw new Error(\n      'Polar payment provider is not configured. Set POLAR_ORGANIZATION_ACCESS_TOKEN and POLAR_SANDBOX_MODE environment variables.'\n    );\n  }\n\n  _polarClient = new Polar({\n    accessToken,\n    server: sandboxMode === \"true\" ? \"sandbox\" : \"production\",\n  });\n\n  return _polarClient;\n}\n\n// For backwards compatibility - but will throw if env vars not set\nexport const polarClient = new Proxy({} as Polar, {\n  get(target, prop) {\n    return getPolarClient()[prop as keyof Polar];\n  }\n});\n","import { listOrders } from \"@lemonsqueezy/lemonsqueezy.js\";\nimport Stripe from \"stripe\";\nimport { type DailyStats } from \"wasp/entities\";\nimport { type DailyStatsJob } from \"wasp/server/jobs\";\nimport { stripeClient } from \"../payment/stripe/stripeClient\";\nimport {\n  getDailyPageViews,\n  getSources,\n} from \"./providers/plausibleAnalyticsUtils\";\n// import { getDailyPageViews, getSources } from './providers/googleAnalyticsUtils';\nimport { paymentProcessor } from \"../payment/paymentProcessor\";\nimport { SubscriptionStatus } from \"../payment/plans\";\nimport { assertUnreachable } from \"../shared/utils\";\nimport { checkAndSendTrialExpiringEmails } from \"../server/emails/notificationSender\";\nimport { polarClient } from \"../payment/polar/polarClient\";\nimport { OrderStatus } from \"@polar-sh/sdk/models/components/orderstatus.js\";\n\nexport type DailyStatsProps = {\n  dailyStats?: DailyStats;\n  weeklyStats?: DailyStats[];\n  isLoading?: boolean;\n};\n\nexport const calculateDailyStats: DailyStatsJob<never, void> = async (\n  _args,\n  context,\n) => {\n  const nowUTC = new Date(Date.now());\n  nowUTC.setUTCHours(0, 0, 0, 0);\n\n  const yesterdayUTC = new Date(nowUTC);\n  yesterdayUTC.setUTCDate(yesterdayUTC.getUTCDate() - 1);\n\n  try {\n    const yesterdaysStats = await context.entities.DailyStats.findFirst({\n      where: {\n        date: {\n          equals: yesterdayUTC,\n        },\n      },\n    });\n\n    const userCount = await context.entities.User.count({});\n    // users can have paid but canceled subscriptions which terminate at the end of the period\n    // we don't want to count those users as current paying users\n    const paidUserCount = await context.entities.User.count({\n      where: {\n        subscriptionStatus: SubscriptionStatus.Active,\n      },\n    });\n\n    let userDelta = userCount;\n    let paidUserDelta = paidUserCount;\n    if (yesterdaysStats) {\n      userDelta -= yesterdaysStats.userCount;\n      paidUserDelta -= yesterdaysStats.paidUserCount;\n    }\n\n    let totalRevenue;\n    switch (paymentProcessor.id) {\n      case \"stripe\":\n        totalRevenue = await fetchTotalStripeRevenue();\n        break;\n      case \"lemonsqueezy\":\n        totalRevenue = await fetchTotalLemonSqueezyRevenue();\n        break;\n      case \"polar\":\n        totalRevenue = await fetchTotalPolarRevenue();\n        break;\n      default:\n        assertUnreachable(paymentProcessor.id);\n    }\n\n    const { totalViews, prevDayViewsChangePercent } = await getDailyPageViews();\n\n    let dailyStats = await context.entities.DailyStats.findUnique({\n      where: {\n        date: nowUTC,\n      },\n    });\n\n    if (!dailyStats) {\n      console.log(\"No daily stat found for today, creating one...\");\n      dailyStats = await context.entities.DailyStats.create({\n        data: {\n          date: nowUTC,\n          totalViews,\n          prevDayViewsChangePercent,\n          userCount,\n          paidUserCount,\n          userDelta,\n          paidUserDelta,\n          totalRevenue,\n        },\n      });\n    } else {\n      console.log(\"Daily stat found for today, updating it...\");\n      dailyStats = await context.entities.DailyStats.update({\n        where: {\n          id: dailyStats.id,\n        },\n        data: {\n          totalViews,\n          prevDayViewsChangePercent,\n          userCount,\n          paidUserCount,\n          userDelta,\n          paidUserDelta,\n          totalRevenue,\n        },\n      });\n    }\n    const sources = await getSources();\n\n    for (const source of sources) {\n      let visitors = source.visitors;\n      if (typeof source.visitors !== \"number\") {\n        visitors = parseInt(source.visitors);\n      }\n      await context.entities.PageViewSource.upsert({\n        where: {\n          date_name: {\n            date: nowUTC,\n            name: source.source,\n          },\n        },\n        create: {\n          date: nowUTC,\n          name: source.source,\n          visitors,\n          dailyStatsId: dailyStats.id,\n        },\n        update: {\n          visitors,\n        },\n      });\n    }\n\n    console.table({ dailyStats });\n\n    // ========================================================================\n    // Check and send trial expiring emails\n    // ========================================================================\n    console.log(\"[DailyStats] Checking for trial users needing expiration emails...\");\n    try {\n      await checkAndSendTrialExpiringEmails();\n      console.log(\"[DailyStats] Trial expiration email check complete\");\n    } catch (emailError: any) {\n      console.error(\"[DailyStats] Error sending trial expiration emails:\", emailError?.message);\n      // Don't fail the whole job if email sending fails\n    }\n  } catch (error: any) {\n    console.error(\"Error calculating daily stats: \", error);\n    await context.entities.Logs.create({\n      data: {\n        message: `Error calculating daily stats: ${error?.message}`,\n        level: \"job-error\",\n      },\n    });\n  }\n};\n\nasync function fetchTotalStripeRevenue() {\n  let totalRevenue = 0;\n  let params: Stripe.BalanceTransactionListParams = {\n    limit: 100,\n    // created: {\n    //   gte: startTimestamp,\n    //   lt: endTimestamp\n    // },\n    type: \"charge\",\n  };\n\n  let hasMore = true;\n  while (hasMore) {\n    const balanceTransactions =\n      await stripeClient.balanceTransactions.list(params);\n\n    for (const transaction of balanceTransactions.data) {\n      if (transaction.type === \"charge\") {\n        totalRevenue += transaction.amount;\n      }\n    }\n\n    if (balanceTransactions.has_more) {\n      // Set the starting point for the next iteration to the last object fetched\n      params.starting_after =\n        balanceTransactions.data[balanceTransactions.data.length - 1].id;\n    } else {\n      hasMore = false;\n    }\n  }\n\n  // Revenue is in cents so we convert to dollars (or your main currency unit)\n  return totalRevenue / 100;\n}\n\nasync function fetchTotalLemonSqueezyRevenue() {\n  try {\n    let totalRevenue = 0;\n    let hasNextPage = true;\n    let currentPage = 1;\n\n    while (hasNextPage) {\n      const { data: response } = await listOrders({\n        filter: {\n          storeId: process.env.LEMONSQUEEZY_STORE_ID,\n        },\n        page: {\n          number: currentPage,\n          size: 100,\n        },\n      });\n\n      if (response?.data) {\n        for (const order of response.data) {\n          totalRevenue += order.attributes.total;\n        }\n      }\n\n      hasNextPage = !response?.meta?.page.lastPage;\n      currentPage++;\n    }\n\n    // Revenue is in cents so we convert to dollars (or your main currency unit)\n    return totalRevenue / 100;\n  } catch (error) {\n    console.error(\"Error fetching Lemon Squeezy revenue:\", error);\n    throw error;\n  }\n}\n\nasync function fetchTotalPolarRevenue(): Promise<number> {\n  let totalRevenue = 0;\n\n  const result = await polarClient.orders.list({\n    limit: 100,\n  });\n\n  for await (const page of result) {\n    const orders = page.result.items || [];\n\n    for (const order of orders) {\n      if (order.status === OrderStatus.Paid && order.totalAmount > 0) {\n        totalRevenue += order.totalAmount;\n      }\n    }\n  }\n\n  // Revenue is in cents so we convert to dollars\n  return totalRevenue / 100;\n}\n","import { prisma } from 'wasp/server';\nimport { createJobDefinition } from 'wasp/server/jobs/core/pgBoss';\nconst entities = {\n    User: prisma.user,\n    DailyStats: prisma.dailyStats,\n    Logs: prisma.logs,\n    PageViewSource: prisma.pageViewSource,\n};\nconst jobSchedule = {\n    cron: \"0 * * * *\",\n    options: {},\n};\n// PUBLIC API\nexport const dailyStatsJob = createJobDefinition({\n    jobName: 'dailyStatsJob',\n    defaultJobOptions: {},\n    jobSchedule,\n    entities,\n});\n//# sourceMappingURL=dailyStatsJob.js.map","import { prisma } from 'wasp/server';\nimport { createJobDefinition } from 'wasp/server/jobs/core/pgBoss';\nconst entities = {\n    User: prisma.user,\n    AirtableConnection: prisma.airtableConnection,\n    GoogleSheetsConnection: prisma.googleSheetsConnection,\n    SyncConfig: prisma.syncConfig,\n    SyncLog: prisma.syncLog,\n};\nconst jobSchedule = {\n    cron: \"*/5 * * * *\",\n    options: {},\n};\n// PUBLIC API\nexport const syncJob = createJobDefinition({\n    jobName: 'syncJob',\n    defaultJobOptions: {},\n    jobSchedule,\n    entities,\n});\n//# sourceMappingURL=syncJob.js.map","import { registerJob } from 'wasp/server/jobs/core/pgBoss'\nimport { calculateDailyStats } from '../../../../../src/analytics/stats'\nimport { dailyStatsJob as _waspJobDefinition } from 'wasp/server/jobs'\n\nregisterJob({\n  job: _waspJobDefinition,\n  jobFn: calculateDailyStats,\n})\n","/**\n * Background Sync Job\n * Runs periodically to sync all active SyncConfigs\n * Executes every 5 minutes via cron schedule\n */\n\nimport type { SyncJob } from 'wasp/server/jobs';\nimport type { User } from 'wasp/entities';\nimport { syncAirtableToSheets } from '../sync/airtableToSheets';\nimport { syncSheetsToAirtable } from '../sync/sheetsToAirtable';\nimport { syncBidirectional } from '../sync/bidirectionalSync';\nimport { getValidAirtableToken, getValidGoogleToken } from '../utils/tokenManager';\nimport type { ConflictResolutionStrategy } from '../sync/conflictDetector';\nimport { shouldPauseSyncs, getSyncPauseReason, getSyncFrequency } from '../middleware/usageLimits';\nimport { sendSyncFailedEmail, checkAndSendUsageEmails } from '../emails/notificationSender';\n\n// ============================================================================\n// Types\n// ============================================================================\n\ninterface SyncJobResult {\n  /** Total sync configs processed */\n  totalProcessed: number;\n  /** Successful syncs */\n  successful: number;\n  /** Failed syncs */\n  failed: number;\n  /** Skipped syncs (missing connections, etc.) */\n  skipped: number;\n  /** Details per config */\n  results: Array<{\n    configId: string;\n    configName: string;\n    status: 'SUCCESS' | 'FAILED' | 'SKIPPED';\n    message: string;\n    duration?: number;\n    error?: string;\n  }>;\n  /** Job execution time */\n  duration: number;\n}\n\n// ============================================================================\n// Main Job Function\n// ============================================================================\n\n/**\n * Performs sync for all active SyncConfigs\n * This function is called by the PgBoss scheduler every 5 minutes\n */\nexport const performSync: SyncJob<never, void> = async (_args, context) => {\n  const startTime = Date.now();\n  const result: SyncJobResult = {\n    totalProcessed: 0,\n    successful: 0,\n    failed: 0,\n    skipped: 0,\n    results: [],\n    duration: 0,\n  };\n\n  console.log('\\n' + '='.repeat(80));\n  console.log('[SyncJob] Starting scheduled sync job...');\n  console.log('[SyncJob] Time:', new Date().toISOString());\n  console.log('='.repeat(80) + '\\n');\n\n  try {\n    // ========================================================================\n    // STEP 1: Fetch all active SyncConfigs\n    // ========================================================================\n    console.log('[SyncJob] Fetching active sync configurations...');\n\n    const activeSyncConfigs = await context.entities.SyncConfig.findMany({\n      where: {\n        isActive: true,\n      },\n      include: {\n        user: {\n          include: {\n            airtableConnections: true,\n            googleSheetsConnections: true,\n          },\n        },\n      },\n      orderBy: {\n        lastSyncAt: 'asc', // Prioritize configs that haven't synced recently\n      },\n    });\n\n    console.log(`[SyncJob] Found ${activeSyncConfigs.length} active sync configuration(s)`);\n\n    if (activeSyncConfigs.length === 0) {\n      console.log('[SyncJob] No active sync configurations found. Job complete.');\n      return;\n    }\n\n    // ========================================================================\n    // STEP 2: Process each SyncConfig\n    // ========================================================================\n    for (const config of activeSyncConfigs) {\n      result.totalProcessed++;\n      const configStartTime = Date.now();\n\n      console.log(`\\n[SyncJob] [${'='.repeat(70)}]`);\n      console.log(`[SyncJob] Processing config: ${config.name} (${config.id})`);\n      console.log(`[SyncJob] Direction: ${config.syncDirection}`);\n      console.log(`[SyncJob] User: ${config.user.email || config.user.username || config.userId}`);\n      console.log(`[SyncJob] [${'='.repeat(70)}]\\n`);\n\n      try {\n        // --------------------------------------------------------------------\n        // 2.0: Check if user's subscription/trial is active\n        // --------------------------------------------------------------------\n        if (shouldPauseSyncs(config.user as User)) {\n          const pauseReason = getSyncPauseReason(config.user as User);\n          console.warn(`[SyncJob] â¸ï¸  Syncs paused for user: ${pauseReason}`);\n          result.skipped++;\n          result.results.push({\n            configId: config.id,\n            configName: config.name,\n            status: 'SKIPPED',\n            message: pauseReason || 'Trial expired or subscription inactive',\n          });\n          continue;\n        }\n\n        // --------------------------------------------------------------------\n        // 2.1: Validate connections exist\n        // --------------------------------------------------------------------\n        const airtableConnection = config.user.airtableConnections?.[0];\n        const googleConnection = config.user.googleSheetsConnections?.[0];\n\n        if (!airtableConnection) {\n          const message = 'User has no Airtable connection';\n          console.warn(`[SyncJob] âš ï¸  ${message}`);\n          result.skipped++;\n          result.results.push({\n            configId: config.id,\n            configName: config.name,\n            status: 'SKIPPED',\n            message,\n          });\n\n          // Update sync status\n          await context.entities.SyncConfig.update({\n            where: { id: config.id },\n            data: { lastSyncStatus: 'failed' },\n          });\n\n          continue;\n        }\n\n        if (!googleConnection) {\n          const message = 'User has no Google Sheets connection';\n          console.warn(`[SyncJob] âš ï¸  ${message}`);\n          result.skipped++;\n          result.results.push({\n            configId: config.id,\n            configName: config.name,\n            status: 'SKIPPED',\n            message,\n          });\n\n          // Update sync status\n          await context.entities.SyncConfig.update({\n            where: { id: config.id },\n            data: { lastSyncStatus: 'failed' },\n          });\n\n          continue;\n        }\n\n        // --------------------------------------------------------------------\n        // 2.2: Get valid access tokens (auto-refreshes if needed)\n        // --------------------------------------------------------------------\n        console.log('[SyncJob] Getting valid access tokens...');\n\n        let airtableAccessToken: string;\n        let sheetsAccessToken: string;\n\n        try {\n          airtableAccessToken = await getValidAirtableToken(config.userId);\n          console.log('[SyncJob] âœ“ Got valid Airtable token');\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to get Airtable access token';\n          console.error(`[SyncJob] âœ— ${message}`);\n          result.skipped++;\n          result.results.push({\n            configId: config.id,\n            configName: config.name,\n            status: 'SKIPPED',\n            message,\n          });\n          continue;\n        }\n\n        try {\n          sheetsAccessToken = await getValidGoogleToken(config.userId);\n          console.log('[SyncJob] âœ“ Got valid Google Sheets token');\n        } catch (error) {\n          const message = error instanceof Error ? error.message : 'Failed to get Google Sheets access token';\n          console.error(`[SyncJob] âœ— ${message}`);\n          result.skipped++;\n          result.results.push({\n            configId: config.id,\n            configName: config.name,\n            status: 'SKIPPED',\n            message,\n          });\n          continue;\n        }\n\n        // --------------------------------------------------------------------\n        // 2.3: Execute sync based on direction\n        // --------------------------------------------------------------------\n        console.log(`[SyncJob] Executing ${config.syncDirection} sync...`);\n\n        let syncResult: any;\n        let syncStatus: 'success' | 'failed' | 'partial' = 'success';\n        let errorMessage: string | undefined;\n\n        try {\n          switch (config.syncDirection) {\n            case 'AIRTABLE_TO_SHEETS': {\n              syncResult = await syncAirtableToSheets({\n                airtableAccessToken,\n                sheetsAccessToken,\n                baseId: config.airtableBaseId,\n                tableId: config.airtableTableId,\n                spreadsheetId: config.googleSpreadsheetId,\n                sheetId: config.googleSheetId,\n                fieldMappings: config.fieldMappings\n                  ? JSON.parse(config.fieldMappings)\n                  : undefined,\n                includeHeader: true,\n                deleteExtraRows: false,\n                resolveLinkedRecords: true,\n                idColumnIndex: 0,\n                maxRetries: 3,\n                batchSize: 100,\n              });\n\n              syncStatus =\n                syncResult.errors.length === 0\n                  ? 'success'\n                  : syncResult.added + syncResult.updated > 0\n                    ? 'partial'\n                    : 'failed';\n              break;\n            }\n\n            case 'SHEETS_TO_AIRTABLE': {\n              syncResult = await syncSheetsToAirtable({\n                sheetsAccessToken,\n                airtableAccessToken,\n                spreadsheetId: config.googleSpreadsheetId,\n                sheetId: config.googleSheetId,\n                baseId: config.airtableBaseId,\n                tableId: config.airtableTableId,\n                fieldMappings: config.fieldMappings\n                  ? JSON.parse(config.fieldMappings)\n                  : undefined,\n                idColumnIndex: 0,\n                skipHeaderRow: true,\n                deleteExtraRecords: false,\n                resolveLinkedRecords: true,\n                createMissingLinkedRecords: false,\n                maxRetries: 3,\n                batchSize: 10,\n                validationMode: 'lenient',\n              });\n\n              syncStatus =\n                syncResult.errors.length === 0\n                  ? 'success'\n                  : syncResult.added + syncResult.updated > 0\n                    ? 'partial'\n                    : 'failed';\n              break;\n            }\n\n            case 'BIDIRECTIONAL': {\n              syncResult = await syncBidirectional({\n                syncConfigId: config.id,\n                airtableAccessToken,\n                sheetsAccessToken,\n                baseId: config.airtableBaseId,\n                tableId: config.airtableTableId,\n                spreadsheetId: config.googleSpreadsheetId,\n                sheetId: config.googleSheetId,\n                conflictResolution: config.conflictResolution as ConflictResolutionStrategy,\n                fieldMappings: config.fieldMappings\n                  ? JSON.parse(config.fieldMappings)\n                  : undefined,\n                idColumnIndex: 0,\n                includeHeader: true,\n                resolveLinkedRecords: true,\n                createMissingLinkedRecords: false,\n                maxRetries: 3,\n                batchSize: 10,\n                dryRun: false,\n              });\n\n              syncStatus =\n                syncResult.status === 'SUCCESS'\n                  ? 'success'\n                  : syncResult.status === 'PARTIAL'\n                    ? 'partial'\n                    : 'failed';\n              break;\n            }\n\n            default:\n              throw new Error(`Unknown sync direction: ${config.syncDirection}`);\n          }\n\n          // Log successful sync\n          console.log(`[SyncJob] âœ“ Sync completed successfully`);\n          console.log(`[SyncJob]   Status: ${syncStatus}`);\n          if (config.syncDirection === 'BIDIRECTIONAL') {\n            console.log(\n              `[SyncJob]   Airtable â†’ Sheets: ${syncResult.summary.airtableToSheets.added} added, ${syncResult.summary.airtableToSheets.updated} updated`\n            );\n            console.log(\n              `[SyncJob]   Sheets â†’ Airtable: ${syncResult.summary.sheetsToAirtable.added} added, ${syncResult.summary.sheetsToAirtable.updated} updated`\n            );\n            console.log(`[SyncJob]   Conflicts: ${syncResult.summary.conflicts.total} resolved`);\n          } else {\n            console.log(\n              `[SyncJob]   Records: ${syncResult.added} added, ${syncResult.updated} updated, ${syncResult.deleted} deleted`\n            );\n          }\n          console.log(`[SyncJob]   Duration: ${syncResult.duration}ms`);\n\n          if (syncResult.errors && syncResult.errors.length > 0) {\n            console.warn(`[SyncJob]   âš ï¸  ${syncResult.errors.length} error(s) occurred`);\n            errorMessage = syncResult.errors\n              .slice(0, 3)\n              .map((e: any) => e.message)\n              .join('; ');\n          }\n\n          // Check usage limits and send notification emails if approaching/reaching limits\n          try {\n            const recordCount = config.syncDirection === 'BIDIRECTIONAL'\n              ? (syncResult?.summary?.airtableToSheets?.total || 0) + (syncResult?.summary?.sheetsToAirtable?.total || 0)\n              : (syncResult?.total || 0);\n\n            if (recordCount > 0) {\n              await checkAndSendUsageEmails(config.user as User, recordCount);\n            }\n          } catch (usageEmailError) {\n            console.error('[SyncJob] Failed to send usage notification email:', usageEmailError);\n          }\n\n          result.successful++;\n        } catch (syncError) {\n          // Sync execution failed\n          syncStatus = 'failed';\n          errorMessage =\n            syncError instanceof Error ? syncError.message : String(syncError);\n          console.error(`[SyncJob] âœ— Sync failed:`, errorMessage);\n          console.error(`[SyncJob] Error stack:`, syncError instanceof Error ? syncError.stack : 'No stack');\n          result.failed++;\n\n          // Initialize syncResult with error info so it gets logged properly\n          syncResult = {\n            added: 0,\n            updated: 0,\n            deleted: 0,\n            total: 0,\n            errors: [{ message: errorMessage, type: 'SYNC_ERROR' }],\n            warnings: [],\n            duration: Date.now() - configStartTime,\n          };\n\n          // Send sync failed email notification\n          try {\n            await sendSyncFailedEmail(\n              config.user as User,\n              config.name,\n              errorMessage\n            );\n          } catch (emailError) {\n            console.error('[SyncJob] Failed to send sync failure email:', emailError);\n          }\n        }\n\n        // --------------------------------------------------------------------\n        // 2.4: Update SyncConfig and create SyncLog\n        // --------------------------------------------------------------------\n        console.log('[SyncJob] Updating sync metadata...');\n\n        const configDuration = Date.now() - configStartTime;\n\n        // Update SyncConfig\n        await context.entities.SyncConfig.update({\n          where: { id: config.id },\n          data: {\n            lastSyncAt: new Date(),\n            lastSyncStatus: syncStatus,\n          },\n        });\n\n        // Create SyncLog entry\n        await context.entities.SyncLog.create({\n          data: {\n            syncConfigId: config.id,\n            status:\n              syncStatus === 'success'\n                ? 'SUCCESS'\n                : syncStatus === 'partial'\n                  ? 'PARTIAL'\n                  : 'FAILED',\n            recordsSynced:\n              config.syncDirection === 'BIDIRECTIONAL'\n                ? (syncResult?.summary?.airtableToSheets?.added || 0) +\n                  (syncResult?.summary?.airtableToSheets?.updated || 0) +\n                  (syncResult?.summary?.sheetsToAirtable?.added || 0) +\n                  (syncResult?.summary?.sheetsToAirtable?.updated || 0)\n                : (syncResult?.added || 0) + (syncResult?.updated || 0),\n            recordsFailed: syncResult?.errors?.length || 0,\n            errors: errorMessage\n              ? JSON.stringify([{ message: errorMessage }])\n              : syncResult?.errors && syncResult.errors.length > 0\n                ? JSON.stringify(\n                    syncResult.errors.slice(0, 10).map((e: any) => ({\n                      message: e.message,\n                      recordId: e.recordId,\n                      type: e.type,\n                    }))\n                  )\n                : null,\n            startedAt: new Date(configStartTime),\n            completedAt: new Date(),\n            triggeredBy: 'scheduled',\n            direction: config.syncDirection,\n          },\n        });\n\n        // Add to results\n        result.results.push({\n          configId: config.id,\n          configName: config.name,\n          status: syncStatus === 'failed' ? 'FAILED' : 'SUCCESS',\n          message:\n            syncStatus === 'failed'\n              ? errorMessage || 'Sync failed'\n              : `Synced successfully (${syncStatus})`,\n          duration: configDuration,\n          error: errorMessage,\n        });\n\n        console.log('[SyncJob] âœ“ Sync metadata updated');\n      } catch (error) {\n        // Config processing failed catastrophically\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        console.error(`[SyncJob] âœ— Failed to process config:`, errorMessage);\n\n        result.failed++;\n        result.results.push({\n          configId: config.id,\n          configName: config.name,\n          status: 'FAILED',\n          message: 'Failed to process config',\n          error: errorMessage,\n        });\n\n        // Try to log the failure\n        try {\n          await context.entities.SyncLog.create({\n            data: {\n              syncConfigId: config.id,\n              status: 'FAILED',\n              recordsSynced: 0,\n              recordsFailed: 0,\n              errors: JSON.stringify([\n                { message: errorMessage, type: 'PROCESSING_ERROR' },\n              ]),\n              startedAt: new Date(configStartTime),\n              completedAt: new Date(),\n              triggeredBy: 'scheduled',\n              direction: config.syncDirection,\n            },\n          });\n\n          await context.entities.SyncConfig.update({\n            where: { id: config.id },\n            data: { lastSyncStatus: 'failed' },\n          });\n        } catch (logError) {\n          console.error(\n            '[SyncJob] Failed to log error:',\n            logError instanceof Error ? logError.message : String(logError)\n          );\n        }\n      }\n    }\n\n    // ========================================================================\n    // STEP 3: Log job summary\n    // ========================================================================\n    result.duration = Date.now() - startTime;\n\n    console.log('\\n' + '='.repeat(80));\n    console.log('[SyncJob] Job Summary:');\n    console.log(`[SyncJob]   Total Processed: ${result.totalProcessed}`);\n    console.log(`[SyncJob]   Successful: ${result.successful}`);\n    console.log(`[SyncJob]   Failed: ${result.failed}`);\n    console.log(`[SyncJob]   Skipped: ${result.skipped}`);\n    console.log(`[SyncJob]   Duration: ${result.duration}ms`);\n    console.log('[SyncJob]');\n    console.log('[SyncJob] Detailed Results:');\n    result.results.forEach((r, i) => {\n      const icon = r.status === 'SUCCESS' ? 'âœ“' : r.status === 'FAILED' ? 'âœ—' : 'âŠ˜';\n      console.log(\n        `[SyncJob]   ${i + 1}. ${icon} ${r.configName} - ${r.message}${r.duration ? ` (${r.duration}ms)` : ''}`\n      );\n      if (r.error) {\n        console.log(`[SyncJob]      Error: ${r.error}`);\n      }\n    });\n    console.log('='.repeat(80) + '\\n');\n  } catch (error) {\n    // Job-level error\n    console.error(\n      '\\n[SyncJob] âœ— CRITICAL ERROR in sync job:',\n      error instanceof Error ? error.message : String(error)\n    );\n    console.error('[SyncJob] Stack trace:', error);\n\n    // Don't crash the job scheduler - log and return\n    console.error('[SyncJob] Job will retry on next schedule\\n');\n  }\n};\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Gets a user-friendly description of the sync direction\n */\nfunction getSyncDirectionDescription(direction: string): string {\n  switch (direction) {\n    case 'AIRTABLE_TO_SHEETS':\n      return 'Airtable â†’ Sheets';\n    case 'SHEETS_TO_AIRTABLE':\n      return 'Sheets â†’ Airtable';\n    case 'BIDIRECTIONAL':\n      return 'Bidirectional';\n    default:\n      return direction;\n  }\n}\n\n/**\n * Truncates error messages for logging\n */\nfunction truncateError(error: string, maxLength: number = 200): string {\n  if (error.length <= maxLength) return error;\n  return error.substring(0, maxLength) + '...';\n}\n","import { registerJob } from 'wasp/server/jobs/core/pgBoss'\nimport { performSync } from '../../../../../src/server/jobs/syncJob'\nimport { syncJob as _waspJobDefinition } from 'wasp/server/jobs'\n\nregisterJob({\n  job: _waspJobDefinition,\n  jobFn: performSync,\n})\n","import http from 'http'\n\nimport app from './app.js'\nimport { config } from 'wasp/server'\n\nimport serverSetup from '../../../../src/server/serverSetup'\nimport { ServerSetupFn } from 'wasp/server'\nimport { ServerSetupFnContext } from 'wasp/server/types'\n\nimport { startPgBoss } from 'wasp/server/jobs/core/pgBoss'\nimport './jobs/core/allJobs.js'\n\n\nconst startServer = async () => {\n  await startPgBoss()\n\n  const port = normalizePort(config.port)\n  app.set('port', port)\n\n  const server = http.createServer(app)\n\n  const serverSetupFnContext: ServerSetupFnContext = { app, server }\n  await (serverSetup as ServerSetupFn)(serverSetupFnContext)\n\n\n  server.listen(port)\n\n  server.on('error', (error: NodeJS.ErrnoException) => {\n    if (error.syscall !== 'listen') throw error\n    const bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port\n    // handle specific listen errors with friendly messages\n    switch (error.code) {\n    case 'EACCES':\n      console.error(bind + ' requires elevated privileges')\n      process.exit(1)\n    case 'EADDRINUSE':\n      console.error(bind + ' is already in use')\n      process.exit(1)\n    default:\n      throw error\n    }\n  })\n\n  server.on('listening', () => {\n    const addr = server.address()\n    const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port\n    console.log('Server listening on ' + bind)\n  })\n}\n\nstartServer().catch(e => console.error(e))\n\n/**\n * Normalize a port into a number, string, or false.\n */\nfunction normalizePort (val) {\n  const port = parseInt(val, 10)\n  if (isNaN(port)) return val // named pipe\n  if (port >= 0) return port // port number\n  return false\n}\n"],"names":["config","InternalPrismaClient","prisma","auth","sleep","SubscriptionStatus","PaymentPlanId","updateIsUserAdminById","getPaginatedUsers","updateUsername","requestEmailChange","crypto","confirmEmailChange","updateNotificationPreferences","changePassword","exportUserData","deleteAccount","initEmailSender","generateCheckoutSession","getCustomerPortalUrl","getAdminOverviewStats","getRecentActivity","searchUsers","getOnlineUsers","getUserDetail","updateUser","deleteUser","getActiveSyncs","getFailedSyncs","getSyncMonitor","pauseResumeSync","triggerManualSyncAdmin","forceRefreshUserToken","REQUIRED_SCOPES","generateAuthorizationUrl","exchangeCodeForTokens","refreshAccessToken","validateScopes","initiateAirtableAuth","completeAirtableAuth","getAirtableConnectionStatus","disconnectAirtable","initiateGoogleAuth","completeGoogleAuth","getGoogleConnectionStatus","disconnectGoogle","fetchWithRetry","retryWithBackoff","finalizeSyncResult","chunkArray","isRowEmpty","normalizeFieldValue","airtableChanged","refreshAirtableToken","errorMessage","refreshGoogleToken","emailSender","triggerManualSync","runInitialSync","createSyncConfig","updateSyncConfig","deleteSyncConfig","toggleSyncActive","runConnectionDiagnostics","clearReauthFlags","sendTestEmails","getDailyStats","listUserAirtableBases","airtableClient.listBases","getAirtableTableSchema","airtableClient.getBaseSchema","getAirtableBaseTables","validateSpreadsheetUrl","googleClient.validateAndGetSpreadsheet","googleClient.GoogleSheetsError","getSpreadsheetSheets","googleClient.getSpreadsheet","getSheetColumnHeaders","googleClient.getSheetData","googleClient.columnNumberToLetter","getUserSyncConfigs","getSyncConfigById","getSyncLogs","getUserUsage","router","ensureValidArgs","waspServerConfig","z","email","providersRouter","_wasppaymentsWebhookmiddlewareConfigFn","_wasppaymentsWebhookfn","operations","apis","indexRouter","PgBossStatus","entities","jobSchedule","_waspJobDefinition"],"mappings":"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"}